diff --git a/docs/sdy_dialect.md b/docs/sdy_dialect.md
index de07f95..25a74f7 100755
--- a/docs/sdy_dialect.md
+++ b/docs/sdy_dialect.md
@@ -39,9 +39,12 @@ Example:
 ```
 
 **Constraints:**
-- Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
 - Elements in `gathering_axes` must satisfy the constraints listed in
   `AxisRefListAttr`.
+- `out_sharding` must satisfy the constraints listed in
+  `TensorShardingAttr`.
+- The operand must have a sharding.
+- Both operand and result shardings should be bound to the same `MeshAttr`.
 - Applying `gathering_axes` to the operand sharding gets `out_sharding`.
 
 Traits: `SameOperandsAndResultType`
@@ -69,51 +72,6 @@ Interfaces: `InferTypeOpInterface`, `Sdy_CollectiveOpInterface`
 | `result` | tensor of any type values
 
 
-### `sdy.all_reduce` (sdy::AllReduceOp)
-
-_Perform an all-reduce comunication along axes_
-
-
-Syntax:
-
-```
-operation ::= `sdy.all_reduce` $reduction_axes $tensor `out_sharding````=```$out_sharding attr-dict `:` type($result)
-```
-
-Reduces chunks of a tensor along axes specified in `reduction_axes`.
-The order of `reduction_axes` is not important for the result, but can
-affect the order of the corresponding replica groups.
-
-**Constraints:**
-- Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
-- `reduction_axes` must satisfy the constraints listed in `AxisRefListAttr`;
-- `reduction_axes` must not overlap with the operand sharding axes;
-
-Traits: `SameOperandsAndResultType`
-
-Interfaces: `InferTypeOpInterface`, `Sdy_CollectiveOpInterface`
-
-#### Attributes:
-
-<table>
-<tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr>
-<tr><td><code>reduction_axes</code></td><td>::mlir::sdy::AxisRefListAttr</td><td>List of axis refs</td></tr>
-<tr><td><code>out_sharding</code></td><td>::mlir::sdy::TensorShardingAttr</td><td>Tensor sharding</td></tr>
-</table>
-
-#### Operands:
-
-| Operand | Description |
-| :-----: | ----------- |
-| `tensor` | tensor of any type values
-
-#### Results:
-
-| Result | Description |
-| :----: | ----------- |
-| `result` | tensor of any type values
-
-
 ### `sdy.all_slice` (sdy::AllSliceOp)
 
 _Performs a dynamic-slice operation along axes_
@@ -148,7 +106,10 @@ Example:
 **Constraints:**
 - Elements in `slicing_axes` must satisfy the constraints listed in
   `AxisRefListAttr`.
-- Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
+- `out_sharding` must satisfy the constraints listed in
+  `TensorShardingAttr`.
+- The operand must have a sharding.
+- Both operand and result shardings should be bound to the same `MeshAttr`.
 - Applying `slicing_axes` to the operand sharding gets `out_sharding`.
 
 Traits: `SameOperandsAndResultType`
@@ -211,8 +172,11 @@ Example:
 ```
 
 **Constraints:**
-- Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
 - `axes` must satisfy the constraints listed in `AxisRefListAttr`.
+- `out_sharding` must satisfy the constraints listed in
+  `TensorShardingAttr`.
+- The operand must have a sharding.
+- Both operand and result shardings should be bound to the same `MeshAttr`.
 - `src_dim` and `tgt_dim` must be valid dimensions (positive and less than
   rank of tensor), and different from each other.
 - Moving `axes` from `src_dim` to `tgt_dim` in the operand sharding gets
@@ -278,7 +242,10 @@ sdy.mesh @mesh = <["a"=2, "b"=2, "c"=4, "d"=2, "e"=2, "f"=2]>
 ```
 
 **Constraints:**
-- Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
+- `out_sharding` must satisfy the constraints listed in
+  `TensorShardingAttr`.
+- The operand must have a sharding.
+- Both operand and result shardings should be bound to the same `MeshAttr`.
 - For each dimension, the product of sharding axis sizes in `out_sharding`
   must match that of the corresponding operand dimension sharding.
 
diff --git a/docs/sdy_op_interfaces.md b/docs/sdy_op_interfaces.md
index 12ade1b..90f2edd 100755
--- a/docs/sdy_op_interfaces.md
+++ b/docs/sdy_op_interfaces.md
@@ -5,12 +5,6 @@
 Interface for all collective ops. Encapsulates common get/set for
 outSharding attribute.
 
-**Constraints:**
-- Operand must have a sharding.
-- `out_sharding` is valid w.r.t the corresponding type.
-- MeshAttr of result and operand is the same.
-- Same rank for the operand and result sharding.
-
 ### Methods:
 #### `getOutSharding`
 
@@ -30,24 +24,6 @@ Sets the output tensor sharding of the collective op.
 
 NOTE: This method *must* be implemented by the user.
 
-#### `getTensor`
-
-```c++
-::mlir::TypedValue<::mlir::TensorType> getTensor();
-```
-Get the tensor operand of the collective op.
-
-NOTE: This method *must* be implemented by the user.
-
-#### `getType`
-
-```c++
-::mlir::Type getType();
-```
-Get the type of the collective op result.
-
-NOTE: This method *must* be implemented by the user.
-
 ## ShardableDataFlowOpInterface (`Sdy_ShardableDataFlowOpInterface`)
 
 An op interface that allows shardy to propagate shardings through data flow
diff --git a/shardy/dialect/sdy/ir/BUILD b/shardy/dialect/sdy/ir/BUILD
index cfe1835..68bf069 100644
--- a/shardy/dialect/sdy/ir/BUILD
+++ b/shardy/dialect/sdy/ir/BUILD
@@ -166,7 +166,6 @@ cc_library(
         "parsers.h",
         "printers.h",
         "utils.h",
-        "verifiers.h",
     ],
     deps = [
         ":attrs_inc",
diff --git a/shardy/dialect/sdy/ir/attrs.td b/shardy/dialect/sdy/ir/attrs.td
index ed80d14..577334f 100644
--- a/shardy/dialect/sdy/ir/attrs.td
+++ b/shardy/dialect/sdy/ir/attrs.td
@@ -793,18 +793,6 @@ def Sdy_TensorSharding : AttrDef<Sdy_Dialect, "TensorSharding"> {
     // `localTensorType` will be a multiple of the global tensor type returned.
     RankedTensorType getGlobalTensorType(RankedTensorType localTensorType,
                                          MeshAttr mesh) const;
-
-    // Returns true if axes of all dimensions are the same.
-    bool areDimAxesEqual(TensorShardingAttr otherSharding) const {
-      auto left = getDimShardings();
-      auto right = otherSharding.getDimShardings();
-      return left.size() == right.size() &&
-             llvm::all_of(llvm::zip_equal(left, right),
-                          [](auto&& pair) {
-                            return std::get<0>(pair).getAxes() ==
-                                   std::get<1>(pair).getAxes();
-                          });
-    }
     }];
 }
 
@@ -1057,7 +1045,7 @@ def Sdy_AxisRefList : ArrayOfAttr<Sdy_Dialect, "AxisRefList",
 def Sdy_EmptyAxisList: AttrConstraint<
     CPred<"$_self.isa<AxisRefListAttr>() && "
           "$_self.cast<AxisRefListAttr>().empty()">,
-    "axis list is empty">;
+    "is empty axis list">;
 
 def Sdy_ListOfAxisRefLists : ArrayOfAttr<Sdy_Dialect, "ListOfAxisRefLists",
                                  "list_of_axis_ref_lists", "AxisRefListAttr"> {
diff --git a/shardy/dialect/sdy/ir/canonicalization.cc b/shardy/dialect/sdy/ir/canonicalization.cc
index 4be1a41..373860e 100644
--- a/shardy/dialect/sdy/ir/canonicalization.cc
+++ b/shardy/dialect/sdy/ir/canonicalization.cc
@@ -175,11 +175,6 @@ void AllSliceOp::getCanonicalizationPatterns(RewritePatternSet& results,
   results.add<AllSliceNoopPattern>(context);
 }
 
-void AllReduceOp::getCanonicalizationPatterns(RewritePatternSet& results,
-                                              MLIRContext* context) {
-  results.add<AllReduceNoopPattern>(context);
-}
-
 void AllToAllOp::getCanonicalizationPatterns(RewritePatternSet& results,
                                              MLIRContext* context) {
   results.add<AllToAllNoopPattern>(context);
diff --git a/shardy/dialect/sdy/ir/canonicalization.td b/shardy/dialect/sdy/ir/canonicalization.td
index edd8983..2caf35d 100644
--- a/shardy/dialect/sdy/ir/canonicalization.td
+++ b/shardy/dialect/sdy/ir/canonicalization.td
@@ -37,8 +37,6 @@ def AllSliceNoopPattern : Pat<(Sdy_AllSliceOp $tensor, Sdy_EmptyAxesPerDim:$slic
 def AllToAllNoopPattern : Pat<(Sdy_AllToAllOp $tensor, $srcDim, $tgtDim, Sdy_EmptyAxisList:$axes, $outSharding),
                                (replaceWithValue $tensor)>;
 
-def AllReduceNoopPattern : Pat<(Sdy_AllReduceOp $tensor, Sdy_EmptyAxisList:$reductionAxes, $resultSharding),
-                               (replaceWithValue $tensor)>;
 
 def AllSliceOfAllGatherPattern : Pat<
   (Sdy_AllSliceOp (Sdy_AllGatherOp $tensor, $gatheringAxes, $_), $slicingAxes, $_),
diff --git a/shardy/dialect/sdy/ir/dialect.cc b/shardy/dialect/sdy/ir/dialect.cc
index 354ad2d..8f54ebc 100644
--- a/shardy/dialect/sdy/ir/dialect.cc
+++ b/shardy/dialect/sdy/ir/dialect.cc
@@ -121,7 +121,8 @@ namespace {
 // terminator.
 // Else returns an empty vector.
 template <typename RegionOpTy>
-SmallVector<Value> getEdgeSourcesFromRegionBasedOp(Value owner, RegionOpTy op) {
+SmallVector<Value> getEdgeSourcesFromRegionBasedOp(Value owner,
+                                                   RegionOpTy op) {
   static_assert(
       OpTrait::template hasSingleBlockImplicitTerminator<RegionOpTy>::value);
   assert(getOwningOp(owner) == op.getOperation());
@@ -327,6 +328,7 @@ AxisRefAttr::getMeshComparator(MeshAttr mesh) {
     StringRef lhsName = lhs.getName();
     StringRef rhsName = rhs.getName();
     if (lhsName == rhsName) {
+
       // Both axis-refs have the same name, defer to AxisRefAttr::operator<
       return lhs < rhs;
     }
@@ -1207,7 +1209,8 @@ DataFlowEdgeOp DataFlowEdgeOp::lookup(OpOperand& source) {
 }
 
 TensorShardingAttr DataFlowEdgeOp::transformTargetSharding(
-    TensorShardingAttr sharding, DataFlowShardingTransformType transformType) {
+    TensorShardingAttr sharding,
+    DataFlowShardingTransformType transformType) {
   return castOwningShardableDataFlowOp(getInput())
       .transformTargetSharding(getInput(), sharding, transformType);
 }
diff --git a/shardy/dialect/sdy/ir/dialect.h b/shardy/dialect/sdy/ir/dialect.h
index 38caf83..e3f464f 100644
--- a/shardy/dialect/sdy/ir/dialect.h
+++ b/shardy/dialect/sdy/ir/dialect.h
@@ -40,7 +40,6 @@ limitations under the License.
 #include "mlir/Interfaces/SideEffectInterfaces.h"
 #include "mlir/Support/LLVM.h"
 #include "shardy/dialect/sdy/ir/constants.h"
-#include "shardy/dialect/sdy/ir/verifiers.h"
 
 // IWYU pragma: end_keep
 
diff --git a/shardy/dialect/sdy/ir/op_interface.td b/shardy/dialect/sdy/ir/op_interface.td
index 1d40777..1bc7344 100644
--- a/shardy/dialect/sdy/ir/op_interface.td
+++ b/shardy/dialect/sdy/ir/op_interface.td
@@ -18,7 +18,6 @@ limitations under the License.
 
 include "mlir/IR/OpBase.td"
 include "shardy/dialect/sdy/ir/attrs.td"
-include "mlir/Interfaces/InferTypeOpInterface.td"
 
 //===----------------------------------------------------------------------===//
 // ShardableDataFlowOpInterface
@@ -246,15 +245,9 @@ def Sdy_CollectiveOpInterface : OpInterface<"CollectiveOpInterface"> {
   let description = [{
     Interface for all collective ops. Encapsulates common get/set for
     outSharding attribute.
-
-    **Constraints:**
-    - Operand must have a sharding.
-    - `out_sharding` is valid w.r.t the corresponding type.
-    - MeshAttr of result and operand is the same.
-    - Same rank for the operand and result sharding.
   }];
   let cppNamespace = "::mlir::sdy";
-  let methods = [
+    let methods = [
     InterfaceMethod<
       /*desc=*/[{
         Returns the output tensor sharding of the collective op.
@@ -270,19 +263,10 @@ def Sdy_CollectiveOpInterface : OpInterface<"CollectiveOpInterface"> {
       /*methodName=*/"setOutShardingAttr",
       /*args=*/(ins "::mlir::sdy::TensorShardingAttr":$sharding)
     >,
-    InterfaceMethod<
-      /*desc=*/[{ Get the tensor operand of the collective op. }],
-      /*retType=*/"::mlir::TypedValue<::mlir::TensorType>",
-      /*methodName=*/"getTensor"
-    >,
-    InterfaceMethod<
-      /*desc=*/[{ Get the type of the collective op result. }],
-      /*retType=*/"::mlir::Type",
-      /*methodName=*/"getType"
-    >
   ];
   let verify = [{
-    return ::mlir::sdy::verifyCollectiveOp($_op);
+    // TODO(kostiantynl): b/391574176 - add a common collective op verify
+    return success();
   }];
 }
 
diff --git a/shardy/dialect/sdy/ir/ops.td b/shardy/dialect/sdy/ir/ops.td
index b577404..eec6b7d 100644
--- a/shardy/dialect/sdy/ir/ops.td
+++ b/shardy/dialect/sdy/ir/ops.td
@@ -476,9 +476,12 @@ def Sdy_AllGatherOp : Sdy_Op<"all_gather",
     ```
 
     **Constraints:**
-    - Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
     - Elements in `gathering_axes` must satisfy the constraints listed in
       `AxisRefListAttr`.
+    - `out_sharding` must satisfy the constraints listed in
+      `TensorShardingAttr`.
+    - The operand must have a sharding.
+    - Both operand and result shardings should be bound to the same `MeshAttr`.
     - Applying `gathering_axes` to the operand sharding gets `out_sharding`.
   }];
 
@@ -520,7 +523,10 @@ def Sdy_AllSliceOp : Sdy_Op<"all_slice",
     **Constraints:**
     - Elements in `slicing_axes` must satisfy the constraints listed in
       `AxisRefListAttr`.
-    - Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
+    - `out_sharding` must satisfy the constraints listed in
+      `TensorShardingAttr`.
+    - The operand must have a sharding.
+    - Both operand and result shardings should be bound to the same `MeshAttr`.
     - Applying `slicing_axes` to the operand sharding gets `out_sharding`.
   }];
 
@@ -564,8 +570,11 @@ def Sdy_AllToAllOp : Sdy_Op<"all_to_all",
     ```
 
     **Constraints:**
-    - Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
     - `axes` must satisfy the constraints listed in `AxisRefListAttr`.
+    - `out_sharding` must satisfy the constraints listed in
+      `TensorShardingAttr`.
+    - The operand must have a sharding.
+    - Both operand and result shardings should be bound to the same `MeshAttr`.
     - `src_dim` and `tgt_dim` must be valid dimensions (positive and less than
       rank of tensor), and different from each other.
     - Moving `axes` from `src_dim` to `tgt_dim` in the operand sharding gets
@@ -614,7 +623,10 @@ def Sdy_CollectivePermuteOp : Sdy_Op<"collective_permute",
     ```
 
     **Constraints:**
-    - Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
+    - `out_sharding` must satisfy the constraints listed in
+      `TensorShardingAttr`.
+    - The operand must have a sharding.
+    - Both operand and result shardings should be bound to the same `MeshAttr`.
     - For each dimension, the product of sharding axis sizes in `out_sharding`
       must match that of the corresponding operand dimension sharding.
   }];
@@ -628,29 +640,5 @@ def Sdy_CollectivePermuteOp : Sdy_Op<"collective_permute",
   let hasVerifier = 1;
 }
 
-def Sdy_AllReduceOp: Sdy_Op<"all_reduce",
-    [SameOperandsAndResultType, InferTypeOpInterface, Sdy_CollectiveOpInterface]> {
-  let summary = "Perform an all-reduce comunication along axes";
-  let description = [{
-    Reduces chunks of a tensor along axes specified in `reduction_axes`.
-    The order of `reduction_axes` is not important for the result, but can
-    affect the order of the corresponding replica groups.
-
-    **Constraints:**
-    - Must satisfy the constraints listed in `Sdy_CollectiveOpInterface`.
-    - `reduction_axes` must satisfy the constraints listed in `AxisRefListAttr`;
-    - `reduction_axes` must not overlap with the operand sharding axes;
-  }];
-
-  let arguments = (ins
-    AnyTensor:$tensor,
-    Sdy_AxisRefList:$reduction_axes,
-    Sdy_TensorSharding:$out_sharding
-  );
-  let results = (outs AnyTensor:$result);
-  let assemblyFormat = "$reduction_axes $tensor `out_sharding````=```$out_sharding attr-dict `:` type($result)";
-  let hasVerifier = 1;
-  let hasCanonicalizer = 1;
-}
 
 #endif  // SDY_OPS
diff --git a/shardy/dialect/sdy/ir/test/collective_canonicalization.mlir b/shardy/dialect/sdy/ir/test/collective_canonicalization.mlir
index 613f1fd..62cf698 100644
--- a/shardy/dialect/sdy/ir/test/collective_canonicalization.mlir
+++ b/shardy/dialect/sdy/ir/test/collective_canonicalization.mlir
@@ -23,13 +23,6 @@ func.func @null_all_to_all(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<
   return %0 : tensor<16x2xf32>
 }
 
-// CHECK-LABEL: func @null_all_reduce
-func.func @null_all_reduce(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y"}, {"x"}]>}) -> tensor<16x2xf32> {
-  // CHECK-NEXT: return %arg0 : tensor<16x2xf32>
-  %0 = sdy.all_reduce {} %arg0 out_sharding=<@mesh, [{"y"}, {"x"}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
-
 // CHECK-LABEL: func @all_slice_of_all_gather
 func.func @all_slice_of_all_gather(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y"}, {"x"}]>}) -> tensor<16x2xf32> {
   // TODO(kostiantynl): orphaned all_gather should be removed.
diff --git a/shardy/dialect/sdy/ir/test/collective_parse_print.mlir b/shardy/dialect/sdy/ir/test/collective_parse_print.mlir
index e2f892f..9207d1f 100644
--- a/shardy/dialect/sdy/ir/test/collective_parse_print.mlir
+++ b/shardy/dialect/sdy/ir/test/collective_parse_print.mlir
@@ -5,8 +5,6 @@ sdy.mesh @mesh2 = <["x"=2, "y"=2, "z"=2]>
 sdy.mesh @mesh3 = <["x"=4, "y"=2]>
 sdy.mesh @mesh4 = <["x"=8, "y"=2, "z"=2]>
 sdy.mesh @mesh5 = <["x"=2, "y"=2, "z"=4, "w"=4]>
-sdy.mesh @mesh6 = <["x"=4, "y"=4]>
-sdy.mesh @mesh7 = <["x"=16, "y"=2]>
 
 // CHECK-LABEL: func @all_gather1
 func.func @all_gather1(%arg0 : tensor<16x8xf32> {sdy.sharding=#sdy.sharding<@mesh1, [{"y"}, {"x"}]>}) -> tensor<16x8xf32> {
@@ -210,40 +208,3 @@ func.func @collective_permute_replace_sub_axes_multiple_dims(%arg0 : tensor<16x8
   %0 = sdy.collective_permute %arg0 out_sharding=<@mesh5, [{"z":(1)2, "x", "y"}, {"z":(2)2, "w":(1)2}]> : tensor<16x8xf32>
   return %0 : tensor<16x8xf32>
 }
-
-// CHECK-LABEL: func @all_reduce
-func.func @all_reduce(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh1, [{}, {"x"}]>}) -> tensor<16x2xf32> {
-  // CHECK-NEXT: sdy.all_reduce {"y"} %arg0 out_sharding=<@mesh1, [{}, {"x"}]> :  tensor<16x2xf32>
-  %0 = sdy.all_reduce {"y"} %arg0 out_sharding=<@mesh1, [{}, {"x"}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
-
-sdy.mesh @mesh_xyzw = <["x"=2, "y"=2, "z"=2, "w"=2]>
-
-// CHECK-LABEL: func @all_reduce_many_axes
-func.func @all_reduce_many_axes(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh_xyzw, [{"y"}, {"x"}]>}) -> tensor<16x2xf32> {
-  // CHECK-NEXT: sdy.all_reduce {"z", "w"} %arg0 out_sharding=<@mesh_xyzw, [{"y"}, {"x"}]> :  tensor<16x2xf32>
-  %0 = sdy.all_reduce {"z", "w"} %arg0 out_sharding=<@mesh_xyzw, [{"y"}, {"x"}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
-
-// CHECK-LABEL: func @all_reduce_split_axis
-func.func @all_reduce_split_axis(%arg0 : tensor<16x32xf32> {sdy.sharding=#sdy.sharding<@mesh7, [{"y"}, {"x": (2)4}]>}) -> tensor<16x32xf32> {
-  // CHECK-NEXT: sdy.all_reduce {"x":(1)2} %arg0 out_sharding=<@mesh7, [{"y"}, {"x":(2)4}]> :  tensor<16x32xf32>
-  %0 = sdy.all_reduce {"x":(1)2} %arg0 out_sharding=<@mesh7, [{"y"}, {"x":(2)4}]> :  tensor<16x32xf32>
-  return %0 : tensor<16x32xf32>
-}
-
-// CHECK-LABEL: func @all_reduce_split_axis_y
-func.func @all_reduce_split_axis_y(%arg0 : tensor<16x32xf32> {sdy.sharding=#sdy.sharding<@mesh6, [{"y":(1)2}, {"x"}]>}) -> tensor<16x32xf32> {
-  // CHECK-NEXT: sdy.all_reduce {"y":(2)2} %arg0 out_sharding=<@mesh6, [{"y":(1)2}, {"x"}]> :  tensor<16x32xf32>
-  %0 = sdy.all_reduce {"y":(2)2} %arg0 out_sharding=<@mesh6, [{"y":(1)2}, {"x"}]> :  tensor<16x32xf32>
-  return %0 : tensor<16x32xf32>
-}
-
-// CHECK-LABEL: func @all_reduce_output_is_explicitely_replicated
-func.func @all_reduce_output_is_explicitely_replicated(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh2, [{}, {"x", "y"}]>}) -> tensor<16x2xf32> {
-  // CHECK-NEXT: sdy.all_reduce {} %arg0 out_sharding=<@mesh2, [{}, {"x", "y"}], replicated={"z"}> :  tensor<16x2xf32>
-  %0 = sdy.all_reduce {} %arg0 out_sharding=<@mesh2, [{}, {"x", "y"}], replicated={"z"}> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
diff --git a/shardy/dialect/sdy/ir/test/collective_verification.mlir b/shardy/dialect/sdy/ir/test/collective_verification.mlir
index 55589c4..ad26cbf 100644
--- a/shardy/dialect/sdy/ir/test/collective_verification.mlir
+++ b/shardy/dialect/sdy/ir/test/collective_verification.mlir
@@ -445,101 +445,3 @@ func.func @collective_permute_sharded_size_mismatch_across_dims(%arg0 : tensor<1
   %0 = sdy.collective_permute %arg0 out_sharding=<@mesh, [{"x"}, {"y", "z"}]> :  tensor<16x8xf32>
   return %0 : tensor<16x8xf32>
 }
-
-// -----
-sdy.mesh @mesh= <["x"=2, "y"=2]>
-
-func.func @all_reduce_mismatch_output_sharding(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh, [{}, {"x", "y"}]>}) -> tensor<16x2xf32> {
-  // expected-error@+1 {{'sdy.all_reduce' op operand and result sharding have different axes}}
-  %0 = sdy.all_reduce {} %arg0 out_sharding=<@mesh, [{}, {"y"}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
-
-
-// -----
-
-sdy.mesh @mesh= <["x"=2, "y"=2, "z"=2]>
-sdy.mesh @mesh_other= <["x"=2, "y"=4]>
-
-func.func @all_reduce_mismatch_output_mesh(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh, [{}, {"x", "y"}]>}) -> tensor<16x2xf32> {
-  // expected-note@above {{operand mesh: #sdy.mesh<["x"=2, "y"=2, "z"=2]>}}
-  // expected-error@+1 {{'sdy.all_reduce' op result mesh does not match operand mesh}}
-  %0 = sdy.all_reduce {} %arg0 out_sharding=<@mesh_other, [{}, {"x", "y"}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
-
-// -----
-sdy.mesh @mesh= <["x"=2, "y"=8, "z"=2]>
-
-func.func @all_reduce_overlapping_part_axis(%arg0 : tensor<16x32xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y"}, {"x"}]>}) -> tensor<16x32xf32> {
-  // expected-error@+1 {{'sdy.all_reduce' op reduction axis overlaps with operand sharding: "y":(2)2}}
-  %0 = sdy.all_reduce {"y":(2)2} %arg0 out_sharding=<@mesh, [{"y"}, {"x"}]> :  tensor<16x32xf32>
-  return %0 : tensor<16x32xf32>
-}
-
-// -----
-sdy.mesh @mesh= <["x"=2, "y"=8, "y2"=8, "z"=2]>
-
-func.func @all_reduce_overlapping_axis_minor(%arg0 : tensor<16x32xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y", "y2"}, {"x"}]>}) -> tensor<16x32xf32> {
-  // expected-error@+1 {{'sdy.all_reduce' op reduction axis overlaps with operand sharding: "y2"}}
-  %0 = sdy.all_reduce {"y2"} %arg0 out_sharding=<@mesh, [{"y", "y2"}, {"x"}]> :  tensor<16x32xf32>
-  return %0 : tensor<16x32xf32>
-}
-// -----
-sdy.mesh @mesh= <["x"=2, "y"=8, "y2"=8, "z"=2]>
-
-func.func @all_reduce_overlapping_axis_major(%arg0 : tensor<16x32xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y", "y2"}, {"x"}]>}) -> tensor<16x32xf32> {
-  // expected-error@+1 {{'sdy.all_reduce' op reduction axis overlaps with operand sharding: "y"}}
-  %0 = sdy.all_reduce {"y"} %arg0 out_sharding=<@mesh, [{"y", "y2"}, {"x"}]> :  tensor<16x32xf32>
-  return %0 : tensor<16x32xf32>
-}
-
-// -----
-sdy.mesh @mesh= <["x"=2, "y"=8, "z"=2]>
-
-// func.func @all_reduce_wrong_axis(%arg0 : tensor<16x32xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y":(4)2}, {"x"}]>}) -> tensor<16x32xf32> {
-// TODO(kostiantynl): fix the sub-axis verification in the followup CL b/393057118
-// COM: {{'sdy.all_reduce' op sub-axis next pre-size 16 doesn't divide the size of the full axis 8: "y":(8)2}}
-//   %0 = sdy.all_reduce {"y":(8)2} %arg0 out_sharding=<@mesh, [{"y":(4)2}, {"x"}]> :  tensor<16x32xf32>
-//   return %0 : tensor<16x32xf32>
-// }
-
-
-// -----
-
-sdy.mesh @mesh = <["x"=2, "y"=2]>
-
-func.func @all_reduce_on_operand_without_sharding(%arg0 : tensor<16x2xf32>) -> tensor<16x2xf32> {
-  // expected-error @+1 {{'sdy.all_reduce' op collective on operand without sharding}}
-  %0 = sdy.all_reduce {"x"} %arg0 out_sharding=<@mesh, [{"y"}, {}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
-// -----
-
-sdy.mesh @mesh = <["x"=4, "y"=2]>
-
-func.func @all_reduce_reduction_axes_can_be_merged(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y"}, {"x"}]>}) -> tensor<16x2xf32> {
-  // expected-error @+1 {{'sdy.all_reduce' op operand and result sharding have different axes}}
-  %0 = sdy.all_reduce {"x":(1)2, "x":(2)2} %arg0 out_sharding=<@mesh, [{"y"}, {}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
-
-// -----
-
-sdy.mesh @mesh = <["x"=2, "y"=2]>
-
-func.func @all_reduce_duplicate_reduction_axes_across_dims(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y"}, {"x"}]>}) -> tensor<16x2xf32> {
-  // expected-error @+1 {{'sdy.all_reduce' op operand and result sharding have different axes}}
-  %0 = sdy.all_reduce {"x", "x"} %arg0 out_sharding=<@mesh, [{}, {}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
-
-// -----
-
-sdy.mesh @mesh = <["x"=2, "y"=2]>
-
-func.func @all_reduce_invalid_out_sharding(%arg0 : tensor<16x2xf32> {sdy.sharding=#sdy.sharding<@mesh, [{"y"}, {"x"}]>}) -> tensor<16x2xf32> {
-  // expected-error @+1 {{duplicate axis ref: "x"}}
-  %0 = sdy.all_reduce {"y"} %arg0 out_sharding=<@mesh, [{}, {"x", "x"}]> :  tensor<16x2xf32>
-  return %0 : tensor<16x2xf32>
-}
diff --git a/shardy/dialect/sdy/ir/test/tensor_sharding_verification.mlir b/shardy/dialect/sdy/ir/test/tensor_sharding_verification.mlir
index 6a1f3b5..4e6b752 100644
--- a/shardy/dialect/sdy/ir/test/tensor_sharding_verification.mlir
+++ b/shardy/dialect/sdy/ir/test/tensor_sharding_verification.mlir
@@ -324,6 +324,26 @@ func.func @empty_closed_dim_sharding_with_priority(%arg0: tensor<8x8xf32>, %arg1
 
 sdy.mesh @mesh = <["a"=2]>
 
+func.func @size_zero_dim_sharded(%arg0: tensor<8x0xf32>, %arg1: tensor<8x0xf32>) -> tensor<8x0xf32> {
+  // expected-error @+1 {{dim 1 of size 0 is sharded on an axis of size > 1}}
+  %0 = stablehlo.add %arg0, %arg1 {sdy.sharding=#sdy.sharding_per_value<[<@mesh, [{}, {"a"}]>]>} : tensor<8x0xf32>
+  return %0 : tensor<8x0xf32>
+}
+
+// -----
+
+sdy.mesh @mesh = <["a"=2]>
+
+func.func @size_zero_dim_sharded_dynamic_shape(%arg0: tensor<?x0xf32>, %arg1: tensor<?x0xf32>) -> tensor<?x0xf32> {
+  // expected-error @+1 {{dim 1 of size 0 is sharded on an axis of size > 1}}
+  %0 = stablehlo.add %arg0, %arg1 {sdy.sharding=#sdy.sharding_per_value<[<@mesh, [{}, {"a"}]>]>} : tensor<?x0xf32>
+  return %0 : tensor<?x0xf32>
+}
+
+// -----
+
+sdy.mesh @mesh = <["a"=2]>
+
 func.func @unknown_sub_axis(%arg0: tensor<8x8xf32>, %arg1: tensor<8x8xf32>) -> tensor<8x8xf32> {
   // expected-error @+1 {{unknown axis name: "c"}}
   %0 = stablehlo.add %arg0, %arg1 {sdy.sharding=#sdy.sharding_per_value<[<@mesh, [{}, {"c":(2)2}], replicated={"a"}>]>} : tensor<8x8xf32>
diff --git a/shardy/dialect/sdy/ir/utils.cc b/shardy/dialect/sdy/ir/utils.cc
index 0e7643d..16481b4 100644
--- a/shardy/dialect/sdy/ir/utils.cc
+++ b/shardy/dialect/sdy/ir/utils.cc
@@ -331,7 +331,7 @@ void setSharding(Value value, TensorShardingAttr sharding) {
       .Case<ReshardOp>(
           [&](ReshardOp reshardOp) { reshardOp.setShardingAttr(sharding); })
       .Case<CollectiveOpInterface>([&](CollectiveOpInterface collectiveOp) {
-        collectiveOp.setOutShardingAttr(sharding);
+        return collectiveOp.setOutShardingAttr(sharding);
       })
       .Case<ShardableDataFlowOpInterface>(
           [&](ShardableDataFlowOpInterface shardableRegionOp) {
diff --git a/shardy/dialect/sdy/ir/verifiers.cc b/shardy/dialect/sdy/ir/verifiers.cc
index e7d4076..f127e92 100644
--- a/shardy/dialect/sdy/ir/verifiers.cc
+++ b/shardy/dialect/sdy/ir/verifiers.cc
@@ -13,8 +13,6 @@ See the License for the specific language governing permissions and
 limitations under the License.
 ==============================================================================*/
 
-#include "shardy/dialect/sdy/ir/verifiers.h"
-
 #include <algorithm>
 #include <cstdint>
 #include <functional>
@@ -212,6 +210,7 @@ LogicalResult emitBoundAxisInManualComputationError(EmitErrorFn emitError,
 //
 // - The tensor should have a rank.
 // - The number of dimension shardings is equal to the rank of the tensor.
+// - Dimensions of size 0 aren't sharded.
 // - Replicated axes are ordered w.r.t. `mesh` (see
 //   AxisRefAttr::getMeshComparator).
 // - All dimension shardings and the replicated axes are each a valid axis-ref
@@ -246,7 +245,7 @@ LogicalResult verifyTensorShardingAttr(TensorShardingAttr shardingAttr,
   if (auto tupleType = dyn_cast<TupleType>(type)) {
     if (tupleType.size() != 1) {
       return emitError("ops can only have a sharding for a tuple of size 1: ")
-             << tupleType;
+          << tupleType;
     }
     tensorType = dyn_cast<ShapedType>(tupleType.getType(0));
   }
@@ -300,6 +299,13 @@ LogicalResult verifyTensorShardingAttr(TensorShardingAttr shardingAttr,
       continue;
     }
 
+    if (dimSize == 0 &&
+        llvm::any_of(dimSharding.getAxes(), [&](AxisRefAttr axisRef) {
+          return axisNameToSize[axisRef.getName()] > 1;
+        })) {
+      return emitError("dim ")
+          << dim << " of size 0 is sharded on an axis of size > 1";
+    }
     if (checkDivisibility) {
       int64_t shardedSize = dimSharding.getShardedSize(mesh);
       if (dimSize % shardedSize != 0) {
@@ -846,6 +852,7 @@ LogicalResult verifyManualComputationValue(
       }
     }
 
+
     // 6. Verify the global shape and local shapes of the op regions
     //    arguments/results match.
     SmallVector<int64_t> newDimSizes;
@@ -918,8 +925,8 @@ LogicalResult ManualComputationOp::verify() {
   }
 
   SymbolTable symbolTable(getOperation()->getParentOfType<ModuleOp>());
-  llvm::SmallDenseSet<StringRef> manualAxesSet(getManualAxes().begin(),
-                                               getManualAxes().end());
+  llvm::SmallDenseSet<StringRef> manualAxesSet(
+      getManualAxes().begin(), getManualAxes().end());
   if (failed(verifyManualComputationValue(
           *this, getOperandTypes(), getBody().getArgumentTypes(),
           getInShardings(), symbolTable, manualAxesSet, "operand")) ||
@@ -1023,8 +1030,11 @@ LogicalResult NamedComputationOp::verify() {
 namespace {
 
 // Verifies:
-// 1. All collective axes per dimension are valid (see `verifyAxisRefList`).
-// 2. Applying `collectiveAxesPerDim` to the operand sharding (via
+// 1. Operand has a sharding.
+// 2. Result sharding is valid w.r.t the corresponding type.
+// 3. Both operand and result shardings are bound to the same `MeshAttr`.
+// 4. All collective axes per dimension are valid (see `verifyAxisRefList`).
+// 5. Applying `collectiveAxesPerDim` to the operand sharding (via
 //    `getExpectedResultDimSharding`) gets the output sharding.
 template <typename OpTy>
 LogicalResult verifyCollectiveWithAxesPerDim(
@@ -1033,12 +1043,30 @@ LogicalResult verifyCollectiveWithAxesPerDim(
         DimensionShardingAttr operandDimSharding,
         ArrayRef<AxisRefAttr> dimCollectiveAxes, int64_t dim, MeshAttr mesh)>
         getExpectedResultDimSharding) {
+  // 1. Verify operand has a sharding.
   TensorShardingAttr operandSharding = getSharding(op.getOperand());
+  if (!operandSharding) {
+    return op.emitOpError("collective on operand without sharding");
+  }
+
+  // 2. Verify result sharding is valid w.r.t the corresponding type.
   TensorShardingAttr resultSharding = op.getOutSharding();
+  if (failed(verifyTensorShardingAttr(resultSharding, op.getType(), op,
+                                      getEmitErrorFn(op)))) {
+    return failure();
+  }
+
+  // 3. Verify MeshAttr of result and operand is the same.
   MeshAttr mesh = resultSharding.getMesh(op);
   MeshAttr operandMesh = operandSharding.getMesh(op);
 
-  // 1. Verify all collective axes.
+  if (mesh != operandMesh) {
+    return op.emitOpError("result mesh does not match operand mesh")
+               .attachNote(op.getOperand().getLoc())
+           << "operand mesh: " << operandMesh;
+  }
+
+  // 4. Verify all collective axes.
   SmallDenseSet<AxisRefAttr> seenAxisRefs;
   SmallDenseMap<StringRef, SmallVector<AxisRefAttr>> axisNameToSubAxes;
   SmallDenseMap<StringRef, int64_t> axisNameToSize = mesh.getAxisNameToSize();
@@ -1050,25 +1078,31 @@ LogicalResult verifyCollectiveWithAxesPerDim(
     }
   }
 
-  // 2. Verify that applying `collectiveAxesPerDim` to the operand gets
+  // 5. Verify that applying `collectiveAxesPerDim` to the operand gets
   // outSharding.
   // For example:
   // operand sharding: (a, b, c, d)
   // gathering axes: (c, d)
   // -> (a, b)
 
+  // 5.1. Verify same rank of the result sharding and operand sharding.
   ArrayRef<DimensionShardingAttr> resultDimShardings =
       resultSharding.getDimShardings();
   ArrayRef<DimensionShardingAttr> operandDimShardings =
       operandSharding.getDimShardings();
-  // 2.1. Verify same rank of result sharding and the collective axes.
+  if (resultDimShardings.size() != operandDimShardings.size()) {
+    return op.emitOpError("result sharding has rank ")
+           << resultDimShardings.size() << " but operand sharding has rank "
+           << operandDimShardings.size();
+  }
+  // 5.2. Verify same rank of result sharding and the collective axes.
   if (resultDimShardings.size() != collectiveAxesPerDim.size()) {
     return op.emitOpError("result sharding has rank ")
            << resultDimShardings.size() << " but collective axes has rank "
            << collectiveAxesPerDim.size();
   }
 
-  // 2.2. Verify that applying `collectiveAxesPerDim` to the operand gets
+  // 5.3. Verify that applying `collectiveAxesPerDim` to the operand gets
   // `resultDimShardings`.
   for (auto [dim, dimEntry] : llvm::enumerate(
            llvm::zip_equal(operandDimShardings, collectiveAxesPerDim))) {
@@ -1152,11 +1186,32 @@ LogicalResult AllSliceOp::verify() {
 }
 
 LogicalResult AllToAllOp::verify() {
+  // TODO(b/391574176): CollectiveOpInterface should verify 1-3.
+
+  // 1. Verify operand has a sharding.
   TensorShardingAttr operandSharding = getSharding(getOperand());
+  if (!operandSharding) {
+    return emitOpError("collective on operand without sharding");
+  }
+
+  // 2. Verify result sharding is valid w.r.t the corresponding type.
   TensorShardingAttr resultSharding = getOutSharding();
+  if (failed(verifyTensorShardingAttr(resultSharding, getType(), *this,
+                                      getEmitErrorFn(*this)))) {
+    return failure();
+  }
+
+  // 3. Verify MeshAttr of result and operand is the same.
   MeshAttr mesh = resultSharding.getMesh(*this);
+  MeshAttr operandMesh = operandSharding.getMesh(*this);
+
+  if (mesh != operandMesh) {
+    return emitOpError("result mesh does not match operand mesh")
+               .attachNote(getOperand().getLoc())
+           << "operand mesh: " << operandMesh;
+  }
 
-  // 1. Verify `axes` is a valid list of axes.
+  // 4. Verify `axes` is a valid list of axes.
   SmallDenseSet<AxisRefAttr> seenAxisRefs;
   SmallDenseMap<StringRef, SmallVector<AxisRefAttr>> axisNameToSubAxes;
   SmallDenseMap<StringRef, int64_t> axisNameToSize = mesh.getAxisNameToSize();
@@ -1165,7 +1220,7 @@ LogicalResult AllToAllOp::verify() {
     return failure();
   }
 
-  // 2. Verify `src_dim` and `tgt_dim`.
+  // 5. Verify `src_dim` and `tgt_dim`.
   int64_t rank = getTensorRank(getResult());
   auto verifyDim = [this, rank](int64_t dim,
                                 StringRef dimName) -> LogicalResult {
@@ -1185,12 +1240,19 @@ LogicalResult AllToAllOp::verify() {
     return emitOpError("source and target dimensions must be different");
   }
 
+  // TODO(b/391574176): should also be verified by CollectiveOpInterface.
+  // Verify same rank of the result sharding and operand sharding.
   ArrayRef<DimensionShardingAttr> resultDimShardings =
       resultSharding.getDimShardings();
   ArrayRef<DimensionShardingAttr> operandDimShardings =
       operandSharding.getDimShardings();
+  if (resultDimShardings.size() != operandDimShardings.size()) {
+    return emitOpError("result sharding has rank ")
+           << resultDimShardings.size() << " but operand sharding has rank "
+           << operandDimShardings.size();
+  }
 
-  // 3. Verify that moving `axes` from `src_dim` to `tgt_dim` in the operand
+  // 6. Verify that moving `axes` from `src_dim` to `tgt_dim` in the operand
   // sharding gets `out_sharding`.
   for (auto [dim, dimShardings] : llvm::enumerate(
            llvm::zip_equal(operandDimShardings, resultDimShardings))) {
@@ -1230,15 +1292,44 @@ LogicalResult AllToAllOp::verify() {
 }
 
 LogicalResult CollectivePermuteOp::verify() {
+  // TODO(b/391574176): CollectiveOpInterface should verify 1-3.
+
+  // 1. Verify operand has a sharding.
   TensorShardingAttr operandSharding = getSharding(getOperand());
+  if (!operandSharding) {
+    return emitOpError("collective on operand without sharding");
+  }
+
+  // 2. Verify result sharding is valid w.r.t the corresponding type.
   TensorShardingAttr resultSharding = getOutSharding();
+  if (failed(verifyTensorShardingAttr(resultSharding, getType(), *this,
+                                      getEmitErrorFn(*this)))) {
+    return failure();
+  }
+
+  // 3. Verify MeshAttr of result and operand is the same.
   MeshAttr mesh = resultSharding.getMesh(*this);
+  MeshAttr operandMesh = operandSharding.getMesh(*this);
+
+  if (mesh != operandMesh) {
+    return emitOpError("result mesh does not match operand mesh")
+               .attachNote(getOperand().getLoc())
+           << "operand mesh: " << operandMesh;
+  }
+
+  // TODO(b/391574176): should also be verified by CollectiveOpInterface.
+  // Verify same rank of the result sharding and operand sharding.
   ArrayRef<DimensionShardingAttr> resultDimShardings =
       resultSharding.getDimShardings();
   ArrayRef<DimensionShardingAttr> operandDimShardings =
       operandSharding.getDimShardings();
+  if (resultDimShardings.size() != operandDimShardings.size()) {
+    return emitOpError("result sharding has rank ")
+           << resultDimShardings.size() << " but operand sharding has rank "
+           << operandDimShardings.size();
+  }
 
-  // For each dimension, verify that the sharded size of input and output
+  // 4. For each dimension, verify that the sharded size of input and output
   // dimension shardings match.
   for (auto [dim, dimShardings] : llvm::enumerate(
            llvm::zip_equal(operandDimShardings, resultDimShardings))) {
@@ -1258,47 +1349,6 @@ LogicalResult CollectivePermuteOp::verify() {
   return success();
 }
 
-LogicalResult verifyCollectiveOp(Operation* rawOp) {
-  auto collectiveOp = dyn_cast<CollectiveOpInterface>(rawOp);
-  if (!collectiveOp) {
-    return failure();
-  }
-  // 1. Verify operand has a sharding.
-  TensorShardingAttr operandSharding = getSharding(collectiveOp.getTensor());
-  if (!operandSharding) {
-    return collectiveOp.emitOpError("collective on operand without sharding");
-  }
-
-  // 2. Verify result sharding is valid w.r.t the corresponding type.
-  TensorShardingAttr resultSharding = collectiveOp.getOutSharding();
-  if (auto res =
-          verifyTensorShardingAttr(resultSharding, collectiveOp.getType(),
-                                   collectiveOp, getEmitErrorFn(collectiveOp));
-      failed(res)) {
-    return res;
-  }
-
-  // 3. Verify MeshAttr of result and operand is the same.
-  MeshAttr mesh = resultSharding.getMesh(collectiveOp);
-  MeshAttr operandMesh = operandSharding.getMesh(collectiveOp);
-
-  if (mesh != operandMesh) {
-    return collectiveOp.emitOpError("result mesh does not match operand mesh")
-               .attachNote(collectiveOp.getTensor().getLoc())
-           << "operand mesh: " << operandMesh;
-  }
-
-  // 4. Verify same rank of the result sharding and operand sharding.
-  auto resultDimShardings = resultSharding.getRank();
-  auto operandDimShardings = operandSharding.getRank();
-  if (resultDimShardings != operandDimShardings) {
-    return collectiveOp.emitOpError("result sharding has rank ")
-           << resultDimShardings << " but operand sharding has rank "
-           << operandDimShardings;
-  }
-  return success();
-}
-
 LogicalResult SdyDialect::verifyRegionArgAttribute(Operation* op,
                                                    unsigned regionIndex,
                                                    unsigned argIndex,
@@ -1350,38 +1400,5 @@ LogicalResult SdyDialect::verifyOperationAttribute(Operation* op,
   return success();
 }
 
-LogicalResult AllReduceOp::verify() {
-  TensorShardingAttr operandSharding = getSharding(getOperand());
-  TensorShardingAttr resultSharding = getOutSharding();
-  MeshAttr mesh = resultSharding.getMesh(*this);
-  if (!operandSharding.areDimAxesEqual(resultSharding)) {
-    return emitOpError("operand and result sharding have different axes");
-  }
-
-  // 1. Verify all reduction axes are valid.
-  SmallDenseSet<AxisRefAttr> seenAxisRefs;
-  SmallDenseMap<StringRef, SmallVector<AxisRefAttr>> axisNameToSubAxes;
-  ArrayRef<AxisRefAttr> reductionAxes = getReductionAxes();
-  SmallDenseMap<StringRef, int64_t> axisNameToSize = mesh.getAxisNameToSize();
-  if (auto res = verifyAxisRefList(reductionAxes, axisNameToSize, seenAxisRefs,
-                                   axisNameToSubAxes, getEmitErrorFn(*this));
-      failed(res)) {
-    return res;
-  }
-
-  // 2. Verify no axis from reduction_axes overlap with the operand sharding
-  // axes.
-  for (AxisRefAttr reductionAxisRef : reductionAxes) {
-    if (operandSharding.anyOfAxisRef([reductionAxisRef](AxisRefAttr axisRef) {
-          return axisRef.overlaps(reductionAxisRef);
-        })) {
-      return emitOpError("reduction axis overlaps with operand sharding: ")
-             << reductionAxisRef.toString();
-    }
-  }
-
-  return success();
-}
-
 }  // namespace sdy
 }  // namespace mlir
diff --git a/shardy/dialect/sdy/ir/verifiers.h b/shardy/dialect/sdy/ir/verifiers.h
deleted file mode 100644
index 4d2551b..0000000
--- a/shardy/dialect/sdy/ir/verifiers.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* Copyright 2025 The Shardy Authors.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-==============================================================================*/
-
-#ifndef SHARDY_DIALECT_SDY_IR_VERIFIERS_H_
-#define SHARDY_DIALECT_SDY_IR_VERIFIERS_H_
-
-#include "mlir/IR/Operation.h"
-#include "mlir/Support/LogicalResult.h"
-
-namespace mlir {
-namespace sdy {
-
-LogicalResult verifyCollectiveOp(Operation* op);
-
-}  // namespace sdy
-}  // namespace mlir
-
-#endif  // SHARDY_DIALECT_SDY_IR_VERIFIERS_H_
diff --git a/shardy/dialect/sdy/transforms/propagation/BUILD b/shardy/dialect/sdy/transforms/propagation/BUILD
index c038e73..0730172 100644
--- a/shardy/dialect/sdy/transforms/propagation/BUILD
+++ b/shardy/dialect/sdy/transforms/propagation/BUILD
@@ -234,7 +234,6 @@ cc_test(
     srcs = ["basic_factor_propagation_test.cc"],
     deps = [
         ":basic_factor_propagation",
-        ":factor_propagation",
         ":sharding_projection",
         ":testing_utils",
         ":utils",
@@ -270,7 +269,6 @@ cc_test(
     srcs = ["aggressive_factor_propagation_test.cc"],
     deps = [
         ":aggressive_factor_propagation",
-        ":factor_propagation",
         ":sharding_projection",
         ":testing_utils",
         ":utils",
diff --git a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
index aaded5f..fc4f2f1 100644
--- a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
@@ -25,8 +25,8 @@ limitations under the License.
 #include "mlir/IR/Value.h"
 #include "mlir/Support/LLVM.h"
 #include "shardy/dialect/sdy/ir/dialect.h"
-#include "shardy/dialect/sdy/transforms/propagation/factor_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_projection.h"
+#include "shardy/dialect/sdy/transforms/propagation/utils.h"
 
 namespace mlir {
 namespace sdy {
@@ -85,12 +85,14 @@ SmallVector<TensorIndexSize> getFactorToSourceTensor(
 }  // namespace
 
 UpdateTensorShardings AggressiveFactorPropagation::propagateFactorShardings(
-    ShardingProjection& projection,
-    PropagationDirectionAlongFactor directionAlongFactor,
+    ShardingProjection& projection, PropagationDirection direction,
     ArrayRef<int64_t> factorSizes, MeshAttr mesh, Operation* op,
     bool conservativePropagation) const {
   UpdateTensorShardings result(projection.getNumOperands(),
                                projection.getNumResults());
+  if (direction == PropagationDirection::NONE) {
+    return result;
+  }
 
   // Find the compatible major axes ignoring conflicts.
   AxesPerFactor axesPerFactor;
@@ -98,7 +100,7 @@ UpdateTensorShardings AggressiveFactorPropagation::propagateFactorShardings(
   bool allElementsAreEmpty = true;
   for (int64_t i = 0; i < factorSizes.size(); ++i) {
     SmallVector<AxisRefAttr>& axes = axesPerFactor.emplace_back(
-        getCompatibleMajorAxes(projection, i, directionAlongFactor(i), op));
+        getCompatibleMajorAxes(projection, i, direction, op));
     if (!axes.empty()) {
       allElementsAreEmpty = false;
     }
diff --git a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.h b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.h
index cf44b14..3f7e699 100644
--- a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.h
+++ b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.h
@@ -22,7 +22,6 @@ limitations under the License.
 #include "mlir/Support/LLVM.h"
 #include "shardy/dialect/sdy/ir/dialect.h"
 #include "shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.h"
-#include "shardy/dialect/sdy/transforms/propagation/factor_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_projection.h"
 
 namespace mlir {
@@ -77,8 +76,7 @@ namespace sdy {
 class AggressiveFactorPropagation : public BasicFactorPropagation {
  public:
   UpdateTensorShardings propagateFactorShardings(
-      ShardingProjection& projection,
-      PropagationDirectionAlongFactor directionAlongFactor,
+      ShardingProjection& projection, PropagationDirection direction,
       ArrayRef<int64_t> factorSizes, MeshAttr mesh, Operation* op,
       bool conservativePropagation) const override;
 };
diff --git a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation_test.cc b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation_test.cc
index 45e12e1..cec5ff8 100644
--- a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation_test.cc
+++ b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation_test.cc
@@ -18,9 +18,9 @@ limitations under the License.
 #include <cassert>
 #include <cstdint>
 
+#include "mlir/IR/Operation.h"
 #include "mlir/Support/LLVM.h"
 #include "shardy/dialect/sdy/ir/dialect.h"
-#include "shardy/dialect/sdy/transforms/propagation/factor_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_projection.h"
 #include "shardy/dialect/sdy/transforms/propagation/testing_utils.h"
 #include "shardy/dialect/sdy/transforms/propagation/utils.h"
@@ -34,19 +34,16 @@ namespace {
 using ::testing::ElementsAre;
 using ::testing::IsEmpty;
 
-PropagationDirectionAlongFactor propagateAnything() {
-  return [](int64_t) { return PropagationDirection::BOTH; };
-}
-
 class AggressiveFactorPropagationTest : public PropagationTestBase {
  protected:
   UpdateTensorShardings propagateFactorShardings(
       ShardingProjection& projection, int64_t numFactors,
-      PropagationDirectionAlongFactor directionAlongFactor =
-          propagateAnything()) {
+      PropagationDirection direction = PropagationDirection::BOTH,
+      MeshAttr mesh = nullptr, bool conservativePropagation = false,
+      Operation* op = nullptr) {
     return AggressiveFactorPropagation().propagateFactorShardings(
-        projection, directionAlongFactor, SmallVector<int64_t>(numFactors, 1),
-        /*mesh=*/nullptr, /*op=*/nullptr, /*conservativePropagation=*/false);
+        projection, direction, SmallVector<int64_t>(numFactors, 1), mesh, op,
+        conservativePropagation);
   }
 };
 
@@ -350,51 +347,6 @@ TEST_F(AggressiveFactorPropagationTest, NewAxesConflict) {
   EXPECT_EQ(projection, projectionExpected);
 }
 
-TEST_F(AggressiveFactorPropagationTest, PropagateAlongSpecificFactor) {
-  TensorFactorShardings factor0IsSharded = {
-      .factorIndexToSharding = {{0, {.axisRefs = {createAxis("a")}}}, {1, {}}}};
-  TensorFactorShardings factor1IsSharded = {
-      .factorIndexToSharding = {{0, {}}, {1, {.axisRefs = {createAxis("a")}}}}};
-  TensorFactorShardings replicated = {
-      .factorIndexToSharding = {{0, {}}, {1, {}}}};
-
-  auto propagateAlongFactor =
-      [&](PropagationDirectionAlongFactor propagateAlongFactor,
-          const ShardingProjection& projectionExpected) {
-        ShardingProjection projection(
-            /*operands=*/{factor0IsSharded, factor1IsSharded},
-            /*results=*/{replicated});
-
-        auto [updateOperands, updateResults] =
-            propagateFactorShardings(projection, 2, propagateAlongFactor);
-        EXPECT_THAT(toSetBitsVector(updateOperands), IsEmpty());
-        EXPECT_THAT(toSetBitsVector(updateResults), ElementsAre(0));
-        EXPECT_EQ(projection, projectionExpected);
-      };
-
-  auto propagateAlongFactorOnly = [](int64_t factorIndex) {
-    return [factorIndex](int64_t i) {
-      return i == factorIndex ? PropagationDirection::BOTH
-                              : PropagationDirection::NONE;
-    };
-  };
-
-  ShardingProjection propagateAlongFactor0Expected(
-      /*operands=*/{factor0IsSharded, factor1IsSharded},
-      /*results=*/{factor0IsSharded});
-  ShardingProjection propagateAlongFactor1Expected(
-      /*operands=*/{factor0IsSharded, factor1IsSharded},
-      /*results=*/{factor1IsSharded});
-  propagateAlongFactor(propagateAlongFactorOnly(0),
-                       propagateAlongFactor0Expected);
-  propagateAlongFactor(propagateAlongFactorOnly(1),
-                       propagateAlongFactor1Expected);
-
-  // When we propagate along all factors, we propagate "a" to the result along
-  // factor 0.
-  propagateAlongFactor(propagateAnything(), propagateAlongFactor0Expected);
-}
-
 }  // namespace
 }  // namespace sdy
 }  // namespace mlir
diff --git a/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.cc b/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.cc
index 1743279..0bb88e9 100644
--- a/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.cc
@@ -35,7 +35,6 @@ limitations under the License.
 #include "shardy/dialect/sdy/ir/dialect.h"
 #include "shardy/dialect/sdy/ir/utils.h"
 #include "shardy/dialect/sdy/transforms/common/macros.h"
-#include "shardy/dialect/sdy/transforms/propagation/factor_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_projection.h"
 
 namespace mlir {
@@ -306,10 +305,6 @@ std::pair<SmallVector<AxisRefAttr>, bool> getCompatibleMajorAxesInternal(
 SmallVector<AxisRefAttr> BasicFactorPropagation::getCompatibleMajorAxes(
     const ShardingProjection& projection, int64_t factorIndex,
     PropagationDirection direction, Operation* op) const {
-  if (direction == PropagationDirection::NONE) {
-    return {};
-  }
-
   std::optional<DirectionBasedTensorShardings> tensorShardings =
       getDirectionBasedTensorShardings(direction, op, projection.getOperands(),
                                        projection.getResults());
@@ -388,6 +383,10 @@ SmallVector<AxisRefAttr> BasicFactorPropagation::getCompatibleMajorShardingAxes(
     const ShardingProjection& projection, int64_t factorIndex,
     PropagationDirection direction, int64_t factorSize, MeshAttr mesh,
     Operation* op, bool conservativePropagation) const {
+  if (direction == PropagationDirection::NONE) {
+    return SmallVector<AxisRefAttr>();
+  }
+
   // Finds the compatible major axes ignoring conflicts.
   SmallVector<AxisRefAttr> resultAxes =
       getCompatibleMajorAxes(projection, factorIndex, direction, op);
@@ -406,8 +405,7 @@ SmallVector<AxisRefAttr> BasicFactorPropagation::getCompatibleMajorShardingAxes(
 }
 
 UpdateTensorShardings BasicFactorPropagation::propagateFactorShardings(
-    ShardingProjection& projection,
-    PropagationDirectionAlongFactor directionAlongFactor,
+    ShardingProjection& projection, PropagationDirection direction,
     ArrayRef<int64_t> factorSizes, MeshAttr mesh, Operation* op,
     bool conservativePropagation) const {
   UpdateTensorShardings result(projection.getNumOperands(),
@@ -419,8 +417,8 @@ UpdateTensorShardings BasicFactorPropagation::propagateFactorShardings(
     // that factor for all tensors, those are the axes we will propagate to
     // tensors that aren't already sharded.
     SmallVector<AxisRefAttr> axesToPropagate = getCompatibleMajorShardingAxes(
-        projection, factorIndex, directionAlongFactor(factorIndex), factorSize,
-        mesh, op, conservativePropagation);
+        projection, factorIndex, direction, factorSize, mesh, op,
+        conservativePropagation);
 
     // Update all shardings along this factor if possible.
     auto [updateOperandForFactor, updateResultForFactor] =
diff --git a/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.h b/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.h
index f74e6d9..6ef1d47 100644
--- a/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.h
+++ b/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation.h
@@ -42,8 +42,7 @@ class BasicFactorPropagation : public FactorPropagation {
 
   // Propagates the factor shardings in `projection`.
   UpdateTensorShardings propagateFactorShardings(
-      ShardingProjection& projection,
-      PropagationDirectionAlongFactor directionAlongFactor,
+      ShardingProjection& projection, PropagationDirection direction,
       ArrayRef<int64_t> factorSizes, MeshAttr mesh, Operation* op,
       bool conservativePropagation) const override;
 
diff --git a/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation_test.cc b/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation_test.cc
index cb6f1ca..90449ce 100644
--- a/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation_test.cc
+++ b/shardy/dialect/sdy/transforms/propagation/basic_factor_propagation_test.cc
@@ -19,10 +19,10 @@ limitations under the License.
 #include <cstdint>
 #include <utility>
 
+#include "mlir/IR/Operation.h"
 #include "mlir/Parser/Parser.h"
 #include "mlir/Support/LLVM.h"
 #include "shardy/dialect/sdy/ir/dialect.h"
-#include "shardy/dialect/sdy/transforms/propagation/factor_propagation.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_projection.h"
 #include "shardy/dialect/sdy/transforms/propagation/testing_utils.h"
 #include "shardy/dialect/sdy/transforms/propagation/utils.h"
@@ -36,30 +36,25 @@ namespace {
 using ::testing::ElementsAre;
 using ::testing::IsEmpty;
 
-PropagationDirectionAlongFactor propagateAnything() {
-  return [](int64_t) { return PropagationDirection::BOTH; };
-}
-
 class BasicFactorPropagationTest : public PropagationTestBase {
  protected:
   UpdateTensorShardings propagateFactorShardings(
       ShardingProjection& projection, int64_t numFactors,
-      PropagationDirectionAlongFactor directionAlongFactor =
-          propagateAnything(),
-      MeshAttr mesh = nullptr, bool conservativePropagation = false) {
+      PropagationDirection direction = PropagationDirection::BOTH,
+      MeshAttr mesh = nullptr, bool conservativePropagation = false,
+      Operation* op = nullptr) {
     return BasicFactorPropagation().propagateFactorShardings(
-        projection, directionAlongFactor, SmallVector<int64_t>(numFactors, 1),
-        mesh, /*op=*/nullptr, conservativePropagation);
+        projection, direction, SmallVector<int64_t>(numFactors, 1), mesh, op,
+        conservativePropagation);
   }
 
   UpdateTensorShardings propagateFactorShardings(
       ShardingProjection& projection, ArrayRef<int64_t> factorSizes,
-      PropagationDirectionAlongFactor directionAlongFactor =
-          propagateAnything(),
-      MeshAttr mesh = nullptr) {
+      PropagationDirection direction = PropagationDirection::BOTH,
+      MeshAttr mesh = nullptr, bool conservativePropagation = false,
+      Operation* op = nullptr) {
     return BasicFactorPropagation().propagateFactorShardings(
-        projection, directionAlongFactor, factorSizes, mesh, /*op=*/nullptr,
-        /*conservativePropagation=*/false);
+        projection, direction, factorSizes, mesh, op, conservativePropagation);
   }
 };
 
@@ -442,7 +437,7 @@ TEST_F(BasicFactorPropagationTest, MinorMostFactorNotDivisible) {
     ShardingProjection projectionBefore({operand}, {resultBefore});
     ShardingProjection projectionAfter({operand}, {resultAfter});
     auto [updateOperands, updateResults] = propagateFactorShardings(
-        projectionBefore, factorSizes, propagateAnything(), mesh);
+        projectionBefore, factorSizes, PropagationDirection::BOTH, mesh);
     EXPECT_THAT(toSetBitsVector(updateOperands), IsEmpty());
     EXPECT_THAT(toSetBitsVector(updateResults), ElementsAre(0));
     EXPECT_EQ(projectionBefore, projectionAfter);
@@ -485,135 +480,136 @@ TEST_F(BasicFactorPropagationTest, MinorMostFactorNotDivisible) {
   }
 }
 
-TEST_F(BasicFactorPropagationTest, DifferentDirectionsForDifferentFactors) {
-  ShardingProjection projection(
-      /*operands=*/
-      {{.factorIndexToSharding = {{0, {.axisRefs = {createAxis("a")}}},
-                                  {1, {.axisRefs = {createAxis("b")}}},
-                                  {2, {.axisRefs = {createAxis("c")}}},
-                                  {3, {.axisRefs = {createAxis("d")}}},
-                                  {4, {.axisRefs = {}}},
-                                  {5, {.axisRefs = {}}},
-                                  {6, {.axisRefs = {}}},
-                                  {7, {.axisRefs = {}}}}},
-       {.factorIndexToSharding = {{0, {.axisRefs = {}}},
-                                  {1, {.axisRefs = {}}},
-                                  {2, {.axisRefs = {}}},
-                                  {3, {.axisRefs = {}}},
-                                  {4, {.axisRefs = {}}},
-                                  {5, {.axisRefs = {}}},
-                                  {6, {.axisRefs = {}}},
-                                  {7, {.axisRefs = {}}}}}},
-      /*results=*/
-      {{.factorIndexToSharding = {{0, {.axisRefs = {}}},
-                                  {1, {.axisRefs = {}}},
-                                  {2, {.axisRefs = {}}},
-                                  {3, {.axisRefs = {}}},
-                                  {4, {.axisRefs = {createAxis("e")}}},
-                                  {5, {.axisRefs = {createAxis("f")}}},
-                                  {6, {.axisRefs = {createAxis("g")}}},
-                                  {7, {.axisRefs = {createAxis("h")}}}}},
-       {.factorIndexToSharding = {{0, {.axisRefs = {}}},
-                                  {1, {.axisRefs = {}}},
-                                  {2, {.axisRefs = {}}},
-                                  {3, {.axisRefs = {}}},
-                                  {4, {.axisRefs = {}}},
-                                  {5, {.axisRefs = {}}},
-                                  {6, {.axisRefs = {}}},
-                                  {7, {.axisRefs = {}}}}}});
-
-  PropagationDirectionAlongFactor directionAlongFactor =
-      [](int64_t factorIndex) {
-        if (factorIndex == 0 || factorIndex == 4) {
-          return PropagationDirection::BOTH;
-        }
-        if (factorIndex == 1 || factorIndex == 5) {
-          return PropagationDirection::FORWARD;
-        }
-        if (factorIndex == 2 || factorIndex == 6) {
-          return PropagationDirection::BACKWARD;
-        }
-        return PropagationDirection::NONE;
-      };
+TEST_F(BasicFactorPropagationTest, UniDirectionalPropagation) {
+  TensorFactorShardings operandBefore0 = {
+      .factorIndexToSharding = {
+          {0, {.axisRefs = {createAxis("a"), createAxis("b")}}},
+          {1, {.axisRefs = {createAxis("d"), createAxis("e")}}},
+      }};
+  TensorFactorShardings operandBefore1 = {
+      .factorIndexToSharding = {
+          {0, {.axisRefs = {createAxis("a")}}},
+          {1, {.axisRefs = {createAxis("d")}}},
+      }};
+  TensorFactorShardings result0 = {
+      .factorIndexToSharding = {
+          {0,
+           {.axisRefs = {createAxis("a"), createAxis("b"), createAxis("c")}}},
+          {1, {.axisRefs = {createAxis("d")}}},
+      }};
 
-  ShardingProjection projectionExpected(
-      /*operands=*/
-      {{.factorIndexToSharding = {{0, {.axisRefs = {createAxis("a")}}},
-                                  {1, {.axisRefs = {createAxis("b")}}},
-                                  {2, {.axisRefs = {createAxis("c")}}},
-                                  {3, {.axisRefs = {createAxis("d")}}},
-                                  {4, {.axisRefs = {createAxis("e")}}},
-                                  {5, {.axisRefs = {}}},
-                                  {6, {.axisRefs = {createAxis("g")}}},
-                                  {7, {.axisRefs = {}}}}},
-       {.factorIndexToSharding = {{0, {.axisRefs = {createAxis("a")}}},
-                                  {1, {.axisRefs = {createAxis("b")}}},
-                                  {2, {.axisRefs = {}}},
-                                  {3, {.axisRefs = {}}},
-                                  {4, {.axisRefs = {createAxis("e")}}},
-                                  {5, {.axisRefs = {}}},
-                                  {6, {.axisRefs = {createAxis("g")}}},
-                                  {7, {.axisRefs = {}}}}}},
-      /*results=*/
-      {{.factorIndexToSharding = {{0, {.axisRefs = {createAxis("a")}}},
-                                  {1, {.axisRefs = {createAxis("b")}}},
-                                  {2, {.axisRefs = {}}},
-                                  {3, {.axisRefs = {}}},
-                                  {4, {.axisRefs = {createAxis("e")}}},
-                                  {5, {.axisRefs = {createAxis("f")}}},
-                                  {6, {.axisRefs = {createAxis("g")}}},
-                                  {7, {.axisRefs = {createAxis("h")}}}}},
-       {.factorIndexToSharding = {{0, {.axisRefs = {createAxis("a")}}},
-                                  {1, {.axisRefs = {createAxis("b")}}},
-                                  {2, {.axisRefs = {}}},
-                                  {3, {.axisRefs = {}}},
-                                  {4, {.axisRefs = {createAxis("e")}}},
-                                  {5, {.axisRefs = {}}},
-                                  {6, {.axisRefs = {createAxis("g")}}},
-                                  {7, {.axisRefs = {}}}}}});
+  TensorFactorShardings operandAfter0 = {
+      .factorIndexToSharding = {
+          {0,
+           {.axisRefs = {createAxis("a"), createAxis("b"), createAxis("c")}}},
+          {1, {.axisRefs = {createAxis("d"), createAxis("e")}}},
+      }};
+  TensorFactorShardings operandAfter1 = {
+      .factorIndexToSharding = {
+          {0,
+           {.axisRefs = {createAxis("a"), createAxis("b"), createAxis("c")}}},
+          {1, {.axisRefs = {createAxis("d")}}},
+      }};
 
-  auto [updateOperands, updateResults] =
-      propagateFactorShardings(projection, 8, directionAlongFactor);
-  EXPECT_THAT(toSetBitsVector(updateOperands), ElementsAre(0, 1));
-  EXPECT_THAT(toSetBitsVector(updateResults), ElementsAre(0, 1));
-  EXPECT_EQ(projection, projectionExpected);
+  {
+    // Test that we only propagate backwards. Since we are only propagating
+    // backwards, we can expand both operands to have ["a", "b", "c"] along
+    // factor 0.
+    //
+    // Since we are only propagating backwards, we do not push "e" forwards
+    // along factor 1. We do not propagate sideways to each operand as our
+    // current behavior with BACKWARD closes all operands for factor expansion.
+
+    ShardingProjection projection({operandBefore0, operandBefore1}, {result0});
+    ShardingProjection projectionExpected({operandAfter0, operandAfter1},
+                                          {result0});
+
+    auto [updateOperands, updateResults] =
+        propagateFactorShardings(projection, 2, PropagationDirection::BACKWARD);
+    EXPECT_THAT(toSetBitsVector(updateOperands), ElementsAre(0, 1));
+    EXPECT_THAT(toSetBitsVector(updateResults), IsEmpty());
+    EXPECT_EQ(projection, projectionExpected);
+  }
+
+  {
+    // Test that we only propagate forwards.
+    ShardingProjection projection({result0}, {operandBefore0, operandBefore1});
+    ShardingProjection projectionExpected({result0},
+                                          {operandAfter0, operandAfter1});
+
+    auto [updateOperands, updateResults] =
+        propagateFactorShardings(projection, 2, PropagationDirection::FORWARD);
+    EXPECT_THAT(toSetBitsVector(updateOperands), IsEmpty());
+    EXPECT_THAT(toSetBitsVector(updateResults), ElementsAre(0, 1));
+    EXPECT_EQ(projection, projectionExpected);
+  }
 }
 
 TEST_F(BasicFactorPropagationTest, UniDirectionalPropagationWithConflict) {
-  ShardingProjection projection(
-      /*operands=*/
-      {{.factorIndexToSharding =
-            {{0, {.axisRefs = {createAxis("a"), createAxis("b")}}},
-             {1, {.axisRefs = {}}},
-             {2, {.axisRefs = {createAxis("d")}}}}}},
-      /*results=*/
-      {{.factorIndexToSharding = {
-            {0, {.axisRefs = {createAxis("b")}}},
-            {1, {.axisRefs = {createAxis("c"), createAxis("d")}}},
-            {2, {.axisRefs = {}}}}}});
-
-  PropagationDirectionAlongFactor directionAlongFactor =
-      [](int64_t factorIndex) {
-        if (factorIndex == 0) {
-          return PropagationDirection::FORWARD;
-        }
-        if (factorIndex == 1) {
-          return PropagationDirection::BACKWARD;
-        }
-        return PropagationDirection::NONE;
-      };
+  TensorFactorShardings operand0 = {
+      .factorIndexToSharding = {
+          {0, {.axisRefs = {createAxis("a"), createAxis("b")}}},
+      }};
+  TensorFactorShardings operand1 = {.factorIndexToSharding = {
+                                        {0, {.axisRefs = {createAxis("a")}}},
+                                    }};
+  TensorFactorShardings result = {
+      .factorIndexToSharding = {
+          {0,
+           {.axisRefs = {createAxis("z"), createAxis("a"), createAxis("b")}}},
+      }};
 
-  ShardingProjection projectionExpected(
+  {
+    // Even though we are propagating backwards, we still need to account for
+    // conflicts. The "z" blocks any propagation.
+    ShardingProjection projection({operand0, operand1}, {result});
+    auto [updateOperands, updateResults] =
+        propagateFactorShardings(projection, 1, PropagationDirection::BACKWARD);
+    EXPECT_THAT(toSetBitsVector(updateOperands), IsEmpty());
+    EXPECT_THAT(toSetBitsVector(updateResults), IsEmpty());
+  }
+  {
+    ShardingProjection projection({result}, {operand0, operand1});
+    auto [updateOperands, updateResults] =
+        propagateFactorShardings(projection, 1, PropagationDirection::FORWARD);
+    EXPECT_THAT(toSetBitsVector(updateOperands), IsEmpty());
+    EXPECT_THAT(toSetBitsVector(updateResults), IsEmpty());
+  }
+}
+
+TEST_F(BasicFactorPropagationTest, NonePropagationDirection) {
+  ShardingProjection projection(
       /*operands=*/
-      {{.factorIndexToSharding =
-            {{0, {.axisRefs = {createAxis("a"), createAxis("b")}}},
-             {1, {.axisRefs = {createAxis("c")}}},
-             {2, {.axisRefs = {createAxis("d")}}}}}},
-      /*results=*/{projection.getResult(0)});
+      {
+          {.factorIndexToSharding =
+               {
+                   {0,
+                    {.axisRefs = {createAxis("a"), createAxis("b"),
+                                  createAxis("c")}}},
+               }},
+      },
+      /*results=*/{
+          {.factorIndexToSharding =
+               {
+                   {0, {.axisRefs = {createAxis("a"), createAxis("b")}}},
+               }},
+          {.factorIndexToSharding =
+               {
+                   {0, {.axisRefs = {createAxis("a")}}},
+               }},
+          {.factorIndexToSharding =
+               {
+                   {0,
+                    {.axisRefs = {createAxis("a"), createAxis("b"),
+                                  createAxis("c")}}},
+               }},
+      });
 
+  // Even though [a, b, c] is the most compatible, since we aren't propagating,
+  // we don't update any operands or results.
   auto [updateOperands, updateResults] =
-      propagateFactorShardings(projection, 3, directionAlongFactor);
-  EXPECT_THAT(toSetBitsVector(updateOperands), ElementsAre(0));
+      propagateFactorShardings(projection, 1, PropagationDirection::NONE);
+  EXPECT_THAT(toSetBitsVector(updateOperands), IsEmpty());
   EXPECT_THAT(toSetBitsVector(updateResults), IsEmpty());
 }
 
@@ -639,7 +635,7 @@ TEST_F(BasicFactorPropagationTest,
                         {0, {.axisRefs = {createAxis("a")}}}, {1, {}}}}});
 
   auto [updateOperands, updateResults] = propagateFactorShardings(
-      projection, 2, propagateAnything(), /*mesh=*/nullptr,
+      projection, 2, PropagationDirection::BOTH, /*mesh=*/nullptr,
       /*conservativePropagation=*/true);
   EXPECT_THAT(toSetBitsVector(updateOperands), IsEmpty());
   EXPECT_THAT(toSetBitsVector(updateResults), ElementsAre(0));
diff --git a/shardy/dialect/sdy/transforms/propagation/basic_propagation.cc b/shardy/dialect/sdy/transforms/propagation/basic_propagation.cc
index c2de9ec..10fae75 100644
--- a/shardy/dialect/sdy/transforms/propagation/basic_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/basic_propagation.cc
@@ -270,17 +270,11 @@ LogicalResult propagateTensorShardings(
   ShardingProjection shardingProjection = ShardingProjection::build(
       operandShardings, resultShardings, shardingRule, mesh);
   bool anyUpdated = false;
-  // TODO(zixuanjiang). We apply the same propagation direction to all factors.
-  // We may want to consider propagating along different factors with different
-  // directions in the future.
-  PropagationDirectionAlongFactor directionAlongFactor = [direction](int64_t) {
-    return direction;
-  };
   auto updateShardings = [&]() {
     auto [updateOperand, updateResult] =
         factorPropagation.propagateFactorShardings(
-            shardingProjection, directionAlongFactor,
-            shardingRule.getFactorSizes(), mesh, op, conservativePropagation);
+            shardingProjection, direction, shardingRule.getFactorSizes(), mesh,
+            op, conservativePropagation);
 
     // We need to update the tensor sharding attributes explicitly, as we
     // have been modifying our internal `shardingProjection` so far.
diff --git a/shardy/dialect/sdy/transforms/propagation/factor_propagation.h b/shardy/dialect/sdy/transforms/propagation/factor_propagation.h
index c4cd3a5..99a41f9 100644
--- a/shardy/dialect/sdy/transforms/propagation/factor_propagation.h
+++ b/shardy/dialect/sdy/transforms/propagation/factor_propagation.h
@@ -17,7 +17,6 @@ limitations under the License.
 #define SHARDY_DIALECT_SDY_TRANSFORMS_PROPAGATION_FACTOR_PROPAGATION_H_
 
 #include <cstdint>
-#include <functional>
 
 #include "mlir/IR/Operation.h"
 #include "mlir/Support/LLVM.h"
@@ -27,11 +26,6 @@ limitations under the License.
 namespace mlir {
 namespace sdy {
 
-// A predicate taking a factor index and returning the propagation direction
-// along that factor.
-using PropagationDirectionAlongFactor =
-    std::function<PropagationDirection(int64_t)>;
-
 // An interface for propagating factor shardings.
 class FactorPropagation {
  public:
@@ -39,8 +33,7 @@ class FactorPropagation {
 
   // Propagates the factor shardings in `projection`.
   //
-  // * `directionAlongFactor` is a predicate that determines in which direction
-  //   propagation should happen for a given factor.
+  // * `direction` specifies the direction of propagation.
   // * `factorSizes` is the size of each factor.
   // * `mesh` is the mesh that the factors are sharded over.
   // * `op` is the operation that the factor shardings are propagated through.
@@ -50,8 +43,7 @@ class FactorPropagation {
   // sub-axis, then the axes (and any axes further sharding the factor) is
   // excluded from the result.
   virtual UpdateTensorShardings propagateFactorShardings(
-      ShardingProjection& projection,
-      PropagationDirectionAlongFactor directionAlongFactor,
+      ShardingProjection& projection, PropagationDirection direction,
       ArrayRef<int64_t> factorSizes, MeshAttr mesh, Operation* op,
       bool conservativePropagation) const = 0;
 };
diff --git a/shardy/dialect/sdy/transforms/propagation/test/propagation_pipeline.mlir b/shardy/dialect/sdy/transforms/propagation/test/propagation_pipeline.mlir
index a8ae94f..fb26d23 100644
--- a/shardy/dialect/sdy/transforms/propagation/test/propagation_pipeline.mlir
+++ b/shardy/dialect/sdy/transforms/propagation/test/propagation_pipeline.mlir
@@ -57,15 +57,6 @@ func.func @sharding_constraint_replaced_with_reshard(%arg0: tensor<8x8xf32>) ->
   return %arg0, %0 : tensor<8x8xf32>, tensor<8x8xf32>
 }
 
-// CHECK-LABEL: func @size_zero_dim_sharded
-// CHECK-SAME: %arg0: tensor<8x0xf32> {sdy.sharding = #sdy.sharding<@mesh, [{?}, {"a", ?}]>}
-// CHECK-SAME: %arg1: tensor<8x0xf32> {sdy.sharding = #sdy.sharding<@mesh, [{?}, {"a", ?}]>})
-func.func @size_zero_dim_sharded(%arg0: tensor<8x0xf32>, %arg1: tensor<8x0xf32>) -> tensor<8x0xf32> {
-  // CHECK-NEXT: %0 = stablehlo.add %arg0, %arg1 {sdy.sharding = #sdy.sharding_per_value<[<@mesh, [{}, {"a"}]>]>}
-  %0 = stablehlo.add %arg0, %arg1 {sdy.sharding=#sdy.sharding_per_value<[<@mesh, [{}, {"a"}]>]>} : tensor<8x0xf32>
-  return %0 : tensor<8x0xf32>
-}
-
 // -----
 
 // CHECK: sdy.mesh @mesh = <["a"=2, "b"=2]>
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 509398d..0bb8e4b 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1 +1,5382 @@
 Auto generated patch. Do not edit or delete it, even if empty.
+diff -ruN --strip-trailing-cr a/clang/lib/AST/StmtPrinter.cpp b/clang/lib/AST/StmtPrinter.cpp
+--- a/clang/lib/AST/StmtPrinter.cpp
++++ b/clang/lib/AST/StmtPrinter.cpp
+@@ -1291,8 +1291,14 @@
+          << PD->getFunctionScopeIndex();
+       break;
+     }
++    case Decl::Decomposition:
++      OS << "decomposition";
++      for (const auto &I : cast<DecompositionDecl>(VD)->bindings())
++        OS << '-' << I->getName();
++      break;
+     default:
+-      llvm_unreachable("Unhandled anonymous declaration kind");
++      OS << "unhandled-anonymous-" << VD->getDeclKindName();
++      break;
+     }
+   }
+   if (Node->hasExplicitTemplateArgs()) {
+diff -ruN --strip-trailing-cr a/clang/test/Analysis/anonymous-decls.cpp b/clang/test/Analysis/anonymous-decls.cpp
+--- a/clang/test/Analysis/anonymous-decls.cpp
++++ b/clang/test/Analysis/anonymous-decls.cpp
+@@ -0,0 +1,89 @@
++// RUN: %clang_analyze_cc1 -analyzer-checker=debug.DumpCFG -triple x86_64-apple-darwin12 -std=c++20 %s 2>&1 | FileCheck %s
++
++struct A {
++  static A a;
++  char b;
++  friend bool operator==(A, A) = default;
++};
++bool _ = A() == A::a;
++
++// FIXME: steps 1 and 5 show anonymous function parameters are
++// not handled correctly.
++
++// CHECK-LABEL: bool operator==(A, A) noexcept = default
++// CHECK-NEXT: [B2 (ENTRY)]
++// CHECK-NEXT:    Succs (1): B1
++// CHECK:      [B1]
++// CHECK-NEXT:    1: function-parameter-0-0
++// CHECK-NEXT:    2: [B1.1].b
++// CHECK-NEXT:    3: [B1.2] (ImplicitCastExpr, LValueToRValue, char)
++// CHECK-NEXT:    4: [B1.3] (ImplicitCastExpr, IntegralCast, int)
++// CHECK-NEXT:    5: function-parameter-0-1
++// CHECK-NEXT:    6: [B1.5].b
++// CHECK-NEXT:    7: [B1.6] (ImplicitCastExpr, LValueToRValue, char)
++// CHECK-NEXT:    8: [B1.7] (ImplicitCastExpr, IntegralCast, int)
++// CHECK-NEXT:    9: [B1.4] == [B1.8]
++// CHECK-NEXT:   10: return [B1.9];
++// CHECK-NEXT:    Preds (1): B2
++// CHECK-NEXT:    Succs (1): B0
++// CHECK:      [B0 (EXIT)]
++// CHECK-NEXT:    Preds (1): B1
++
++namespace std {
++template <class> struct iterator_traits;
++template <class, class> struct pair;
++template <class _Tp> struct iterator_traits<_Tp *> {
++  typedef _Tp &reference;
++};
++template <long, class> struct tuple_element;
++template <class> struct tuple_size;
++template <class _T1, class _T2> struct tuple_size<pair<_T1, _T2>> {
++  static const int value = 2;
++};
++template <class _T1, class _T2> struct tuple_element<0, pair<_T1, _T2>> {
++  using type = _T1;
++};
++template <class _T1, class _T2> struct tuple_element<1, pair<_T1, _T2>> {
++  using type = _T2;
++};
++template <long _Ip, class _T1, class _T2>
++tuple_element<_Ip, pair<_T1, _T2>>::type get(pair<_T1, _T2> &);
++struct __wrap_iter {
++  iterator_traits<pair<int, int> *>::reference operator*();
++  void operator++();
++};
++bool operator!=(__wrap_iter, __wrap_iter);
++struct vector {
++  __wrap_iter begin();
++  __wrap_iter end();
++};
++} // namespace std
++int main() {
++  std::vector v;
++  for (auto &[a, b] : v)
++    ;
++}
++
++// FIXME: On steps 8 and 14, a decomposition is referred by name, which they never have.
++
++// CHECK-LABEL: int main()
++// CHECK:      [B3]
++// CHECK-NEXT:   1: operator*
++// CHECK-NEXT:   2: [B3.1] (ImplicitCastExpr, FunctionToPointerDecay, iterator_traits<pair<int, int> *>::reference (*)(void))
++// CHECK-NEXT:   3: __begin1
++// CHECK-NEXT:   4: * [B3.3] (OperatorCall)
++// CHECK-NEXT:   5: auto &;
++// CHECK-NEXT:   6: get<0UL>
++// CHECK-NEXT:   7: [B3.6] (ImplicitCastExpr, FunctionToPointerDecay, typename tuple_element<0L, pair<int, int> >::type (*)(pair<int, int> &))
++// CHECK-NEXT:   8: decomposition-a-b
++// CHECK-NEXT:   9: [B3.7]([B3.8])
++// CHECK-NEXT:  10: [B3.9]
++// CHECK-NEXT:  11: std::tuple_element<0, std::pair<int, int>>::type a = get<0UL>(decomposition-a-b);
++// CHECK-NEXT:  12: get<1UL>
++// CHECK-NEXT:  13: [B3.12] (ImplicitCastExpr, FunctionToPointerDecay, typename tuple_element<1L, pair<int, int> >::type (*)(pair<int, int> &))
++// CHECK-NEXT:  14: decomposition-a-b
++// CHECK-NEXT:  15: [B3.13]([B3.14])
++// CHECK-NEXT:  16: [B3.15]
++// CHECK-NEXT:  17: std::tuple_element<1, std::pair<int, int>>::type b = get<1UL>(decomposition-a-b);
++// CHECK-NEXT:   Preds (1): B1
++// CHECK-NEXT:   Succs (1): B2
+diff -ruN --strip-trailing-cr a/clang/test/Analysis/anonymous-parameter.cpp b/clang/test/Analysis/anonymous-parameter.cpp
+--- a/clang/test/Analysis/anonymous-parameter.cpp
++++ b/clang/test/Analysis/anonymous-parameter.cpp
+@@ -1,30 +0,0 @@
+-// RUN: %clang_analyze_cc1 -analyzer-checker=debug.DumpCFG -triple x86_64-apple-darwin12 -std=c++20 %s 2>&1 | FileCheck %s
+-
+-struct A {
+-  static A a;
+-  char b;
+-  friend bool operator==(A, A) = default;
+-};
+-bool _ = A() == A::a;
+-
+-// FIXME: steps 1 and 5 show anonymous function parameters are
+-// not handled correctly.
+-
+-// CHECK-LABEL: bool operator==(A, A) noexcept = default
+-// CHECK-NEXT: [B2 (ENTRY)]
+-// CHECK-NEXT:    Succs (1): B1
+-// CHECK:      [B1]
+-// CHECK-NEXT:    1: function-parameter-0-0
+-// CHECK-NEXT:    2: [B1.1].b
+-// CHECK-NEXT:    3: [B1.2] (ImplicitCastExpr, LValueToRValue, char)
+-// CHECK-NEXT:    4: [B1.3] (ImplicitCastExpr, IntegralCast, int)
+-// CHECK-NEXT:    5: function-parameter-0-1
+-// CHECK-NEXT:    6: [B1.5].b
+-// CHECK-NEXT:    7: [B1.6] (ImplicitCastExpr, LValueToRValue, char)
+-// CHECK-NEXT:    8: [B1.7] (ImplicitCastExpr, IntegralCast, int)
+-// CHECK-NEXT:    9: [B1.4] == [B1.8]
+-// CHECK-NEXT:   10: return [B1.9];
+-// CHECK-NEXT:    Preds (1): B2
+-// CHECK-NEXT:    Succs (1): B0
+-// CHECK:      [B0 (EXIT)]
+-// CHECK-NEXT:    Preds (1): B1
+diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp b/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
+--- a/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
++++ b/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp
+@@ -849,9 +849,7 @@
+   }
+ }
+ 
+-DIE *DwarfUnit::constructSubprogramArguments(DIE &Buffer, DITypeRefArray Args) {
+-  // Args[0] is the return type.
+-  DIE *ObjectPointer = nullptr;
++void DwarfUnit::constructSubprogramArguments(DIE &Buffer, DITypeRefArray Args) {
+   for (unsigned i = 1, N = Args.size(); i < N; ++i) {
+     const DIType *Ty = Args[i];
+     if (!Ty) {
+@@ -862,14 +860,8 @@
+       addType(Arg, Ty);
+       if (Ty->isArtificial())
+         addFlag(Arg, dwarf::DW_AT_artificial);
+-      if (Ty->isObjectPointer()) {
+-        assert(!ObjectPointer && "Can't have more than one object pointer");
+-        ObjectPointer = &Arg;
+-      }
+     }
+   }
+-
+-  return ObjectPointer;
+ }
+ 
+ void DwarfUnit::constructTypeDIE(DIE &Buffer, const DISubroutineType *CTy) {
+@@ -1366,8 +1358,7 @@
+ 
+     // Add arguments. Do not add arguments for subprogram definition. They will
+     // be handled while processing variables.
+-    if (auto *ObjectPointer = constructSubprogramArguments(SPDie, Args))
+-      addDIEEntry(SPDie, dwarf::DW_AT_object_pointer, *ObjectPointer);
++    constructSubprogramArguments(SPDie, Args);
+   }
+ 
+   addThrownTypes(SPDie, SP->getThrownTypes());
+diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h b/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
+--- a/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
++++ b/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h
+@@ -268,9 +268,7 @@
+   void constructContainingTypeDIEs();
+ 
+   /// Construct function argument DIEs.
+-  ///
+-  /// \returns DIE of the object pointer if one exists. Nullptr otherwise.
+-  DIE *constructSubprogramArguments(DIE &Buffer, DITypeRefArray Args);
++  void constructSubprogramArguments(DIE &Buffer, DITypeRefArray Args);
+ 
+   /// Create a DIE with the given Tag, add the DIE to its parent, and
+   /// call insertDIE if MD is not null.
+diff -ruN --strip-trailing-cr a/llvm/test/DebugInfo/NVPTX/debug-info.ll b/llvm/test/DebugInfo/NVPTX/debug-info.ll
+--- a/llvm/test/DebugInfo/NVPTX/debug-info.ll
++++ b/llvm/test/DebugInfo/NVPTX/debug-info.ll
+@@ -98,2584 +98,2554 @@
+ ; CHECK-DAG: .file {{[0-9]+}} "{{.*}}/usr/local/cuda/include{{/|\\\\}}vector_types.h"
+ 
+ ; CHECK:	.section	.debug_loc
+-; CHECK-NEXT:	{
+-; CHECK-NEXT:$L__debug_loc0:
+-; CHECK-NEXT:.b64 $L__tmp8
+-; CHECK-NEXT:.b64 $L__tmp10
+-; CHECK-NEXT:.b8 5                                   // Loc expr size
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 144                                 // DW_OP_regx
+-; CHECK-NEXT:.b8 177                                 // 2450993
+-; CHECK-NEXT:.b8 204                                 //
+-; CHECK-NEXT:.b8 149                                 //
+-; CHECK-NEXT:.b8 1                                   //
+-; CHECK-NEXT:.b64 0
+-; CHECK-NEXT:.b64 0
+-; CHECK-NEXT:$L__debug_loc1:
+-; CHECK-NEXT:.b64 $L__tmp5
+-; CHECK-NEXT:.b64 $L__func_end0
+-; CHECK-NEXT:.b8 5                                   // Loc expr size
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 144                                 // DW_OP_regx
+-; CHECK-NEXT:.b8 177                                 // 2454065
+-; CHECK-NEXT:.b8 228                                 //
+-; CHECK-NEXT:.b8 149                                 //
+-; CHECK-NEXT:.b8 1                                   //
+-; CHECK-NEXT:.b64 0
+-; CHECK-NEXT:.b64 0
+-; CHECK-NEXT:	}
+-; CHECK-NEXT:	.section	.debug_abbrev
+-; CHECK-NEXT:	{
+-; CHECK-NEXT:.b8 1                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 17                                  // DW_TAG_compile_unit
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 37                                  // DW_AT_producer
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 19                                  // DW_AT_language
+-; CHECK-NEXT:.b8 5                                   // DW_FORM_data2
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 16                                  // DW_AT_stmt_list
+-; CHECK-NEXT:.b8 6                                   // DW_FORM_data4
+-; CHECK-NEXT:.b8 27                                  // DW_AT_comp_dir
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 2                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 19                                  // DW_TAG_structure_type
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 11                                  // DW_AT_byte_size
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 3                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 135                                 // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 64
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 60                                  // DW_AT_declaration
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 4                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 135                                 // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 64
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 60                                  // DW_AT_declaration
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 100                                 // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 5                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 5                                   // DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 52                                  // DW_AT_artificial
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 6                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 60                                  // DW_AT_declaration
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 100                                 // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 50                                  // DW_AT_accessibility
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 7                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 5                                   // DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 8                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 135                                 // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 64
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 60                                  // DW_AT_declaration
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 100                                 // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 50                                  // DW_AT_accessibility
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 9                                   // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 135                                 // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 64
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 60                                  // DW_AT_declaration
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 100                                 // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 50                                  // DW_AT_accessibility
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 10                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 36                                  // DW_TAG_base_type
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 62                                  // DW_AT_encoding
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 11                                  // DW_AT_byte_size
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 11                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 13                                  // DW_TAG_member
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 56                                  // DW_AT_data_member_location
+-; CHECK-NEXT:.b8 10                                  // DW_FORM_block1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 12                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 15                                  // DW_TAG_pointer_type
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 13                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 38                                  // DW_TAG_const_type
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 14                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 16                                  // DW_TAG_reference_type
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 15                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 71                                  // DW_AT_specification
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 32                                  // DW_AT_inline
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 16                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 19                                  // DW_TAG_structure_type
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 11                                  // DW_AT_byte_size
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 5                                   // DW_FORM_data2
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 17                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 13                                  // DW_TAG_member
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 5                                   // DW_FORM_data2
+-; CHECK-NEXT:.b8 56                                  // DW_AT_data_member_location
+-; CHECK-NEXT:.b8 10                                  // DW_FORM_block1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 18                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 5                                   // DW_FORM_data2
+-; CHECK-NEXT:.b8 60                                  // DW_AT_declaration
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 100                                 // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 19                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 135                                 // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 64
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 5                                   // DW_FORM_data2
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 60                                  // DW_AT_declaration
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 100                                 // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 20                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 22                                  // DW_TAG_typedef
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 5                                   // DW_FORM_data2
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 21                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 135                                 // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 64
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 32                                  // DW_AT_inline
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 22                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 5                                   // DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 23                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 17                                  // DW_AT_low_pc
+-; CHECK-NEXT:.b8 1                                   // DW_FORM_addr
+-; CHECK-NEXT:.b8 18                                  // DW_AT_high_pc
+-; CHECK-NEXT:.b8 1                                   // DW_FORM_addr
+-; CHECK-NEXT:.b8 64                                  // DW_AT_frame_base
+-; CHECK-NEXT:.b8 10                                  // DW_FORM_block1
+-; CHECK-NEXT:.b8 135                                 // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 64
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 63                                  // DW_AT_external
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 24                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 5                                   // DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 51                                  // DW_AT_address_class
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 2                                   // DW_AT_location
+-; CHECK-NEXT:.b8 10                                  // DW_FORM_block1
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 25                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 5                                   // DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 2                                   // DW_AT_location
+-; CHECK-NEXT:.b8 6                                   // DW_FORM_data4
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 26                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 52                                  // DW_TAG_variable
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 2                                   // DW_AT_location
+-; CHECK-NEXT:.b8 6                                   // DW_FORM_data4
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 27                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 29                                  // DW_TAG_inlined_subroutine
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 49                                  // DW_AT_abstract_origin
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 17                                  // DW_AT_low_pc
+-; CHECK-NEXT:.b8 1                                   // DW_FORM_addr
+-; CHECK-NEXT:.b8 18                                  // DW_AT_high_pc
+-; CHECK-NEXT:.b8 1                                   // DW_FORM_addr
+-; CHECK-NEXT:.b8 88                                  // DW_AT_call_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 89                                  // DW_AT_call_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 87                                  // DW_AT_call_column
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 28                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 29                                  // DW_TAG_inlined_subroutine
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 49                                  // DW_AT_abstract_origin
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 17                                  // DW_AT_low_pc
+-; CHECK-NEXT:.b8 1                                   // DW_FORM_addr
+-; CHECK-NEXT:.b8 18                                  // DW_AT_high_pc
+-; CHECK-NEXT:.b8 1                                   // DW_FORM_addr
+-; CHECK-NEXT:.b8 88                                  // DW_AT_call_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 89                                  // DW_AT_call_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 87                                  // DW_AT_call_column
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 29                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 5                                   // DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 51                                  // DW_AT_address_class
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 2                                   // DW_AT_location
+-; CHECK-NEXT:.b8 10                                  // DW_FORM_block1
+-; CHECK-NEXT:.b8 49                                  // DW_AT_abstract_origin
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 30                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 57                                  // DW_TAG_namespace
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 31                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 8                                   // DW_TAG_imported_declaration
+-; CHECK-NEXT:.b8 0                                   // DW_CHILDREN_no
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 24                                  // DW_AT_import
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 32                                  // Abbreviation Code
+-; CHECK-NEXT:.b8 46                                  // DW_TAG_subprogram
+-; CHECK-NEXT:.b8 1                                   // DW_CHILDREN_yes
+-; CHECK-NEXT:.b8 135                                 // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 64
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 3                                   // DW_AT_name
+-; CHECK-NEXT:.b8 8                                   // DW_FORM_string
+-; CHECK-NEXT:.b8 58                                  // DW_AT_decl_file
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 59                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // DW_FORM_data1
+-; CHECK-NEXT:.b8 73                                  // DW_AT_type
+-; CHECK-NEXT:.b8 19                                  // DW_FORM_ref4
+-; CHECK-NEXT:.b8 60                                  // DW_AT_declaration
+-; CHECK-NEXT:.b8 12                                  // DW_FORM_flag
+-; CHECK-NEXT:.b8 0                                   // EOM(1)
+-; CHECK-NEXT:.b8 0                                   // EOM(2)
+-; CHECK-NEXT:.b8 0                                   // EOM(3)
+-; CHECK-NEXT:	}
+-; CHECK-NEXT:	.section	.debug_info
+-; CHECK-NEXT:	{
+-; CHECK-NEXT:.b32 2460                               // Length of Unit
+-; CHECK-NEXT:.b8 2                                   // DWARF version number
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b32 .debug_abbrev                      // Offset Into Abbrev. Section
+-; CHECK-NEXT:.b8 8                                   // Address Size (in bytes)
+-; CHECK-NEXT:.b8 1                                   // Abbrev [1] 0xb:0x995 DW_TAG_compile_unit
+-; CHECK-NEXT:.b8 0                                   // DW_AT_producer
+-; CHECK-NEXT:.b8 4                                   // DW_AT_language
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 100                                 // DW_AT_name
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 103
+-; CHECK-NEXT:.b8 45
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 46
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b32 .debug_line                        // DW_AT_stmt_list
+-; CHECK-NEXT:.b8 47                                  // DW_AT_comp_dir
+-; CHECK-NEXT:.b8 115
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 47
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // Abbrev [2] 0x31:0x23e DW_TAG_structure_type
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_byte_size
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 77                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0x4f:0x4f DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 78                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0x9e:0x4f DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 79                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0xed:0x4f DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 122
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 122
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 80                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 4                                   // Abbrev [4] 0x13c:0x4d DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 32
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 83                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 639                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 386                                // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x182:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 686                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 6                                   // Abbrev [6] 0x189:0x2b DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 85                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 429                                // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x1ad:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 696                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 6                                   // Abbrev [6] 0x1b4:0x30 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 85                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 472                                // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x1d8:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 696                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x1de:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 701                                // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 8                                   // Abbrev [8] 0x1e4:0x47 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 83
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 82
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 83
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 61
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 85                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 543                                // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x21f:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 686                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x225:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 701                                // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 9                                   // Abbrev [9] 0x22b:0x43 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 38
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 85                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 706                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 615                                // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x267:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 686                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 10                                  // Abbrev [10] 0x26f:0x10 DW_TAG_base_type
+-; CHECK-NEXT:.b8 117                                 // DW_AT_name
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 115
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 103
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 32
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 7                                   // DW_AT_encoding
+-; CHECK-NEXT:.b8 4                                   // DW_AT_byte_size
+-; CHECK-NEXT:.b8 2                                   // Abbrev [2] 0x27f:0x2f DW_TAG_structure_type
+-; CHECK-NEXT:.b8 117                                 // DW_AT_name
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 12                                  // DW_AT_byte_size
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 190                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 11                                  // Abbrev [11] 0x289:0xc DW_TAG_member
+-; CHECK-NEXT:.b8 120                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 192                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 2                                   // DW_AT_data_member_location
+-; CHECK-NEXT:.b8 35
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 11                                  // Abbrev [11] 0x295:0xc DW_TAG_member
+-; CHECK-NEXT:.b8 121                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 192                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 2                                   // DW_AT_data_member_location
+-; CHECK-NEXT:.b8 35
+-; CHECK-NEXT:.b8 4
+-; CHECK-NEXT:.b8 11                                  // Abbrev [11] 0x2a1:0xc DW_TAG_member
+-; CHECK-NEXT:.b8 122                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 192                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 2                                   // DW_AT_data_member_location
+-; CHECK-NEXT:.b8 35
+-; CHECK-NEXT:.b8 8
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x2ae:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 691                                // DW_AT_type
+-; CHECK-NEXT:.b8 13                                  // Abbrev [13] 0x2b3:0x5 DW_TAG_const_type
+-; CHECK-NEXT:.b32 49                                 // DW_AT_type
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x2b8:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 49                                 // DW_AT_type
+-; CHECK-NEXT:.b8 14                                  // Abbrev [14] 0x2bd:0x5 DW_TAG_reference_type
+-; CHECK-NEXT:.b32 691                                // DW_AT_type
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x2c2:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 49                                 // DW_AT_type
+-; CHECK-NEXT:.b8 15                                  // Abbrev [15] 0x2c7:0x6 DW_TAG_subprogram
+-; CHECK-NEXT:.b32 79                                 // DW_AT_specification
+-; CHECK-NEXT:.b8 1                                   // DW_AT_inline
+-; CHECK-NEXT:.b8 2                                   // Abbrev [2] 0x2cd:0x23c DW_TAG_structure_type
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_byte_size
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 88                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0x2eb:0x4f DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 89                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0x33a:0x4f DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 90                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0x389:0x4f DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 122
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 122
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 91                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 4                                   // Abbrev [4] 0x3d8:0x4b DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 52
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 32
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 94                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 1289                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1052                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x41c:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1477                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 6                                   // Abbrev [6] 0x423:0x2b DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 96                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1095                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x447:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1487                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 6                                   // Abbrev [6] 0x44e:0x30 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 96                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1138                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x472:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1487                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x478:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1492                               // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 8                                   // Abbrev [8] 0x47e:0x47 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 83
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 82
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 83
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 61
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 96                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1209                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x4b9:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1477                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x4bf:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1492                               // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 9                                   // Abbrev [9] 0x4c5:0x43 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 107
+-; CHECK-NEXT:.b8 68
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 38
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 96                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 1497                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1281                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x501:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1477                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 16                                  // Abbrev [16] 0x509:0xa9 DW_TAG_structure_type
+-; CHECK-NEXT:.b8 100                                 // DW_AT_name
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 12                                  // DW_AT_byte_size
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 161                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b8 17                                  // Abbrev [17] 0x513:0xd DW_TAG_member
+-; CHECK-NEXT:.b8 120                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 163                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b8 2                                   // DW_AT_data_member_location
+-; CHECK-NEXT:.b8 35
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 17                                  // Abbrev [17] 0x520:0xd DW_TAG_member
+-; CHECK-NEXT:.b8 121                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 163                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b8 2                                   // DW_AT_data_member_location
+-; CHECK-NEXT:.b8 35
+-; CHECK-NEXT:.b8 4
+-; CHECK-NEXT:.b8 17                                  // Abbrev [17] 0x52d:0xd DW_TAG_member
+-; CHECK-NEXT:.b8 122                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 163                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b8 2                                   // DW_AT_data_member_location
+-; CHECK-NEXT:.b8 35
+-; CHECK-NEXT:.b8 8
+-; CHECK-NEXT:.b8 18                                  // Abbrev [18] 0x53a:0x25 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 100                                 // DW_AT_name
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 165                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1353                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x549:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1458                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x54f:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x554:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x559:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 18                                  // Abbrev [18] 0x55f:0x1b DW_TAG_subprogram
+-; CHECK-NEXT:.b8 100                                 // DW_AT_name
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 166                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1390                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x56e:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1458                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x574:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1463                               // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 19                                  // Abbrev [19] 0x57a:0x37 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 52
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 109
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 32
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 167                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b32 1463                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1450                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x5aa:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 1458                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x5b2:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 1289                               // DW_AT_type
+-; CHECK-NEXT:.b8 20                                  // Abbrev [20] 0x5b7:0xe DW_TAG_typedef
+-; CHECK-NEXT:.b32 639                                // DW_AT_type
+-; CHECK-NEXT:.b8 117                                 // DW_AT_name
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 127                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x5c5:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 1482                               // DW_AT_type
+-; CHECK-NEXT:.b8 13                                  // Abbrev [13] 0x5ca:0x5 DW_TAG_const_type
+-; CHECK-NEXT:.b32 717                                // DW_AT_type
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x5cf:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 717                                // DW_AT_type
+-; CHECK-NEXT:.b8 14                                  // Abbrev [14] 0x5d4:0x5 DW_TAG_reference_type
+-; CHECK-NEXT:.b32 1482                               // DW_AT_type
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x5d9:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 717                                // DW_AT_type
+-; CHECK-NEXT:.b8 15                                  // Abbrev [15] 0x5de:0x6 DW_TAG_subprogram
+-; CHECK-NEXT:.b32 747                                // DW_AT_specification
+-; CHECK-NEXT:.b8 1                                   // DW_AT_inline
+-; CHECK-NEXT:.b8 2                                   // Abbrev [2] 0x5e4:0x247 DW_TAG_structure_type
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_byte_size
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 66                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0x603:0x50 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 54
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 67                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0x653:0x50 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 54
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 68                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // Abbrev [3] 0x6a3:0x50 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 54
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 49
+-; CHECK-NEXT:.b8 55
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 122
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 122
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 69                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 623                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 4                                   // Abbrev [4] 0x6f3:0x4e DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 54
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 32
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 72                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 639                                // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1850                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x73a:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 2091                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 6                                   // Abbrev [6] 0x741:0x2c DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 74                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1894                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x766:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 2101                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 6                                   // Abbrev [6] 0x76d:0x31 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_name
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 74                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 1938                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x792:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 2101                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x798:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 2106                               // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 8                                   // Abbrev [8] 0x79e:0x48 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 54
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 83
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 82
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 83
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 61
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 74                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 2010                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x7da:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 2091                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x7e0:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 2106                               // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 9                                   // Abbrev [9] 0x7e6:0x44 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 78
+-; CHECK-NEXT:.b8 75
+-; CHECK-NEXT:.b8 50
+-; CHECK-NEXT:.b8 54
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 99
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 117
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 104
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 73
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 69
+-; CHECK-NEXT:.b8 118
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 111                                 // DW_AT_name
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 38
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 2                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 74                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2111                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b32 2083                               // DW_AT_object_pointer
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 3                                   // DW_AT_accessibility
+-; CHECK-NEXT:                                        // DW_ACCESS_private
+-; CHECK-NEXT:.b8 5                                   // Abbrev [5] 0x823:0x6 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 2091                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_artificial
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x82b:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 2096                               // DW_AT_type
+-; CHECK-NEXT:.b8 13                                  // Abbrev [13] 0x830:0x5 DW_TAG_const_type
+-; CHECK-NEXT:.b32 1508                               // DW_AT_type
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x835:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 1508                               // DW_AT_type
+-; CHECK-NEXT:.b8 14                                  // Abbrev [14] 0x83a:0x5 DW_TAG_reference_type
+-; CHECK-NEXT:.b32 2096                               // DW_AT_type
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x83f:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 1508                               // DW_AT_type
+-; CHECK-NEXT:.b8 15                                  // Abbrev [15] 0x844:0x6 DW_TAG_subprogram
+-; CHECK-NEXT:.b32 1539                               // DW_AT_specification
+-; CHECK-NEXT:.b8 1                                   // DW_AT_inline
+-; CHECK-NEXT:.b8 21                                  // Abbrev [21] 0x84a:0x32 DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 114
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 115
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 80
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 114                                 // DW_AT_name
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 115
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 1                                   // DW_AT_inline
+-; CHECK-NEXT:.b8 22                                  // Abbrev [22] 0x85e:0x9 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 120                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2172                               // DW_AT_type
+-; CHECK-NEXT:.b8 22                                  // Abbrev [22] 0x867:0x9 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 121                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2172                               // DW_AT_type
+-; CHECK-NEXT:.b8 22                                  // Abbrev [22] 0x870:0xb DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 114                                 // DW_AT_name
+-; CHECK-NEXT:.b8 101
+-; CHECK-NEXT:.b8 115
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 3                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2181                               // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 10                                  // Abbrev [10] 0x87c:0x9 DW_TAG_base_type
+-; CHECK-NEXT:.b8 102                                 // DW_AT_name
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 4                                   // DW_AT_encoding
+-; CHECK-NEXT:.b8 4                                   // DW_AT_byte_size
+-; CHECK-NEXT:.b8 12                                  // Abbrev [12] 0x885:0x5 DW_TAG_pointer_type
+-; CHECK-NEXT:.b32 2172                               // DW_AT_type
+-; CHECK-NEXT:.b8 23                                  // Abbrev [23] 0x88a:0xd5 DW_TAG_subprogram
+-; CHECK-NEXT:.b64 $L__func_begin0                    // DW_AT_low_pc
+-; CHECK-NEXT:.b64 $L__func_end0                      // DW_AT_high_pc
+-; CHECK-NEXT:.b8 1                                   // DW_AT_frame_base
+-; CHECK-NEXT:.b8 156
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 53
+-; CHECK-NEXT:.b8 115
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 80
+-; CHECK-NEXT:.b8 102
+-; CHECK-NEXT:.b8 83
+-; CHECK-NEXT:.b8 95
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 115                                 // DW_AT_name
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 112
+-; CHECK-NEXT:.b8 121
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 5                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b8 1                                   // DW_AT_external
+-; CHECK-NEXT:.b8 24                                  // Abbrev [24] 0x8b5:0x10 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 2                                   // DW_AT_address_class
+-; CHECK-NEXT:.b8 5                                   // DW_AT_location
+-; CHECK-NEXT:.b8 144
+-; CHECK-NEXT:.b8 178
+-; CHECK-NEXT:.b8 228
+-; CHECK-NEXT:.b8 149
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b8 110                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 5                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2456                               // DW_AT_type
+-; CHECK-NEXT:.b8 25                                  // Abbrev [25] 0x8c5:0xd DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 $L__debug_loc0                     // DW_AT_location
+-; CHECK-NEXT:.b8 97                                  // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 5                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2172                               // DW_AT_type
+-; CHECK-NEXT:.b8 22                                  // Abbrev [22] 0x8d2:0x9 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 120                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 5                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2181                               // DW_AT_type
+-; CHECK-NEXT:.b8 22                                  // Abbrev [22] 0x8db:0x9 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 121                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 5                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2181                               // DW_AT_type
+-; CHECK-NEXT:.b8 26                                  // Abbrev [26] 0x8e4:0xd DW_TAG_variable
+-; CHECK-NEXT:.b32 $L__debug_loc1                     // DW_AT_location
+-; CHECK-NEXT:.b8 105                                 // DW_AT_name
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 1                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 6                                   // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2456                               // DW_AT_type
+-; CHECK-NEXT:.b8 27                                  // Abbrev [27] 0x8f1:0x18 DW_TAG_inlined_subroutine
+-; CHECK-NEXT:.b32 711                                // DW_AT_abstract_origin
+-; CHECK-NEXT:.b64 $L__tmp1                           // DW_AT_low_pc
+-; CHECK-NEXT:.b64 $L__tmp2                           // DW_AT_high_pc
+-; CHECK-NEXT:.b8 1                                   // DW_AT_call_file
+-; CHECK-NEXT:.b8 6                                   // DW_AT_call_line
+-; CHECK-NEXT:.b8 11                                  // DW_AT_call_column
+-; CHECK-NEXT:.b8 27                                  // Abbrev [27] 0x909:0x18 DW_TAG_inlined_subroutine
+-; CHECK-NEXT:.b32 1502                               // DW_AT_abstract_origin
+-; CHECK-NEXT:.b64 $L__tmp2                           // DW_AT_low_pc
+-; CHECK-NEXT:.b64 $L__tmp3                           // DW_AT_high_pc
+-; CHECK-NEXT:.b8 1                                   // DW_AT_call_file
+-; CHECK-NEXT:.b8 6                                   // DW_AT_call_line
+-; CHECK-NEXT:.b8 24                                  // DW_AT_call_column
+-; CHECK-NEXT:.b8 27                                  // Abbrev [27] 0x921:0x18 DW_TAG_inlined_subroutine
+-; CHECK-NEXT:.b32 2116                               // DW_AT_abstract_origin
+-; CHECK-NEXT:.b64 $L__tmp3                           // DW_AT_low_pc
+-; CHECK-NEXT:.b64 $L__tmp4                           // DW_AT_high_pc
+-; CHECK-NEXT:.b8 1                                   // DW_AT_call_file
+-; CHECK-NEXT:.b8 6                                   // DW_AT_call_line
+-; CHECK-NEXT:.b8 37                                  // DW_AT_call_column
+-; CHECK-NEXT:.b8 28                                  // Abbrev [28] 0x939:0x25 DW_TAG_inlined_subroutine
+-; CHECK-NEXT:.b32 2122                               // DW_AT_abstract_origin
+-; CHECK-NEXT:.b64 $L__tmp9                           // DW_AT_low_pc
+-; CHECK-NEXT:.b64 $L__tmp10                          // DW_AT_high_pc
+-; CHECK-NEXT:.b8 1                                   // DW_AT_call_file
+-; CHECK-NEXT:.b8 8                                   // DW_AT_call_line
+-; CHECK-NEXT:.b8 5                                   // DW_AT_call_column
+-; CHECK-NEXT:.b8 29                                  // Abbrev [29] 0x951:0xc DW_TAG_formal_parameter
+-; CHECK-NEXT:.b8 2                                   // DW_AT_address_class
+-; CHECK-NEXT:.b8 5                                   // DW_AT_location
+-; CHECK-NEXT:.b8 144
+-; CHECK-NEXT:.b8 179
+-; CHECK-NEXT:.b8 204
+-; CHECK-NEXT:.b8 149
+-; CHECK-NEXT:.b8 1
+-; CHECK-NEXT:.b32 2151                               // DW_AT_abstract_origin
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 30                                  // Abbrev [30] 0x95f:0xd DW_TAG_namespace
+-; CHECK-NEXT:.b8 115                                 // DW_AT_name
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 100
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 31                                  // Abbrev [31] 0x964:0x7 DW_TAG_imported_declaration
+-; CHECK-NEXT:.b8 4                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 202                                 // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2412                               // DW_AT_import
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 32                                  // Abbrev [32] 0x96c:0x1b DW_TAG_subprogram
+-; CHECK-NEXT:.b8 95                                  // DW_AT_MIPS_linkage_name
+-; CHECK-NEXT:.b8 90
+-; CHECK-NEXT:.b8 76
+-; CHECK-NEXT:.b8 51
+-; CHECK-NEXT:.b8 97
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 115
+-; CHECK-NEXT:.b8 120
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 97                                  // DW_AT_name
+-; CHECK-NEXT:.b8 98
+-; CHECK-NEXT:.b8 115
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 4                                   // DW_AT_decl_file
+-; CHECK-NEXT:.b8 44                                  // DW_AT_decl_line
+-; CHECK-NEXT:.b32 2439                               // DW_AT_type
+-; CHECK-NEXT:.b8 1                                   // DW_AT_declaration
+-; CHECK-NEXT:.b8 7                                   // Abbrev [7] 0x981:0x5 DW_TAG_formal_parameter
+-; CHECK-NEXT:.b32 2439                               // DW_AT_type
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:.b8 10                                  // Abbrev [10] 0x987:0x11 DW_TAG_base_type
+-; CHECK-NEXT:.b8 108                                 // DW_AT_name
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 103
+-; CHECK-NEXT:.b8 32
+-; CHECK-NEXT:.b8 108
+-; CHECK-NEXT:.b8 111
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 103
+-; CHECK-NEXT:.b8 32
+-; CHECK-NEXT:.b8 105
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 5                                   // DW_AT_encoding
+-; CHECK-NEXT:.b8 8                                   // DW_AT_byte_size
+-; CHECK-NEXT:.b8 10                                  // Abbrev [10] 0x998:0x7 DW_TAG_base_type
+-; CHECK-NEXT:.b8 105                                 // DW_AT_name
+-; CHECK-NEXT:.b8 110
+-; CHECK-NEXT:.b8 116
+-; CHECK-NEXT:.b8 0
+-; CHECK-NEXT:.b8 5                                   // DW_AT_encoding
+-; CHECK-NEXT:.b8 4                                   // DW_AT_byte_size
+-; CHECK-NEXT:.b8 0                                   // End Of Children Mark
+-; CHECK-NEXT:	}
+-; CHECK-NEXT:	.section	.debug_macinfo	{	}
++; CHECK-NEXT: 	{
++; CHECK-NEXT: $L__debug_loc0:
++; CHECK-NEXT: .b64 $L__tmp8
++; CHECK-NEXT: .b64 $L__tmp10
++; CHECK-NEXT: .b8 5                                   // Loc expr size
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 144                                 // DW_OP_regx
++; CHECK-NEXT: .b8 177                                 // 2450993
++; CHECK-NEXT: .b8 204                                 // 
++; CHECK-NEXT: .b8 149                                 // 
++; CHECK-NEXT: .b8 1                                   // 
++; CHECK-NEXT: .b64 0
++; CHECK-NEXT: .b64 0
++; CHECK-NEXT: $L__debug_loc1:
++; CHECK-NEXT: .b64 $L__tmp5
++; CHECK-NEXT: .b64 $L__func_end0
++; CHECK-NEXT: .b8 5                                   // Loc expr size
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 144                                 // DW_OP_regx
++; CHECK-NEXT: .b8 177                                 // 2454065
++; CHECK-NEXT: .b8 228                                 // 
++; CHECK-NEXT: .b8 149                                 // 
++; CHECK-NEXT: .b8 1                                   // 
++; CHECK-NEXT: .b64 0
++; CHECK-NEXT: .b64 0
++; CHECK-NEXT: 	}
++; CHECK-NEXT: 	.section	.debug_abbrev
++; CHECK-NEXT: 	{
++; CHECK-NEXT: .b8 1                                   // Abbreviation Code
++; CHECK-NEXT: .b8 17                                  // DW_TAG_compile_unit
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 37                                  // DW_AT_producer
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 19                                  // DW_AT_language
++; CHECK-NEXT: .b8 5                                   // DW_FORM_data2
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 16                                  // DW_AT_stmt_list
++; CHECK-NEXT: .b8 6                                   // DW_FORM_data4
++; CHECK-NEXT: .b8 27                                  // DW_AT_comp_dir
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 2                                   // Abbreviation Code
++; CHECK-NEXT: .b8 19                                  // DW_TAG_structure_type
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 11                                  // DW_AT_byte_size
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 3                                   // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 135                                 // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 64
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 60                                  // DW_AT_declaration
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 4                                   // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 135                                 // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 64
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 60                                  // DW_AT_declaration
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 5                                   // Abbreviation Code
++; CHECK-NEXT: .b8 5                                   // DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 52                                  // DW_AT_artificial
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 6                                   // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 60                                  // DW_AT_declaration
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 50                                  // DW_AT_accessibility
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 7                                   // Abbreviation Code
++; CHECK-NEXT: .b8 5                                   // DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 8                                   // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 135                                 // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 64
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 60                                  // DW_AT_declaration
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 50                                  // DW_AT_accessibility
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 9                                   // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 135                                 // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 64
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 60                                  // DW_AT_declaration
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 50                                  // DW_AT_accessibility
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 10                                  // Abbreviation Code
++; CHECK-NEXT: .b8 36                                  // DW_TAG_base_type
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 62                                  // DW_AT_encoding
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 11                                  // DW_AT_byte_size
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 11                                  // Abbreviation Code
++; CHECK-NEXT: .b8 13                                  // DW_TAG_member
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 56                                  // DW_AT_data_member_location
++; CHECK-NEXT: .b8 10                                  // DW_FORM_block1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 12                                  // Abbreviation Code
++; CHECK-NEXT: .b8 15                                  // DW_TAG_pointer_type
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 13                                  // Abbreviation Code
++; CHECK-NEXT: .b8 38                                  // DW_TAG_const_type
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 14                                  // Abbreviation Code
++; CHECK-NEXT: .b8 16                                  // DW_TAG_reference_type
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 15                                  // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 71                                  // DW_AT_specification
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 32                                  // DW_AT_inline
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 16                                  // Abbreviation Code
++; CHECK-NEXT: .b8 19                                  // DW_TAG_structure_type
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 11                                  // DW_AT_byte_size
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 5                                   // DW_FORM_data2
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 17                                  // Abbreviation Code
++; CHECK-NEXT: .b8 13                                  // DW_TAG_member
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 5                                   // DW_FORM_data2
++; CHECK-NEXT: .b8 56                                  // DW_AT_data_member_location
++; CHECK-NEXT: .b8 10                                  // DW_FORM_block1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 18                                  // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 5                                   // DW_FORM_data2
++; CHECK-NEXT: .b8 60                                  // DW_AT_declaration
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 19                                  // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 135                                 // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 64
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 5                                   // DW_FORM_data2
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 60                                  // DW_AT_declaration
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 20                                  // Abbreviation Code
++; CHECK-NEXT: .b8 22                                  // DW_TAG_typedef
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 5                                   // DW_FORM_data2
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 21                                  // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 135                                 // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 64
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 32                                  // DW_AT_inline
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 22                                  // Abbreviation Code
++; CHECK-NEXT: .b8 5                                   // DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 23                                  // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 17                                  // DW_AT_low_pc
++; CHECK-NEXT: .b8 1                                   // DW_FORM_addr
++; CHECK-NEXT: .b8 18                                  // DW_AT_high_pc
++; CHECK-NEXT: .b8 1                                   // DW_FORM_addr
++; CHECK-NEXT: .b8 64                                  // DW_AT_frame_base
++; CHECK-NEXT: .b8 10                                  // DW_FORM_block1
++; CHECK-NEXT: .b8 135                                 // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 64
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 63                                  // DW_AT_external
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 24                                  // Abbreviation Code
++; CHECK-NEXT: .b8 5                                   // DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 51                                  // DW_AT_address_class
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 2                                   // DW_AT_location
++; CHECK-NEXT: .b8 10                                  // DW_FORM_block1
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 25                                  // Abbreviation Code
++; CHECK-NEXT: .b8 5                                   // DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 2                                   // DW_AT_location
++; CHECK-NEXT: .b8 6                                   // DW_FORM_data4
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 26                                  // Abbreviation Code
++; CHECK-NEXT: .b8 52                                  // DW_TAG_variable
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 2                                   // DW_AT_location
++; CHECK-NEXT: .b8 6                                   // DW_FORM_data4
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 27                                  // Abbreviation Code
++; CHECK-NEXT: .b8 29                                  // DW_TAG_inlined_subroutine
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 49                                  // DW_AT_abstract_origin
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 17                                  // DW_AT_low_pc
++; CHECK-NEXT: .b8 1                                   // DW_FORM_addr
++; CHECK-NEXT: .b8 18                                  // DW_AT_high_pc
++; CHECK-NEXT: .b8 1                                   // DW_FORM_addr
++; CHECK-NEXT: .b8 88                                  // DW_AT_call_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 89                                  // DW_AT_call_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 87                                  // DW_AT_call_column
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 28                                  // Abbreviation Code
++; CHECK-NEXT: .b8 29                                  // DW_TAG_inlined_subroutine
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 49                                  // DW_AT_abstract_origin
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 17                                  // DW_AT_low_pc
++; CHECK-NEXT: .b8 1                                   // DW_FORM_addr
++; CHECK-NEXT: .b8 18                                  // DW_AT_high_pc
++; CHECK-NEXT: .b8 1                                   // DW_FORM_addr
++; CHECK-NEXT: .b8 88                                  // DW_AT_call_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 89                                  // DW_AT_call_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 87                                  // DW_AT_call_column
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 29                                  // Abbreviation Code
++; CHECK-NEXT: .b8 5                                   // DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 51                                  // DW_AT_address_class
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 2                                   // DW_AT_location
++; CHECK-NEXT: .b8 10                                  // DW_FORM_block1
++; CHECK-NEXT: .b8 49                                  // DW_AT_abstract_origin
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 30                                  // Abbreviation Code
++; CHECK-NEXT: .b8 57                                  // DW_TAG_namespace
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 31                                  // Abbreviation Code
++; CHECK-NEXT: .b8 8                                   // DW_TAG_imported_declaration
++; CHECK-NEXT: .b8 0                                   // DW_CHILDREN_no
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 24                                  // DW_AT_import
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 32                                  // Abbreviation Code
++; CHECK-NEXT: .b8 46                                  // DW_TAG_subprogram
++; CHECK-NEXT: .b8 1                                   // DW_CHILDREN_yes
++; CHECK-NEXT: .b8 135                                 // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 64
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 3                                   // DW_AT_name
++; CHECK-NEXT: .b8 8                                   // DW_FORM_string
++; CHECK-NEXT: .b8 58                                  // DW_AT_decl_file
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 59                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // DW_FORM_data1
++; CHECK-NEXT: .b8 73                                  // DW_AT_type
++; CHECK-NEXT: .b8 19                                  // DW_FORM_ref4
++; CHECK-NEXT: .b8 60                                  // DW_AT_declaration
++; CHECK-NEXT: .b8 12                                  // DW_FORM_flag
++; CHECK-NEXT: .b8 0                                   // EOM(1)
++; CHECK-NEXT: .b8 0                                   // EOM(2)
++; CHECK-NEXT: .b8 0                                   // EOM(3)
++; CHECK-NEXT: 	}
++; CHECK-NEXT: 	.section	.debug_info
++; CHECK-NEXT: 	{
++; CHECK-NEXT: .b32 2388                               // Length of Unit
++; CHECK-NEXT: .b8 2                                   // DWARF version number
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b32 .debug_abbrev                      // Offset Into Abbrev. Section
++; CHECK-NEXT: .b8 8                                   // Address Size (in bytes)
++; CHECK-NEXT: .b8 1                                   // Abbrev [1] 0xb:0x94d DW_TAG_compile_unit
++; CHECK-NEXT: .b8 0                                   // DW_AT_producer
++; CHECK-NEXT: .b8 4                                   // DW_AT_language
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 100                                 // DW_AT_name
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 103
++; CHECK-NEXT: .b8 45
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 46
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b32 .debug_line                        // DW_AT_stmt_list
++; CHECK-NEXT: .b8 47                                  // DW_AT_comp_dir
++; CHECK-NEXT: .b8 115
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 47
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // Abbrev [2] 0x31:0x22a DW_TAG_structure_type
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_byte_size
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 77                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0x4f:0x4f DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 78                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0x9e:0x4f DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 79                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0xed:0x4f DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 122
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 122
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 80                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 4                                   // Abbrev [4] 0x13c:0x49 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 32
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 83                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 619                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x17e:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 666                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 6                                   // Abbrev [6] 0x185:0x27 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 85                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x1a5:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 676                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 6                                   // Abbrev [6] 0x1ac:0x2c DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 85                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x1cc:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 676                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x1d2:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 681                                // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 8                                   // Abbrev [8] 0x1d8:0x43 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 83
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 82
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 83
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 61
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 85                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x20f:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 666                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x215:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 681                                // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 9                                   // Abbrev [9] 0x21b:0x3f DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 38
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 85                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 686                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x253:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 666                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 10                                  // Abbrev [10] 0x25b:0x10 DW_TAG_base_type
++; CHECK-NEXT: .b8 117                                 // DW_AT_name
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 115
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 103
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 32
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 7                                   // DW_AT_encoding
++; CHECK-NEXT: .b8 4                                   // DW_AT_byte_size
++; CHECK-NEXT: .b8 2                                   // Abbrev [2] 0x26b:0x2f DW_TAG_structure_type
++; CHECK-NEXT: .b8 117                                 // DW_AT_name
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 12                                  // DW_AT_byte_size
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 190                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 11                                  // Abbrev [11] 0x275:0xc DW_TAG_member
++; CHECK-NEXT: .b8 120                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 192                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 2                                   // DW_AT_data_member_location
++; CHECK-NEXT: .b8 35
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 11                                  // Abbrev [11] 0x281:0xc DW_TAG_member
++; CHECK-NEXT: .b8 121                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 192                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 2                                   // DW_AT_data_member_location
++; CHECK-NEXT: .b8 35
++; CHECK-NEXT: .b8 4
++; CHECK-NEXT: .b8 11                                  // Abbrev [11] 0x28d:0xc DW_TAG_member
++; CHECK-NEXT: .b8 122                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 192                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 2                                   // DW_AT_data_member_location
++; CHECK-NEXT: .b8 35
++; CHECK-NEXT: .b8 8
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x29a:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 671                                // DW_AT_type
++; CHECK-NEXT: .b8 13                                  // Abbrev [13] 0x29f:0x5 DW_TAG_const_type
++; CHECK-NEXT: .b32 49                                 // DW_AT_type
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x2a4:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 49                                 // DW_AT_type
++; CHECK-NEXT: .b8 14                                  // Abbrev [14] 0x2a9:0x5 DW_TAG_reference_type
++; CHECK-NEXT: .b32 671                                // DW_AT_type
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x2ae:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 49                                 // DW_AT_type
++; CHECK-NEXT: .b8 15                                  // Abbrev [15] 0x2b3:0x6 DW_TAG_subprogram
++; CHECK-NEXT: .b32 79                                 // DW_AT_specification
++; CHECK-NEXT: .b8 1                                   // DW_AT_inline
++; CHECK-NEXT: .b8 2                                   // Abbrev [2] 0x2b9:0x228 DW_TAG_structure_type
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_byte_size
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 88                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0x2d7:0x4f DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 89                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0x326:0x4f DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 90                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0x375:0x4f DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 122
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 122
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 91                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 4                                   // Abbrev [4] 0x3c4:0x47 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 52
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 32
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 94                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 1249                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x404:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1425                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 6                                   // Abbrev [6] 0x40b:0x27 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 96                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x42b:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1435                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 6                                   // Abbrev [6] 0x432:0x2c DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 96                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x452:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1435                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x458:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1440                               // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 8                                   // Abbrev [8] 0x45e:0x43 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 83
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 82
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 83
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 61
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 96                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x495:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1425                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x49b:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1440                               // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 9                                   // Abbrev [9] 0x4a1:0x3f DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 107
++; CHECK-NEXT: .b8 68
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 38
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 96                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 1445                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x4d9:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1425                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 16                                  // Abbrev [16] 0x4e1:0x9d DW_TAG_structure_type
++; CHECK-NEXT: .b8 100                                 // DW_AT_name
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 12                                  // DW_AT_byte_size
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 161                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b8 17                                  // Abbrev [17] 0x4eb:0xd DW_TAG_member
++; CHECK-NEXT: .b8 120                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 163                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b8 2                                   // DW_AT_data_member_location
++; CHECK-NEXT: .b8 35
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 17                                  // Abbrev [17] 0x4f8:0xd DW_TAG_member
++; CHECK-NEXT: .b8 121                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 163                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b8 2                                   // DW_AT_data_member_location
++; CHECK-NEXT: .b8 35
++; CHECK-NEXT: .b8 4
++; CHECK-NEXT: .b8 17                                  // Abbrev [17] 0x505:0xd DW_TAG_member
++; CHECK-NEXT: .b8 122                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 163                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b8 2                                   // DW_AT_data_member_location
++; CHECK-NEXT: .b8 35
++; CHECK-NEXT: .b8 8
++; CHECK-NEXT: .b8 18                                  // Abbrev [18] 0x512:0x21 DW_TAG_subprogram
++; CHECK-NEXT: .b8 100                                 // DW_AT_name
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 165                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x51d:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1406                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x523:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x528:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x52d:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 18                                  // Abbrev [18] 0x533:0x17 DW_TAG_subprogram
++; CHECK-NEXT: .b8 100                                 // DW_AT_name
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 166                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x53e:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1406                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x544:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1411                               // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 19                                  // Abbrev [19] 0x54a:0x33 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 52
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 109
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 32
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 167                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b32 1411                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x576:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 1406                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x57e:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 1249                               // DW_AT_type
++; CHECK-NEXT: .b8 20                                  // Abbrev [20] 0x583:0xe DW_TAG_typedef
++; CHECK-NEXT: .b32 619                                // DW_AT_type
++; CHECK-NEXT: .b8 117                                 // DW_AT_name
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 127                                 // DW_AT_decl_line
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x591:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 1430                               // DW_AT_type
++; CHECK-NEXT: .b8 13                                  // Abbrev [13] 0x596:0x5 DW_TAG_const_type
++; CHECK-NEXT: .b32 697                                // DW_AT_type
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x59b:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 697                                // DW_AT_type
++; CHECK-NEXT: .b8 14                                  // Abbrev [14] 0x5a0:0x5 DW_TAG_reference_type
++; CHECK-NEXT: .b32 1430                               // DW_AT_type
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x5a5:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 697                                // DW_AT_type
++; CHECK-NEXT: .b8 15                                  // Abbrev [15] 0x5aa:0x6 DW_TAG_subprogram
++; CHECK-NEXT: .b32 727                                // DW_AT_specification
++; CHECK-NEXT: .b8 1                                   // DW_AT_inline
++; CHECK-NEXT: .b8 2                                   // Abbrev [2] 0x5b0:0x233 DW_TAG_structure_type
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_byte_size
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 66                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0x5cf:0x50 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 54
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 67                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0x61f:0x50 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 54
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 68                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // Abbrev [3] 0x66f:0x50 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 54
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 49
++; CHECK-NEXT: .b8 55
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 122
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 122
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 69                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 603                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 4                                   // Abbrev [4] 0x6bf:0x4a DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 54
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 32
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 72                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 619                                // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x702:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 2019                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 6                                   // Abbrev [6] 0x709:0x28 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 74                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x72a:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 2029                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 6                                   // Abbrev [6] 0x731:0x2d DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_name
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 74                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x752:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 2029                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x758:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 2034                               // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 8                                   // Abbrev [8] 0x75e:0x44 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 54
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 83
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 82
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 83
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 61
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 74                                  // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x796:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 2019                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x79c:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 2034                               // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 9                                   // Abbrev [9] 0x7a2:0x40 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 78
++; CHECK-NEXT: .b8 75
++; CHECK-NEXT: .b8 50
++; CHECK-NEXT: .b8 54
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 99
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 117
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 104
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 73
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 69
++; CHECK-NEXT: .b8 118
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 111                                 // DW_AT_name
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 38
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 2                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 74                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 2039                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 3                                   // DW_AT_accessibility
++; CHECK-NEXT:                                         // DW_ACCESS_private
++; CHECK-NEXT: .b8 5                                   // Abbrev [5] 0x7db:0x6 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 2019                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_artificial
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x7e3:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 2024                               // DW_AT_type
++; CHECK-NEXT: .b8 13                                  // Abbrev [13] 0x7e8:0x5 DW_TAG_const_type
++; CHECK-NEXT: .b32 1456                               // DW_AT_type
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x7ed:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 1456                               // DW_AT_type
++; CHECK-NEXT: .b8 14                                  // Abbrev [14] 0x7f2:0x5 DW_TAG_reference_type
++; CHECK-NEXT: .b32 2024                               // DW_AT_type
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x7f7:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 1456                               // DW_AT_type
++; CHECK-NEXT: .b8 15                                  // Abbrev [15] 0x7fc:0x6 DW_TAG_subprogram
++; CHECK-NEXT: .b32 1487                               // DW_AT_specification
++; CHECK-NEXT: .b8 1                                   // DW_AT_inline
++; CHECK-NEXT: .b8 21                                  // Abbrev [21] 0x802:0x32 DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 114
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 115
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 80
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 114                                 // DW_AT_name
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 115
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 1                                   // DW_AT_inline
++; CHECK-NEXT: .b8 22                                  // Abbrev [22] 0x816:0x9 DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 120                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_line
++; CHECK-NEXT: .b32 2100                               // DW_AT_type
++; CHECK-NEXT: .b8 22                                  // Abbrev [22] 0x81f:0x9 DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 121                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_line
++; CHECK-NEXT: .b32 2100                               // DW_AT_type
++; CHECK-NEXT: .b8 22                                  // Abbrev [22] 0x828:0xb DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 114                                 // DW_AT_name
++; CHECK-NEXT: .b8 101
++; CHECK-NEXT: .b8 115
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 3                                   // DW_AT_decl_line
++; CHECK-NEXT: .b32 2109                               // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 10                                  // Abbrev [10] 0x834:0x9 DW_TAG_base_type
++; CHECK-NEXT: .b8 102                                 // DW_AT_name
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 4                                   // DW_AT_encoding
++; CHECK-NEXT: .b8 4                                   // DW_AT_byte_size
++; CHECK-NEXT: .b8 12                                  // Abbrev [12] 0x83d:0x5 DW_TAG_pointer_type
++; CHECK-NEXT: .b32 2100                               // DW_AT_type
++; CHECK-NEXT: .b8 23                                  // Abbrev [23] 0x842:0xd5 DW_TAG_subprogram
++; CHECK-NEXT: .b64 $L__func_begin0                    // DW_AT_low_pc
++; CHECK-NEXT: .b64 $L__func_end0                      // DW_AT_high_pc
++; CHECK-NEXT: .b8 1                                   // DW_AT_frame_base
++; CHECK-NEXT: .b8 156
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 53
++; CHECK-NEXT: .b8 115
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 80
++; CHECK-NEXT: .b8 102
++; CHECK-NEXT: .b8 83
++; CHECK-NEXT: .b8 95
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 115                                 // DW_AT_name
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 112
++; CHECK-NEXT: .b8 121
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 5                                   // DW_AT_decl_line
++; CHECK-NEXT: .b8 1                                   // DW_AT_external
++; CHECK-NEXT: .b8 24                                  // Abbrev [24] 0x86d:0x10 DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 2                                   // DW_AT_address_class
++; CHECK-NEXT: .b8 5                                   // DW_AT_location
++; CHECK-NEXT: .b8 144
++; CHECK-NEXT: .b8 178
++; CHECK-NEXT: .b8 228
++; CHECK-NEXT: .b8 149
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b8 110                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 5                                   // DW_AT_decl_line
++; CHECK-NEXT: .b32 2384                               // DW_AT_type
++; CHECK-NEXT: .b8 25                                  // Abbrev [25] 0x87d:0xd DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 $L__debug_loc0                     // DW_AT_location
++; CHECK-NEXT: .b8 97                                  // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 5                                   // DW_AT_decl_line
++; CHECK-NEXT: .b32 2100                               // DW_AT_type
++; CHECK-NEXT: .b8 22                                  // Abbrev [22] 0x88a:0x9 DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 120                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 5                                   // DW_AT_decl_line
++; CHECK-NEXT: .b32 2109                               // DW_AT_type
++; CHECK-NEXT: .b8 22                                  // Abbrev [22] 0x893:0x9 DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 121                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 5                                   // DW_AT_decl_line
++; CHECK-NEXT: .b32 2109                               // DW_AT_type
++; CHECK-NEXT: .b8 26                                  // Abbrev [26] 0x89c:0xd DW_TAG_variable
++; CHECK-NEXT: .b32 $L__debug_loc1                     // DW_AT_location
++; CHECK-NEXT: .b8 105                                 // DW_AT_name
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 1                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 6                                   // DW_AT_decl_line
++; CHECK-NEXT: .b32 2384                               // DW_AT_type
++; CHECK-NEXT: .b8 27                                  // Abbrev [27] 0x8a9:0x18 DW_TAG_inlined_subroutine
++; CHECK-NEXT: .b32 691                                // DW_AT_abstract_origin
++; CHECK-NEXT: .b64 $L__tmp1                           // DW_AT_low_pc
++; CHECK-NEXT: .b64 $L__tmp2                           // DW_AT_high_pc
++; CHECK-NEXT: .b8 1                                   // DW_AT_call_file
++; CHECK-NEXT: .b8 6                                   // DW_AT_call_line
++; CHECK-NEXT: .b8 11                                  // DW_AT_call_column
++; CHECK-NEXT: .b8 27                                  // Abbrev [27] 0x8c1:0x18 DW_TAG_inlined_subroutine
++; CHECK-NEXT: .b32 1450                               // DW_AT_abstract_origin
++; CHECK-NEXT: .b64 $L__tmp2                           // DW_AT_low_pc
++; CHECK-NEXT: .b64 $L__tmp3                           // DW_AT_high_pc
++; CHECK-NEXT: .b8 1                                   // DW_AT_call_file
++; CHECK-NEXT: .b8 6                                   // DW_AT_call_line
++; CHECK-NEXT: .b8 24                                  // DW_AT_call_column
++; CHECK-NEXT: .b8 27                                  // Abbrev [27] 0x8d9:0x18 DW_TAG_inlined_subroutine
++; CHECK-NEXT: .b32 2044                               // DW_AT_abstract_origin
++; CHECK-NEXT: .b64 $L__tmp3                           // DW_AT_low_pc
++; CHECK-NEXT: .b64 $L__tmp4                           // DW_AT_high_pc
++; CHECK-NEXT: .b8 1                                   // DW_AT_call_file
++; CHECK-NEXT: .b8 6                                   // DW_AT_call_line
++; CHECK-NEXT: .b8 37                                  // DW_AT_call_column
++; CHECK-NEXT: .b8 28                                  // Abbrev [28] 0x8f1:0x25 DW_TAG_inlined_subroutine
++; CHECK-NEXT: .b32 2050                               // DW_AT_abstract_origin
++; CHECK-NEXT: .b64 $L__tmp9                           // DW_AT_low_pc
++; CHECK-NEXT: .b64 $L__tmp10                          // DW_AT_high_pc
++; CHECK-NEXT: .b8 1                                   // DW_AT_call_file
++; CHECK-NEXT: .b8 8                                   // DW_AT_call_line
++; CHECK-NEXT: .b8 5                                   // DW_AT_call_column
++; CHECK-NEXT: .b8 29                                  // Abbrev [29] 0x909:0xc DW_TAG_formal_parameter
++; CHECK-NEXT: .b8 2                                   // DW_AT_address_class
++; CHECK-NEXT: .b8 5                                   // DW_AT_location
++; CHECK-NEXT: .b8 144
++; CHECK-NEXT: .b8 179
++; CHECK-NEXT: .b8 204
++; CHECK-NEXT: .b8 149
++; CHECK-NEXT: .b8 1
++; CHECK-NEXT: .b32 2079                               // DW_AT_abstract_origin
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 30                                  // Abbrev [30] 0x917:0xd DW_TAG_namespace
++; CHECK-NEXT: .b8 115                                 // DW_AT_name
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 100
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 31                                  // Abbrev [31] 0x91c:0x7 DW_TAG_imported_declaration
++; CHECK-NEXT: .b8 4                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 202                                 // DW_AT_decl_line
++; CHECK-NEXT: .b32 2340                               // DW_AT_import
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 32                                  // Abbrev [32] 0x924:0x1b DW_TAG_subprogram
++; CHECK-NEXT: .b8 95                                  // DW_AT_MIPS_linkage_name
++; CHECK-NEXT: .b8 90
++; CHECK-NEXT: .b8 76
++; CHECK-NEXT: .b8 51
++; CHECK-NEXT: .b8 97
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 115
++; CHECK-NEXT: .b8 120
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 97                                  // DW_AT_name
++; CHECK-NEXT: .b8 98
++; CHECK-NEXT: .b8 115
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 4                                   // DW_AT_decl_file
++; CHECK-NEXT: .b8 44                                  // DW_AT_decl_line
++; CHECK-NEXT: .b32 2367                               // DW_AT_type
++; CHECK-NEXT: .b8 1                                   // DW_AT_declaration
++; CHECK-NEXT: .b8 7                                   // Abbrev [7] 0x939:0x5 DW_TAG_formal_parameter
++; CHECK-NEXT: .b32 2367                               // DW_AT_type
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: .b8 10                                  // Abbrev [10] 0x93f:0x11 DW_TAG_base_type
++; CHECK-NEXT: .b8 108                                 // DW_AT_name
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 103
++; CHECK-NEXT: .b8 32
++; CHECK-NEXT: .b8 108
++; CHECK-NEXT: .b8 111
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 103
++; CHECK-NEXT: .b8 32
++; CHECK-NEXT: .b8 105
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 5                                   // DW_AT_encoding
++; CHECK-NEXT: .b8 8                                   // DW_AT_byte_size
++; CHECK-NEXT: .b8 10                                  // Abbrev [10] 0x950:0x7 DW_TAG_base_type
++; CHECK-NEXT: .b8 105                                 // DW_AT_name
++; CHECK-NEXT: .b8 110
++; CHECK-NEXT: .b8 116
++; CHECK-NEXT: .b8 0
++; CHECK-NEXT: .b8 5                                   // DW_AT_encoding
++; CHECK-NEXT: .b8 4                                   // DW_AT_byte_size
++; CHECK-NEXT: .b8 0                                   // End Of Children Mark
++; CHECK-NEXT: 	}
++; CHECK-NEXT: 	.section	.debug_macinfo	{	}
+ ; CHECK-NOT: debug_
+ 
+ ; Function Attrs: nounwind readnone
+diff -ruN --strip-trailing-cr a/llvm/test/DebugInfo/X86/dwarf-public-names.ll b/llvm/test/DebugInfo/X86/dwarf-public-names.ll
+--- a/llvm/test/DebugInfo/X86/dwarf-public-names.ll
++++ b/llvm/test/DebugInfo/X86/dwarf-public-names.ll
+@@ -61,7 +61,7 @@
+ 
+ ; Skip the output to the header of the pubnames section.
+ ; LINUX: debug_pubnames
+-; LINUX-NEXT: unit_size =
++; LINUX-NEXT: unit_size = 0x00000128
+ 
+ ; Check for each name in the output.
+ ; LINUX-DAG: "ns"
+diff -ruN --strip-trailing-cr a/llvm/test/DebugInfo/X86/DW_AT_object_pointer.ll b/llvm/test/DebugInfo/X86/DW_AT_object_pointer.ll
+--- a/llvm/test/DebugInfo/X86/DW_AT_object_pointer.ll
++++ b/llvm/test/DebugInfo/X86/DW_AT_object_pointer.ll
+@@ -5,15 +5,7 @@
+ ; CHECK-NOT: ""
+ ; CHECK: DW_TAG
+ ; CHECK: DW_TAG_class_type
+-; CHECK: [[DECL:0x[0-9a-f]+]]: DW_TAG_subprogram
+-; CHECK:                         DW_AT_name {{.*}} "A"
+-; CHECK:                         DW_AT_object_pointer [DW_FORM_ref4] 
+-; CHECK-SAME:                    (cu + 0x{{[0-9a-f]*}} => {[[DECL_PARAM:0x[0-9a-f]*]]})
+-; CHECK: [[DECL_PARAM]]:         DW_TAG_formal_parameter
+-;
+-; CHECK: DW_TAG_subprogram
+-; CHECK:   DW_AT_specification [DW_FORM_ref4] (cu + {{.*}} => {[[DECL]]}
+-; CHECK:   DW_AT_object_pointer [DW_FORM_ref4]     (cu + 0x{{[0-9a-f]*}} => {[[PARAM:0x[0-9a-f]*]]})
++; CHECK: DW_AT_object_pointer [DW_FORM_ref4]     (cu + 0x{{[0-9a-f]*}} => {[[PARAM:0x[0-9a-f]*]]})
+ ; CHECK: [[PARAM]]:     DW_TAG_formal_parameter
+ ; CHECK-NOT: DW_TAG
+ ; CHECK: DW_AT_name [DW_FORM_strp]     ( .debug_str[0x{{[0-9a-f]*}}] = "this")
+diff -ruN --strip-trailing-cr a/llvm/test/tools/llvm-dwarfdump/X86/statistics.ll b/llvm/test/tools/llvm-dwarfdump/X86/statistics.ll
+--- a/llvm/test/tools/llvm-dwarfdump/X86/statistics.ll
++++ b/llvm/test/tools/llvm-dwarfdump/X86/statistics.ll
+@@ -55,8 +55,8 @@
+ ; CHECK:      "#bytes within functions": [[FUNCSIZE:[0-9]+]]
+ ; CHECK:      "#bytes within inlined functions": [[INLINESIZE:[0-9]+]]
+ ; CHECK:      "#bytes in __debug_loc": 35,
+-; CHECK-NEXT: "#bytes in __debug_abbrev": 386,
+-; CHECK-NEXT: "#bytes in __debug_info": 463,
++; CHECK-NEXT: "#bytes in __debug_abbrev": 384,
++; CHECK-NEXT: "#bytes in __debug_info": 459,
+ ; CHECK-NEXT: "#bytes in __debug_str": 231,
+ ; CHECK-NEXT: "#bytes in __apple_names": 348,
+ ; CHECK-NEXT: "#bytes in __apple_objc": 36,
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 99d58b8..42a9b94 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "a06c89387621b0a040e6203e7f1a2d8243f5be33"
-    LLVM_SHA256 = "8c6a02e399182893e3d54a2ff3061c635a17dd8cdea9c8bd5ef7e718256e143c"
+    LLVM_COMMIT = "9534d27e3321a3b9e6e79fe6328445575bf26b7b"
+    LLVM_SHA256 = "de74bd503ecd7527e6e493ecc52aa1b33f6eedc673a9b27d495bd0197b1c24df"
 
     tf_http_archive(
         name = name,
diff --git a/third_party/stablehlo/temporary.patch b/third_party/stablehlo/temporary.patch
index 3404771..90d4d84 100755
--- a/third_party/stablehlo/temporary.patch
+++ b/third_party/stablehlo/temporary.patch
@@ -1,3 +1,15 @@
+diff --ruN a/stablehlo/BUILD.bazel b/stablehlo/BUILD.bazel
+--- stablehlo/BUILD.bazel
++++ stablehlo/BUILD.bazel
+@@ -1547,7 +1547,7 @@
+         ),
+     ],
+     tblgen = "@llvm-project//mlir:mlir-tblgen",
+-    td_file = "stablehlo/dialect/VhloAttrs.td",
++    td_file = "stablehlo/dialect/VhloEnums.td",
+     deps = [
+         ":vhlo_ops_td_files",
+     ],
 diff --ruN a/stablehlo/stablehlo/conversions/tosa/transforms/StablehloLegalizeToTosa.pdll b/stablehlo/stablehlo/conversions/tosa/transforms/StablehloLegalizeToTosa.pdll
 --- stablehlo/stablehlo/conversions/tosa/transforms/StablehloLegalizeToTosa.pdll
 +++ stablehlo/stablehlo/conversions/tosa/transforms/StablehloLegalizeToTosa.pdll
@@ -67,4 +79,4806 @@ diff --ruN a/stablehlo/stablehlo/conversions/tosa/transforms/StablehloLegalizeTo
  Pattern =>
    replace op<stablehlo.or>(input0 : Value<_: Tosa_Tensor>,
                        input1 : Value<_: Tosa_Tensor>)
+diff --ruN a/stablehlo/stablehlo/dialect/AssemblyFormat.cpp b/stablehlo/stablehlo/dialect/AssemblyFormat.cpp
+--- stablehlo/stablehlo/dialect/AssemblyFormat.cpp
++++ stablehlo/stablehlo/dialect/AssemblyFormat.cpp
+@@ -860,6 +860,29 @@
+   return parser.parseSymbolName(target);
+ }
+ 
++void printResultAccuracyAttr(AsmPrinter& odsPrinter, APFloat atol, APFloat rtol,
++                             int64_t ulps, Attribute mode) {
++  odsPrinter << "<";
++  if (!atol.isZero()) {
++    odsPrinter << "atol = ";
++    odsPrinter.printFloat(atol);
++    odsPrinter << ", ";
++  }
++  if (!rtol.isZero()) {
++    odsPrinter << "rtol = ";
++    odsPrinter.printFloat(rtol);
++    odsPrinter << ", ";
++  }
++  if (ulps != 0) {
++    odsPrinter << "ulps = ";
++    odsPrinter << ulps;
++    odsPrinter << ", ";
++  }
++  odsPrinter << "mode = ";
++  odsPrinter.printAttribute(mode);
++  odsPrinter << ">";
++}
++
+ void printTypeExtensions(BoundedAttrInterface attr, DialectAsmPrinter& os) {
+   os << "bounds<";
+   llvm::interleaveComma(attr.getBounds(), os,
+diff --ruN a/stablehlo/stablehlo/dialect/AssemblyFormat.h b/stablehlo/stablehlo/dialect/AssemblyFormat.h
+--- stablehlo/stablehlo/dialect/AssemblyFormat.h
++++ stablehlo/stablehlo/dialect/AssemblyFormat.h
+@@ -378,6 +378,65 @@
+   return success();
+ }
+ 
++// ResultAccuracyAttr - Custom printing and parsing for ResultAccuracyAttr.
++//
++// ResultAccuractAttr ::= `<` OptAtolAccuracy OptRtolAccuracy
++//                            OptUlpAccuracy  ModeAccuracy `>`
++// OptAtolAccuracy ::= `atol` `=` APFloat `, ` | eps
++// OptRtolAccuracy ::= `rtol` `=` APFloat `, ` | eps
++// OptUlpAccuracy  ::= `ulps` `=` int64_t `, ` | eps
++// ModeAccuracy    ::= `mode` `=` ResultAccuracyModeAttr
++void printResultAccuracyAttr(AsmPrinter& odsPrinter, APFloat atol, APFloat rtol,
++                             int64_t ulps, Attribute mode);
++
++template <typename AttrTy, typename ModeTy>
++Attribute parseResultAccuracyAttr(AsmParser& parser, Type type) {
++  APFloat resultAtol = APFloat::getZero(APFloat::IEEEdouble());
++  APFloat resultRtol = APFloat::getZero(APFloat::IEEEdouble());
++  int64_t resultUlps = 0;
++
++  // Parse literal '<'
++  if (parser.parseLess()) return {};
++
++  // OptAtolAccuracy
++  if (succeeded(parser.parseOptionalKeyword("atol"))) {
++    double value;
++    if (parser.parseEqual() || parser.parseFloat(value) || parser.parseComma())
++      return {};
++    resultAtol = APFloat(value);
++  }
++
++  // OptRtolAccuracy
++  if (succeeded(parser.parseOptionalKeyword("rtol"))) {
++    double value;
++    if (parser.parseEqual() || parser.parseFloat(value) || parser.parseComma())
++      return {};
++    resultRtol = APFloat(value);
++  }
++
++  // OptUlpAccuracy
++  if (succeeded(parser.parseOptionalKeyword("ulps"))) {
++    int64_t value;
++    if (parser.parseEqual() || parser.parseInteger(value) ||
++        parser.parseComma())
++      return {};
++    resultUlps = value;
++  }
++
++  // ModeAccuracy
++  ModeTy modeAttr;
++  if (parser.parseKeyword("mode") || parser.parseEqual() ||
++      parser.parseAttribute(modeAttr)) {
++    return {};
++  }
++
++  // Parse literal '>'
++  if (parser.parseGreater()) return {};
++  return parser.getChecked<AttrTy>(
++      parser.getCurrentLocation(), parser.getContext(), resultAtol, resultRtol,
++      resultUlps, modeAttr);
++}
++
+ }  // namespace hlo
+ }  // namespace mlir
+ 
+diff --ruN a/stablehlo/stablehlo/dialect/Base.cpp b/stablehlo/stablehlo/dialect/Base.cpp
+--- stablehlo/stablehlo/dialect/Base.cpp
++++ stablehlo/stablehlo/dialect/Base.cpp
+@@ -780,5 +780,22 @@
+           numScales == rankedType.getDimSize(quantDim));
+ }
+ 
++bool hasSingleBoundedDimension(Type type) {
++  RankedTensorType rankedType = dyn_cast<RankedTensorType>(type);
++  auto boundedAttr =
++      dyn_cast_or_null<BoundedAttrInterface>(rankedType.getEncoding());
++  if (!boundedAttr) return false;
++
++  // Count if bounded attr size is not kDynamic
++  int64_t numBoundedDims = llvm::count_if(
++      boundedAttr.getBounds(),
++      [](int64_t bound) { return !ShapedType::isDynamic(bound); });
++  // Also check that there are only bounded dims and no unbounded dims.
++  int64_t numDynamicDims = llvm::count_if(
++      rankedType.getShape(),
++      [](int64_t bound) { return ShapedType::isDynamic(bound); });
++  return numBoundedDims == 1 && numDynamicDims == 1;
++}
++
+ }  // namespace hlo
+ }  // namespace mlir
+diff --ruN a/stablehlo/stablehlo/dialect/Base.h b/stablehlo/stablehlo/dialect/Base.h
+--- stablehlo/stablehlo/dialect/Base.h
++++ stablehlo/stablehlo/dialect/Base.h
+@@ -101,6 +101,9 @@
+ // mentioned in the StableHLO specification.
+ bool isValidQuantizedDimension(Type type);
+ 
++// Returns true if the given type has a single bounded dimension.
++bool hasSingleBoundedDimension(Type type);
++
+ // TODO(zhouxin) Move type inference related methods to TypeInference.cpp
+ 
+ std::pair<int64_t, int64_t> inferConcatenatedDimAndBound(int64_t leftSize,
+diff --ruN a/stablehlo/stablehlo/dialect/Base.td b/stablehlo/stablehlo/dialect/Base.td
+--- stablehlo/stablehlo/dialect/Base.td
++++ stablehlo/stablehlo/dialect/Base.td
+@@ -29,6 +29,20 @@
+ def I32RankedTensor : RankedTensorOf<[I32]>;
+ 
+ def UI32RankedTensor : RankedTensorOf<[UI32]>;
++
++//===----------------------------------------------------------------------===//
++// HLO type constraints.
++//===----------------------------------------------------------------------===//
++
++// Note: Bounded dynamisms is largely unspecced and this feature needs more
++// thoguht as it is adopted to modern frameworks. The current support is
++// designed to allow existing TF programs to be representable in StableHLO and
++// is subject to change as a formal design for boudned dynamism is developed.
++def HLO_HasSingleBoundedDimensionPred
++  : CPred<"mlir::hlo::hasSingleBoundedDimension($_self)">;
++
++def HLO_HasStaticOrSingleBoundedShapePred
++  : Or<[HasStaticShapePred, HLO_HasSingleBoundedDimensionPred]>;
+ 
+ //===----------------------------------------------------------------------===//
+ // HLO type definitions.
+@@ -267,6 +281,9 @@
+ def HLO_StaticShapeTensorOrPerAxisQuantizedTensor : RankedTensorOf<[HLO_Float, HLO_Pred, HLO_Int, HLO_Complex, HLO_QuantizedInt, HLO_PerAxisQuantizedInt],
+     [IsValidQuantizedDimension, HasStaticShapePred], "statically shaped tensor">;
+ 
++def HLO_StaticShapeTensorPerAxisQuantizedTensorOrBoundedTensor : RankedTensorOf<[HLO_Float, HLO_Pred, HLO_Int, HLO_Complex, HLO_QuantizedInt, HLO_PerAxisQuantizedInt],
++    [IsValidQuantizedDimension, HLO_HasStaticOrSingleBoundedShapePred], "statically shaped or single bounded dimension tensor">;
++
+ def HLO_StaticShapeTensorOrPerAxisQuantizedTensorOrToken : AnyTypeOf<[HLO_StaticShapeTensor, HLO_StaticShapeTensorOrPerAxisQuantizedTensor, HLO_Token]>;
+ 
+ def HLO_StaticShapeIntOrFpTensor : StaticShapeTensorOf<[HLO_Int, HLO_Float]>;
+diff --ruN a/stablehlo/stablehlo/dialect/CMakeLists.txt b/stablehlo/stablehlo/dialect/CMakeLists.txt
+--- stablehlo/stablehlo/dialect/CMakeLists.txt
++++ stablehlo/stablehlo/dialect/CMakeLists.txt
+@@ -190,7 +190,7 @@
+ set(LLVM_TARGET_DEFINITIONS VhloOps.td)
+ mlir_tablegen(VhloAttrs.h.inc -gen-attrdef-decls)
+ mlir_tablegen(VhloAttrs.cpp.inc -gen-attrdef-defs)
+-set(LLVM_TARGET_DEFINITIONS VhloAttrs.td)
++set(LLVM_TARGET_DEFINITIONS VhloEnums.td)
+ mlir_tablegen(VhloAttrInterfaces.h.inc -gen-attr-interface-decls)
+ mlir_tablegen(VhloAttrInterfaces.cpp.inc -gen-attr-interface-defs)
+ set(LLVM_TARGET_DEFINITIONS VhloTypes.td)
+diff --ruN a/stablehlo/stablehlo/dialect/StablehloAttrs.td b/stablehlo/stablehlo/dialect/StablehloAttrs.td
+--- stablehlo/stablehlo/dialect/StablehloAttrs.td
++++ stablehlo/stablehlo/dialect/StablehloAttrs.td
+@@ -19,6 +19,7 @@
+ 
+ include "mlir/IR/OpBase.td"
+ include "mlir/IR/TensorEncoding.td"
++include "stablehlo/dialect/StablehloTypes.td"
+ 
+ def StableHLO_Dims : ArrayRefParameter<"int64_t", "Dimension"> {
+   let parser = "parseDimSizes($_parser)";
+@@ -209,4 +210,18 @@
+   let hasCustomAssemblyFormat = 1;
+ }
+ 
++def StableHLO_ResultAccuracyAttr : AttrDef<StableHLO_Dialect, "ResultAccuracy"> {
++  let mnemonic = "result_accuracy";
++  let summary = "The requested accuracy for transcendental unary ops.";
++  let parameters = (ins
++      "APFloat":$atol,
++      "APFloat":$rtol,
++      "int64_t":$ulps,
++      StableHLO_ResultAccuracyModeAttr:$mode
++  );
++  let hasCustomAssemblyFormat = 1;
++  let genVerifyDecl = 1;
++  let constBuilderCall = "ResultAccuracyAttr::get($_builder.getContext(), APFloat(0.0), APFloat(0.0), 0, ResultAccuracyModeAttr::get($_builder.getContext(), $0))";
++}
++
+ #endif // STABLEHLO_DIALECT_STABLEHLO_ATTRS
+diff --ruN a/stablehlo/stablehlo/dialect/StablehloBytecode.cpp b/stablehlo/stablehlo/dialect/StablehloBytecode.cpp
+--- stablehlo/stablehlo/dialect/StablehloBytecode.cpp
++++ stablehlo/stablehlo/dialect/StablehloBytecode.cpp
+@@ -18,6 +18,7 @@
+ #include <cstdint>
+ #include <memory>
+ 
++#include "llvm/ADT/APFloat.h"
+ #include "llvm/ADT/SmallVector.h"
+ #include "llvm/ADT/StringRef.h"
+ #include "llvm/ADT/TypeSwitch.h"
+@@ -180,6 +181,18 @@
+   ///     allowImpreciseAccumulation : svarint
+   ///   }
+   kDotAlgorithmAttr = 15,
++
++  // ResultAccuracyModeAttr {
++  //   mode: varint (encoded enum)
++  // }
++  kResultAccuracyModeAttr = 16,
++
++  // ResultAccuracyAttr {
++  //   atol: APFloat
++  //   rtol: APFloat
++  //   ulps: svarint
++  // }
++  kResultAccuracyAttr = 17,
+ };
+ 
+ /// This enum contains marker codes used to indicate which type is
+@@ -241,6 +254,10 @@
+   OutputOperandAliasAttr readOutputOperandAliasAttr(
+       DialectBytecodeReader &reader) const;
+   PrecisionAttr readPrecisionAttr(DialectBytecodeReader &reader) const;
++  ResultAccuracyAttr readResultAccuracyAttr(
++      DialectBytecodeReader &reader) const;
++  ResultAccuracyModeAttr readResultAccuracyModeAttr(
++      DialectBytecodeReader &reader) const;
+   RngAlgorithmAttr readRngAlgorithmAttr(DialectBytecodeReader &reader) const;
+   RngDistributionAttr readRngDistributionAttr(
+       DialectBytecodeReader &reader) const;
+@@ -264,6 +281,8 @@
+              DialectBytecodeWriter &writer) const;
+   void write(OutputOperandAliasAttr attr, DialectBytecodeWriter &writer) const;
+   void write(PrecisionAttr attr, DialectBytecodeWriter &writer) const;
++  void write(ResultAccuracyAttr attr, DialectBytecodeWriter &writer) const;
++  void write(ResultAccuracyModeAttr attr, DialectBytecodeWriter &writer) const;
+   void write(RngAlgorithmAttr attr, DialectBytecodeWriter &writer) const;
+   void write(RngDistributionAttr attr, DialectBytecodeWriter &writer) const;
+   void write(ScatterDimensionNumbersAttr attr,
+@@ -327,6 +346,10 @@
+       return readOutputOperandAliasAttr(reader);
+     case stablehlo_encoding::kPrecisionAttr:
+       return readPrecisionAttr(reader);
++    case stablehlo_encoding::kResultAccuracyAttr:
++      return readResultAccuracyAttr(reader);
++    case stablehlo_encoding::kResultAccuracyModeAttr:
++      return readResultAccuracyModeAttr(reader);
+     case stablehlo_encoding::kRngAlgorithmAttr:
+       return readRngAlgorithmAttr(reader);
+     case stablehlo_encoding::kRngDistributionAttr:
+@@ -352,13 +375,13 @@
+       .Case<ChannelHandleAttr, ComparisonDirectionAttr, ComparisonTypeAttr,
+             ConvDimensionNumbersAttr, DotAlgorithmAttr, DotDimensionNumbersAttr,
+             FftTypeAttr, GatherDimensionNumbersAttr, OutputOperandAliasAttr,
+-            PrecisionAttr, RngAlgorithmAttr, RngDistributionAttr,
+-            ScatterDimensionNumbersAttr, TransposeAttr, TypeExtensionsAttr>(
+-          [&](auto attr) {
+-            LOG_WRITE_CALL;
+-            write(attr, writer);
+-            return success();
+-          })
++            PrecisionAttr, ResultAccuracyAttr, ResultAccuracyModeAttr,
++            RngAlgorithmAttr, RngDistributionAttr, ScatterDimensionNumbersAttr,
++            TransposeAttr, TypeExtensionsAttr>([&](auto attr) {
++        LOG_WRITE_CALL;
++        write(attr, writer);
++        return success();
++      })
+       .Default([&](Attribute) {
+         LOG_NOT_IMPLEMENTED;
+         return failure();
+@@ -806,6 +829,55 @@
+   }
+ }
+ 
++//===----------------------------------------------------------------------===//
++// ResultAccuracyModeAttr
++
++ResultAccuracyModeAttr StablehloBytecodeInterface::readResultAccuracyModeAttr(
++    DialectBytecodeReader &reader) const {
++  LOG_READ_CALL;
++  return hlo::bytecode::readEnumAttribute<ResultAccuracyModeAttr>(
++      reader, getContext(),
++      [](uint32_t val) { return symbolizeResultAccuracyMode(val); });
++}
++
++void StablehloBytecodeInterface::write(ResultAccuracyModeAttr attr,
++                                       DialectBytecodeWriter &writer) const {
++  writer.writeVarInt(stablehlo_encoding::kResultAccuracyModeAttr);
++  hlo::bytecode::writeEnumAttribute<ResultAccuracyMode>(attr, writer);
++}
++
++//===----------------------------------------------------------------------===//
++// ResultAccuracyAttr
++
++ResultAccuracyAttr StablehloBytecodeInterface::readResultAccuracyAttr(
++    DialectBytecodeReader &reader) const {
++  LOG_READ_CALL;
++  FailureOr<APFloat> atol;
++  FailureOr<APFloat> rtol;
++  int64_t ulps;
++  ResultAccuracyModeAttr mode;
++  if (failed(atol =
++                 reader.readAPFloatWithKnownSemantics(APFloat::IEEEdouble())) ||
++      failed(rtol =
++                 reader.readAPFloatWithKnownSemantics(APFloat::IEEEdouble())) ||
++      failed(reader.readSignedVarInt(ulps)) ||
++      failed(reader.readAttribute(mode))) {
++    mlir::emitWarning(mlir::UnknownLoc::get(getContext()))
++        << "failed to read APFloat for atol";
++    return ResultAccuracyAttr();
++  }
++  return ResultAccuracyAttr::get(getContext(), *atol, *rtol, ulps, mode);
++}
++
++void StablehloBytecodeInterface::write(ResultAccuracyAttr attr,
++                                       DialectBytecodeWriter &writer) const {
++  writer.writeVarInt(stablehlo_encoding::kResultAccuracyAttr);
++  writer.writeAPFloatWithKnownSemantics(attr.getAtol());
++  writer.writeAPFloatWithKnownSemantics(attr.getRtol());
++  writer.writeSignedVarInt(attr.getUlps());
++  writer.writeAttribute(attr.getMode());
++}
++
+ }  // namespace
+ 
+ void addBytecodeInterface(StablehloDialect *dialect) {
+diff --ruN a/stablehlo/stablehlo/dialect/StablehloEnums.td b/stablehlo/stablehlo/dialect/StablehloEnums.td
+--- stablehlo/stablehlo/dialect/StablehloEnums.td
++++ stablehlo/stablehlo/dialect/StablehloEnums.td
+@@ -45,6 +45,29 @@
+ // TODO(b/129153247) See if it's possible to also validate the size.
+ def StableHLO_PrecisionConfigAttr:
+   TypedArrayAttrBase<StableHLO_PrecisionAttr, "Precision Config attribute">;
++
++//===----------------------------------------------------------------------===//
++// Result Accuracy enum definitions.
++//===----------------------------------------------------------------------===//
++
++def STABLEHLO_RESULT_ACCURACY_DEFAULT : I32EnumAttrCase<"DEFAULT", 0>;
++def STABLEHLO_RESULT_ACCURACY_HIGHEST : I32EnumAttrCase<"HIGHEST", 1>;
++def STABLEHLO_RESULT_ACCURACY_TOLERANCE: I32EnumAttrCase<"TOLERANCE", 2>;
++
++def StableHLO_ResultAccuracyMode : I32EnumAttr<"ResultAccuracyMode",
++    "XLA result accuracy mode.",
++    [
++      STABLEHLO_RESULT_ACCURACY_DEFAULT,
++      STABLEHLO_RESULT_ACCURACY_HIGHEST,
++      STABLEHLO_RESULT_ACCURACY_TOLERANCE
++    ]> {
++  let genSpecializedAttr = 0;
++  let cppNamespace = "::mlir::stablehlo";
++}
++
++def StableHLO_ResultAccuracyModeAttr : EnumAttr<StableHLO_Dialect, StableHLO_ResultAccuracyMode, "result_accuracy_mode"> {
++  let assemblyFormat = "`<` $value `>`";
++}
+ 
+ //===----------------------------------------------------------------------===//
+ // Fast Fourier Transform Type enum definitions.
+diff --ruN a/stablehlo/stablehlo/dialect/StablehloOps.cpp b/stablehlo/stablehlo/dialect/StablehloOps.cpp
+--- stablehlo/stablehlo/dialect/StablehloOps.cpp
++++ stablehlo/stablehlo/dialect/StablehloOps.cpp
+@@ -792,6 +792,29 @@
+       allowImpreciseAccumulation);
+ }
+ 
++// ===----------------------------------------------------------------------===//
++// ExpOp
++//===----------------------------------------------------------------------===//
++
++LogicalResult ResultAccuracyAttr::verify(
++    ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, APFloat atol,
++    APFloat rtol, int64_t ulps, ResultAccuracyModeAttr mode) {
++  return hlo::verifyResultAccuracyAttr(
++      emitError, atol, rtol, ulps,
++      stringifyResultAccuracyMode(mode.getValue()));
++}
++
++LogicalResult ExpOp::verify() {
++  if (auto attr = getResultAccuracyAttr()) {
++    if (failed(ResultAccuracyAttr::verify([&] { return emitError(); },
++                                          attr.getAtol(), attr.getRtol(),
++                                          attr.getUlps(), attr.getMode()))) {
++      return failure();
++    }
++  }
++  return success();
++}
++
+ //===----------------------------------------------------------------------===//
+ // FftOp
+ //===----------------------------------------------------------------------===//
+@@ -3127,6 +3150,20 @@
+       lhsContractingDimensions, rhsContractingDimensions);
+ }
+ 
++// ===----------------------------------------------------------------------===//
++// Custom unary op
++// ===----------------------------------------------------------------------===//
++
++void ResultAccuracyAttr::print(AsmPrinter& odsPrinter) const {
++  hlo::printResultAccuracyAttr(odsPrinter, getAtol(), getRtol(), getUlps(),
++                               getMode());
++}
++
++Attribute ResultAccuracyAttr::parse(AsmParser& parser, Type type) {
++  return hlo::parseResultAccuracyAttr<ResultAccuracyAttr,
++                                      ResultAccuracyModeAttr>(parser, type);
++}
++
+ namespace {
+ enum NonSpatialDim : int64_t {
+   IOBatch = -1,    // Input or output batch dimension
+diff --ruN a/stablehlo/stablehlo/dialect/StablehloOps.td b/stablehlo/stablehlo/dialect/StablehloOps.td
+--- stablehlo/stablehlo/dialect/StablehloOps.td
++++ stablehlo/stablehlo/dialect/StablehloOps.td
+@@ -328,6 +328,23 @@
+     %result = stablehlo.exponential %operand : tensor<2x2xf64>
+     ```
+   }];
++  let arguments = (ins HLO_FpComplexOrQuantizedIntTensor:$operand,
++  DefaultValuedOptionalAttr<StableHLO_ResultAccuracyAttr, "::mlir::stablehlo::ResultAccuracyMode::DEFAULT">:$result_accuracy);
++  let results = (outs HLO_FpComplexOrQuantizedIntTensor:$result);
++  let extraClassDeclaration = commonClassDeclaration # [{
++    LogicalResult reifyReturnTypeShapes(
++        OpBuilder& builder, ValueRange operands,
++        SmallVectorImpl<Value>& reifiedReturnShapes) {
++      return ::mlir::hlo::deriveShapeFromOperand(&builder, getOperation(),
++                                                 operands.front(),
++                                                 &reifiedReturnShapes);
++    }
++  }];
++  let hasVerifier = 1;
++
++  let assemblyFormat = [{
++    $operand attr-dict `:` custom<SameOperandsAndResultType>(type($operand), type($result))
++  }];
+ }
+ 
+ def StableHLO_Expm1Op: StableHLO_UnaryElementwiseOp<"exponential_minus_one",
+@@ -1963,7 +1980,7 @@
+     DenseI64ArrayAttr:$broadcast_dimensions /*broadcast_in_dim_i2*/
+   );
+ 
+-  let results = (outs HLO_StaticShapeTensorOrPerAxisQuantizedTensor);
++  let results = (outs HLO_StaticShapeTensorPerAxisQuantizedTensorOrBoundedTensor);
+ 
+   let hasVerifier = 1;
+ 
+@@ -2715,7 +2732,7 @@
+ 
+   let arguments = (ins HLO_TensorOrPerAxisQuantizedTensor:$operand);
+ 
+-  let results = (outs HLO_StaticShapeTensorOrPerAxisQuantizedTensor);
++  let results = (outs HLO_StaticShapeTensorPerAxisQuantizedTensorOrBoundedTensor);
+   let hasVerifier = 1;
+ 
+   let assemblyFormat = "operands attr-dict `:` functional-type(operands, results)";
+diff --ruN a/stablehlo/stablehlo/dialect/TypeInference.cpp b/stablehlo/stablehlo/dialect/TypeInference.cpp
+--- stablehlo/stablehlo/dialect/TypeInference.cpp
++++ stablehlo/stablehlo/dialect/TypeInference.cpp
+@@ -3724,9 +3724,8 @@
+                                      Value operand,
+                                      ArrayRef<int64_t> broadcastDimensions,
+                                      Value result) {
++  // broadcast_in_dim_c1
+   auto operandType = cast<RankedTensorType>(operand.getType());
+-
+-  // broadcast_in_dim_c1
+   if (failed(verifyQPerTensorScaleAndZeroPointConstraints(location, operandType,
+                                                           result.getType())))
+     return failure();
+@@ -4658,11 +4657,12 @@
+                               Value result) {
+   // If the operand type is dynamically shaped there is nothing to verify.
+   auto operandTy = cast<RankedTensorType>(operand.getType());
+-  if (!operandTy.hasStaticShape()) return success();
++  auto resultTy = cast<RankedTensorType>(result.getType());
++  if (!operandTy.hasStaticShape() || !resultTy.hasStaticShape())
++    return success();
+ 
+   // If the operand type is statically shaped (not required) the number of
+   // elements must match that of the result type.
+-  auto resultTy = cast<RankedTensorType>(result.getType());
+   int64_t numResultElements = resultTy.getNumElements();
+   int64_t numOperandElements = operandTy.getNumElements();
+   if (numResultElements != numOperandElements)
+@@ -5057,5 +5057,30 @@
+   return success();
+ }
+ 
++LogicalResult verifyResultAccuracyCombination(
++    ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, APFloat atol,
++    APFloat rtol, int64_t ulps, StringRef mode) {
++  if (mode == "DEFAULT" || mode == "HIGHEST") {
++    bool all_zero = atol.isZero() && rtol.isZero() && ulps == 0;
++    if (!all_zero) {
++      return emitError()
++             << "Invalid tolerances for ResultAccuracyAttr with mode " << mode
++             << ", must be all zero.";
++    }
++  }
++  return success();
++}
++
++LogicalResult verifyResultAccuracyAttr(
++    ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, APFloat atol,
++    APFloat rtol, int64_t ulps, StringRef mode) {
++  if (atol.isNegative() || rtol.isNegative() || ulps < 0)
++    return emitError() << "Negative tolerance";
++  if (failed(
++          verifyResultAccuracyCombination(emitError, atol, rtol, ulps, mode)))
++    return failure();
++  return success();
++}
++
+ }  // end namespace hlo
+ }  // end namespace mlir
+diff --ruN a/stablehlo/stablehlo/dialect/TypeInference.h b/stablehlo/stablehlo/dialect/TypeInference.h
+--- stablehlo/stablehlo/dialect/TypeInference.h
++++ stablehlo/stablehlo/dialect/TypeInference.h
+@@ -26,6 +26,7 @@
+ #include "mlir/IR/SymbolTable.h"
+ #include "mlir/IR/Types.h"
+ #include "mlir/Interfaces/InferTypeOpInterface.h"
++#include "mlir/Support/LLVM.h"
+ #include "mlir/Support/LogicalResult.h"
+ #include "stablehlo/dialect/Base.h"
+ 
+@@ -596,6 +597,14 @@
+ 
+ LogicalResult verifyWhileOp(std::optional<Location> location,
+                             ValueRange operand, Region& cond, Region& body);
++
++LogicalResult verifyResultAccuracyCombination(
++    ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, APFloat atol,
++    APFloat rtol, int64_t ulps, StringRef mode);
++
++LogicalResult verifyResultAccuracyAttr(
++    ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, APFloat atol,
++    APFloat rtol, int64_t ulps, StringRef mode);
+ }  // end namespace hlo
+ }  // end namespace mlir
+ 
+diff --ruN a/stablehlo/stablehlo/dialect/Version.cpp b/stablehlo/stablehlo/dialect/Version.cpp
+--- stablehlo/stablehlo/dialect/Version.cpp
++++ stablehlo/stablehlo/dialect/Version.cpp
+@@ -75,7 +75,7 @@
+ Version Version::fromCompatibilityRequirement(
+     CompatibilityRequirement requirement) {
+   // Compatibility requirement versions can be updated as needed, as long as the
+-  // version satisifies the requirement.
++  // version satisfies the requirement.
+   // The time frames used are from the date that the release was tagged on, not
+   // merged. The tag date is when the version has been verified and exported to
+   // XLA. See: https://github.com/openxla/stablehlo/tags
+diff --ruN a/stablehlo/stablehlo/dialect/Version.h b/stablehlo/stablehlo/dialect/Version.h
+--- stablehlo/stablehlo/dialect/Version.h
++++ stablehlo/stablehlo/dialect/Version.h
+@@ -38,7 +38,7 @@
+   static FailureOr<Version> fromString(llvm::StringRef versionRef);
+ 
+   /// Return a Version representing the current VHLO dialect version.
+-  static Version getCurrentVersion() { return Version(1, 8, 11); }
++  static Version getCurrentVersion() { return Version(1, 9, 1); }
+ 
+   /// Return a Version representing the minimum supported VHLO dialect version.
+   static Version getMinimumVersion() { return Version(0, 9, 0); }
+diff --ruN a/stablehlo/stablehlo/dialect/VhloAttrs.td b/stablehlo/stablehlo/dialect/VhloAttrs.td
+--- stablehlo/stablehlo/dialect/VhloAttrs.td
++++ stablehlo/stablehlo/dialect/VhloAttrs.td
+@@ -21,18 +21,8 @@
+ include "stablehlo/dialect/VhloBase.td"
+ include "stablehlo/dialect/VhloDialect.td"
+ include "stablehlo/dialect/VhloTypes.td"
+-
+-def VHLO_VersionedAttrInterface : AttrInterface<"VersionedAttrInterface"> {
+-  let cppNamespace = "::mlir::vhlo";
+-  let methods = [
+-    InterfaceMethod<
+-      "Returns the minimum version of the VHLO dialect an attribute is supported in.",
+-      "mlir::vhlo::Version", "getMinVersion">,
+-    InterfaceMethod<
+-      "Returns the maximum version (inclusive) of the VHLO dialect an attribute is supported in.",
+-      "mlir::vhlo::Version", "getMaxVersion">,
+-  ];
+-}
++include "stablehlo/dialect/VhloEnums.td"
++
+ 
+ class VHLO_AttrDef<string name, string minVersion, string maxVersion>
+   : AttrDef<VHLO_Dialect, name, [VHLO_VersionedAttrInterface]> {
+@@ -190,4 +180,27 @@
+   let assemblyFormat = "`<` struct(params) `>`";
+ }
+ 
++
++def VHLO_ResultAccuracyAttrV1 : VHLO_AttrDef<"ResultAccuracyV1", "1.9.0", "current"> {
++  let mnemonic = "result_accuracy_v1";
++  let summary = "The requested accuracy for transcendental unary ops.";
++  let parameters = (ins
++      VHLO_APFloatV1:$atol,
++      VHLO_APFloatV1:$rtol,
++      "int64_t":$ulps,
++      "mlir::Attribute":$mode
++  );
++  let assemblyFormat = "`<` struct(params) `>`";
++  let genVerifyDecl = 1;
++  let extraClassDefinition = [{
++    LogicalResult ResultAccuracyV1Attr::verify(
++        llvm::function_ref<mlir::InFlightDiagnostic ()> errFn,
++        APFloat atol, APFloat rtol, int64_t ulps,
++        mlir::Attribute mode) {
++          if (!isFromVhlo(mode)) return errFn() << "expected VHLO result accuracy mode";
++          return success();
++        }
++  }];
++}
++
+ #endif // STABLEHLO_DIALECT_VHLO_ATTRS
+diff --ruN a/stablehlo/stablehlo/dialect/VhloBytecode.cpp b/stablehlo/stablehlo/dialect/VhloBytecode.cpp
+--- stablehlo/stablehlo/dialect/VhloBytecode.cpp
++++ stablehlo/stablehlo/dialect/VhloBytecode.cpp
+@@ -178,6 +178,18 @@
+   ///     bounds : svarint[]
+   ///   }
+   kTypeExtensionsV1Attr = 18,
++
++  // ResultAccuracyModeV1Attr {
++  //   mode: varint (encoded enum)
++  // }
++  kResultAccuracyModeV1Attr = 19,
++
++  // ResultAccuracyV1Attr {
++  //   atol: APFloat
++  //   rtol: APFloat
++  //   ulps: svarint
++  // }
++  kResultAccuracyV1Attr = 20,
+ };
+ 
+ /// This enum contains marker codes used to indicate which type is
+@@ -433,6 +445,10 @@
+   TypeV1Attr readTypeV1Attr(DialectBytecodeReader &reader) const;
+   TypeExtensionsV1Attr readTypeExtensionsV1Attr(
+       DialectBytecodeReader &reader) const;
++  ResultAccuracyModeV1Attr readResultAccuracyModeV1Attr(
++      DialectBytecodeReader &reader) const;
++  ResultAccuracyV1Attr readResultAccuracyV1Attr(
++      DialectBytecodeReader &reader) const;
+ 
+   // TO ADD ATTRIBUTE: Include a write method for each attribute in VHLO
+   // Ex: void write(SomeAttr attr, DialectBytecodeWriter &writer) const;
+@@ -457,6 +473,9 @@
+   void write(TransposeV1Attr attr, DialectBytecodeWriter &writer) const;
+   void write(TypeV1Attr attr, DialectBytecodeWriter &writer) const;
+   void write(TypeExtensionsV1Attr attr, DialectBytecodeWriter &writer) const;
++  void write(ResultAccuracyModeV1Attr attr,
++             DialectBytecodeWriter &writer) const;
++  void write(ResultAccuracyV1Attr attr, DialectBytecodeWriter &writer) const;
+ 
+   //===--------------------------------------------------------------------===//
+   // Types
+@@ -541,6 +560,10 @@
+       return readTypeV1Attr(reader);
+     case vhlo_encoding::kTypeExtensionsV1Attr:
+       return readTypeExtensionsV1Attr(reader);
++    case vhlo_encoding::kResultAccuracyModeV1Attr:
++      return readResultAccuracyModeV1Attr(reader);
++    case vhlo_encoding::kResultAccuracyV1Attr:
++      return readResultAccuracyV1Attr(reader);
+     default:
+       reader.emitError() << "unknown vhlo attribute code: " << code;
+       return Attribute();
+@@ -558,7 +581,8 @@
+             FftTypeV1Attr, FloatV1Attr, IntegerV1Attr, OutputOperandAliasV1Attr,
+             PrecisionV1Attr, RngAlgorithmV1Attr, RngDistributionV1Attr,
+             StringV1Attr, TensorV1Attr, TransposeV1Attr, TypeV1Attr,
+-            TypeExtensionsV1Attr>([&](auto attr) {
++            TypeExtensionsV1Attr, ResultAccuracyV1Attr,
++            ResultAccuracyModeV1Attr>([&](auto attr) {
+         LOG_WRITE_CALL;
+         write(attr, writer);
+         return success();
+@@ -1450,6 +1474,55 @@
+   writer.writeType(type.getElementType());
+ }
+ 
++//===----------------------------------------------------------------------===//
++// ResultAccuracyModeAttr
++
++ResultAccuracyModeV1Attr VhloBytecodeInterface::readResultAccuracyModeV1Attr(
++    DialectBytecodeReader &reader) const {
++  LOG_READ_CALL;
++  return hlo::bytecode::readEnumAttribute<ResultAccuracyModeV1Attr>(
++      reader, getContext(),
++      [](uint32_t val) { return symbolizeResultAccuracyModeV1(val); });
++}
++
++void VhloBytecodeInterface::write(ResultAccuracyModeV1Attr attr,
++                                  DialectBytecodeWriter &writer) const {
++  writer.writeVarInt(vhlo_encoding::kResultAccuracyModeV1Attr);
++  hlo::bytecode::writeEnumAttribute<ResultAccuracyModeV1>(attr, writer);
++}
++
++//===----------------------------------------------------------------------===//
++// ResultAccuracyAttr
++
++ResultAccuracyV1Attr VhloBytecodeInterface::readResultAccuracyV1Attr(
++    DialectBytecodeReader &reader) const {
++  LOG_READ_CALL;
++  FailureOr<APFloat> atol;
++  FailureOr<APFloat> rtol;
++  int64_t ulps;
++  ResultAccuracyModeV1Attr mode;
++  if (failed(atol =
++                 reader.readAPFloatWithKnownSemantics(APFloat::IEEEdouble())) ||
++      failed(rtol =
++                 reader.readAPFloatWithKnownSemantics(APFloat::IEEEdouble())) ||
++      failed(reader.readSignedVarInt(ulps)) ||
++      failed(reader.readAttribute(mode))) {
++    mlir::emitWarning(mlir::UnknownLoc::get(getContext()))
++        << "failed to read APFloat for atol";
++    return ResultAccuracyV1Attr();
++  }
++  return ResultAccuracyV1Attr::get(getContext(), *atol, *rtol, ulps, mode);
++}
++
++void VhloBytecodeInterface::write(ResultAccuracyV1Attr attr,
++                                  DialectBytecodeWriter &writer) const {
++  writer.writeVarInt(vhlo_encoding::kResultAccuracyV1Attr);
++  writer.writeAPFloatWithKnownSemantics(attr.getAtol());
++  writer.writeAPFloatWithKnownSemantics(attr.getRtol());
++  writer.writeSignedVarInt(attr.getUlps());
++  writer.writeAttribute(attr.getMode());
++}
++
+ }  // namespace
+ 
+ void addBytecodeInterface(VhloDialect *dialect) {
+diff --ruN a/stablehlo/stablehlo/dialect/VhloDialect.td b/stablehlo/stablehlo/dialect/VhloDialect.td
+--- stablehlo/stablehlo/dialect/VhloDialect.td
++++ stablehlo/stablehlo/dialect/VhloDialect.td
+@@ -47,6 +47,7 @@
+       1.6.0: Add DotAlgorithm specificaiton to `dot_general`.
+       1.7.0: Introduce `f8E4M3` and `f8E3M4` types.
+       1.8.0: Introduce `f4E2M1FN`, `f6E2M3FN`, `f6E3M2FN` and `f8E8M0FNU` types.
++      1.9.0: Add `ResultAccuracy` attribute to `exp` op.
+   }];
+ 
+   let useDefaultAttributePrinterParser = 0;
+diff --ruN a/stablehlo/stablehlo/dialect/VhloEnums.td b/stablehlo/stablehlo/dialect/VhloEnums.td
+--- stablehlo/stablehlo/dialect/VhloEnums.td
++++ stablehlo/stablehlo/dialect/VhloEnums.td
+@@ -20,7 +20,20 @@
+ include "mlir/IR/EnumAttr.td"
+ include "mlir/IR/PatternBase.td"
+ include "stablehlo/dialect/VhloBase.td"
+-include "stablehlo/dialect/VhloAttrs.td"
++include "stablehlo/dialect/VhloDialect.td"
++include "mlir/IR/AttrTypeBase.td"
++
++def VHLO_VersionedAttrInterface : AttrInterface<"VersionedAttrInterface"> {
++  let cppNamespace = "::mlir::vhlo";
++  let methods = [
++    InterfaceMethod<
++      "Returns the minimum version of the VHLO dialect an attribute is supported in.",
++      "mlir::vhlo::Version", "getMinVersion">,
++    InterfaceMethod<
++      "Returns the maximum version (inclusive) of the VHLO dialect an attribute is supported in.",
++      "mlir::vhlo::Version", "getMaxVersion">,
++  ];
++}
+ 
+ class VHLO_I32EnumAttr<string name, list<I32EnumAttrCase> cases> :
+     I32EnumAttr<name, name, cases> {
+@@ -198,4 +211,23 @@
+ def VHLO_TransposeAttrV1
+   : VHLO_EnumAttr<VHLO_TransposeV1, "transpose_v1", "0.9.0", "current">;
+ 
++//===----------------------------------------------------------------------===//
++// ResultAccuracyMode
++//===----------------------------------------------------------------------===//
++
++def VHLO_RESULT_V1_ACCURACY_DEFAULT : I32EnumAttrCase<"DEFAULT", 0>;
++def VHLO_RESULT_V1_ACCURACY_HIGHEST : I32EnumAttrCase<"HIGHEST", 1>;
++def VHLO_RESULT_V1_ACCURACY_TOLERANCE: I32EnumAttrCase<"TOLERANCE", 2>;
++
++def VHLO_ResultAccuracyModeV1 : VHLO_I32EnumAttr<"ResultAccuracyModeV1",
++    [
++      VHLO_RESULT_V1_ACCURACY_DEFAULT,
++      VHLO_RESULT_V1_ACCURACY_HIGHEST,
++      VHLO_RESULT_V1_ACCURACY_TOLERANCE
++    ]> {}
++
++def VHLO_ResultAccuracyModeV1Attr
++  : VHLO_EnumAttr<VHLO_ResultAccuracyModeV1, "result_accuracy_mode_v1", "1.9.0", "current">;
++
++
+ #endif // STABLEHLO_DIALECT_VHLO_ENUMS
+diff --ruN a/stablehlo/stablehlo/dialect/VhloOps.cpp b/stablehlo/stablehlo/dialect/VhloOps.cpp
+--- stablehlo/stablehlo/dialect/VhloOps.cpp
++++ stablehlo/stablehlo/dialect/VhloOps.cpp
+@@ -25,7 +25,7 @@
+ #include "llvm/ADT/SmallVectorExtras.h"
+ #include "llvm/ADT/StringExtras.h"
+ #include "llvm/ADT/StringRef.h"
+-#include "llvm/ADT/TypeSwitch.h"
++#include "llvm/ADT/TypeSwitch.h"  // IWYU pragma: keep
+ #include "llvm/Support/Casting.h"
+ #include "mlir/Dialect/Shape/IR/Shape.h"
+ #include "mlir/IR/Attributes.h"
+@@ -40,7 +40,7 @@
+ #include "mlir/Support/LLVM.h"
+ #include "mlir/Support/LogicalResult.h"
+ #include "mlir/Support/TypeID.h"
+-#include "stablehlo/dialect/AssemblyFormat.h"
++#include "stablehlo/dialect/AssemblyFormat.h"  // IWYU pragma: keep
+ #include "stablehlo/dialect/Version.h"
+ #include "stablehlo/dialect/VhloBytecode.h"
+ #include "stablehlo/dialect/VhloTypes.h"
+@@ -184,12 +184,13 @@
+   return success();
+ }
+ 
+-void TensorV1Attr::print(mlir::AsmPrinter& p) const {
+-  p << '<'
+-    << DenseIntOrFPElementsAttr::getFromRawBuffer(
+-           llvm::cast<ShapedType>(convertTypeToBuiltinForPrint(getType())),
+-           getData())
+-    << '>';
++void TensorV1Attr::print(mlir::AsmPrinter& odsPrinter) const {
++  odsPrinter << '<'
++             << DenseIntOrFPElementsAttr::getFromRawBuffer(
++                    llvm::cast<ShapedType>(
++                        convertTypeToBuiltinForPrint(getType())),
++                    getData())
++             << '>';
+ }
+ 
+ // Parse tensor elements using DenseIntOrFPElementsAttr printing.
+diff --ruN a/stablehlo/stablehlo/dialect/VhloOps.td b/stablehlo/stablehlo/dialect/VhloOps.td
+--- stablehlo/stablehlo/dialect/VhloOps.td
++++ stablehlo/stablehlo/dialect/VhloOps.td
+@@ -618,8 +618,15 @@
+   let results = (outs VHLO_AnyType:$result);
+ }
+ 
+-def VHLO_ExpOpV1 : VHLO_Op<"exponential_v1", "0.9.0", "current"> {
+-  let arguments = (ins VHLO_AnyType:$operand);
++def VHLO_ExpOpV1 : VHLO_Op<"exponential_v1", "0.9.0", "1.8.0"> {
++  let arguments = (ins VHLO_AnyType:$operand);
++  let results = (outs VHLO_AnyType:$result);
++}
++
++def VHLO_ExpOpV2 : VHLO_Op<"exponential_v2", "1.9.0", "current"> {
++  let arguments = (ins
++    VHLO_AnyType:$operand,
++    VHLO_AnyAttr:$result_accuracy);
+   let results = (outs VHLO_AnyType:$result);
+ }
+ 
+diff --ruN a/stablehlo/stablehlo/integrations/c/StablehloAttributes.cpp b/stablehlo/stablehlo/integrations/c/StablehloAttributes.cpp
+--- stablehlo/stablehlo/integrations/c/StablehloAttributes.cpp
++++ stablehlo/stablehlo/integrations/c/StablehloAttributes.cpp
+@@ -16,6 +16,7 @@
+ #include <cstdint>
+ #include <optional>
+ 
++#include "llvm/ADT/APFloat.h"
+ #include "llvm/ADT/ArrayRef.h"
+ #include "llvm/Support/Casting.h"
+ #include "llvm/Support/ErrorHandling.h"
+@@ -687,3 +688,69 @@
+   return llvm::cast<mlir::stablehlo::TypeExtensionsAttr>(unwrap(attr))
+       .getBounds()[pos];
+ }
++
++//===----------------------------------------------------------------------===//
++// ResultAccuracyModeAttr
++//===----------------------------------------------------------------------===//
++
++MlirAttribute stablehloResultAccuracyModeAttrGet(MlirContext ctx,
++                                                 MlirStringRef value) {
++  std::optional<mlir::stablehlo::ResultAccuracyMode> accuracyMode =
++      mlir::stablehlo::symbolizeResultAccuracyMode(unwrap(value));
++  if (!accuracyMode) llvm::report_fatal_error("Invalid value.");
++  return wrap(mlir::stablehlo::ResultAccuracyModeAttr::get(
++      unwrap(ctx), accuracyMode.value()));
++}
++
++bool stablehloAttributeIsAResultAccuracyModeAttr(MlirAttribute attr) {
++  return llvm::isa<mlir::stablehlo::ResultAccuracyModeAttr>(unwrap(attr));
++}
++
++MlirStringRef stablehloResultAccuracyModeAttrGetValue(MlirAttribute attr) {
++  return wrap(mlir::stablehlo::stringifyResultAccuracyMode(
++      llvm::cast<mlir::stablehlo::ResultAccuracyModeAttr>(unwrap(attr))
++          .getValue()));
++}
++//===----------------------------------------------------------------------===//
++// ResultAccuracyAttr
++//===----------------------------------------------------------------------===//
++
++MlirAttribute stablehloResultAccuracyAttrGet(MlirContext ctx, double atol,
++                                             double rtol, int64_t ulps,
++                                             MlirStringRef mode) {
++  std::optional<mlir::stablehlo::ResultAccuracyMode> accuracyMode =
++      mlir::stablehlo::symbolizeResultAccuracyMode(unwrap(mode));
++  if (!accuracyMode) llvm::report_fatal_error("Invalid value.");
++  mlir::stablehlo::ResultAccuracyModeAttr modeAttr =
++      mlir::stablehlo::ResultAccuracyModeAttr::get(unwrap(ctx),
++                                                   accuracyMode.value());
++  return wrap(mlir::stablehlo::ResultAccuracyAttr::get(
++      unwrap(ctx), llvm::APFloat(atol), llvm::APFloat(rtol), ulps, modeAttr));
++}
++
++bool stablehloAttributeIsAResultAccuracyAttr(MlirAttribute attr) {
++  return llvm::isa<mlir::stablehlo::ResultAccuracyAttr>(unwrap(attr));
++}
++
++double stablehloResultAccuracyAttrGetAtol(MlirAttribute attr) {
++  llvm::APFloat result =
++      llvm::cast<mlir::stablehlo::ResultAccuracyAttr>(unwrap(attr)).getAtol();
++  return result.convertToDouble();
++}
++
++double stablehloResultAccuracyAttrGetRtol(MlirAttribute attr) {
++  llvm::APFloat result =
++      llvm::cast<mlir::stablehlo::ResultAccuracyAttr>(unwrap(attr)).getRtol();
++  return result.convertToDouble();
++}
++
++int64_t stablehloResultAccuracyAttrGetUlps(MlirAttribute attr) {
++  return llvm::cast<mlir::stablehlo::ResultAccuracyAttr>(unwrap(attr))
++      .getUlps();
++}
++
++MlirAttribute stablehloResultAccuracyAttrGetMode(MlirAttribute attr) {
++  mlir::stablehlo::ResultAccuracyModeAttr modeAttr =
++      llvm::cast<mlir::stablehlo::ResultAccuracyAttr>(unwrap(attr)).getMode();
++  return wrap(modeAttr);
++}
+diff --ruN a/stablehlo/stablehlo/integrations/c/StablehloAttributes.h b/stablehlo/stablehlo/integrations/c/StablehloAttributes.h
+--- stablehlo/stablehlo/integrations/c/StablehloAttributes.h
++++ stablehlo/stablehlo/integrations/c/StablehloAttributes.h
+@@ -13,6 +13,7 @@
+ #ifndef STABLEHLO_INTEGRATIONS_C_STABLEHLO_ATTRIBUTES_H
+ #define STABLEHLO_INTEGRATIONS_C_STABLEHLO_ATTRIBUTES_H
+ 
++#include <stdbool.h>
+ #include <stdint.h>
+ #include <sys/types.h>
+ 
+@@ -376,6 +377,42 @@
+ MLIR_CAPI_EXPORTED int64_t
+ stablehloTypeExtensionsGetBoundsElem(MlirAttribute attr, intptr_t pos);
+ 
++// ===---------------------------------------------------------------------===//
++// ResultAccuracyModeAttr
++//===----------------------------------------------------------------------===//
++
++MLIR_CAPI_EXPORTED MlirAttribute
++stablehloResultAccuracyModeAttrGet(MlirContext ctx, MlirStringRef value);
++
++MLIR_CAPI_EXPORTED bool stablehloAttributeIsAResultAccuracyModeAttr(
++    MlirAttribute attr);
++
++MLIR_CAPI_EXPORTED MlirStringRef
++stablehloResultAccuracyModeAttrGetValue(MlirAttribute attr);
++
++// ===---------------------------------------------------------------------===//
++// ResultAccuracyAttr
++//===----------------------------------------------------------------------===//
++
++MLIR_CAPI_EXPORTED MlirAttribute
++stablehloResultAccuracyAttrGet(MlirContext ctx, double atol, double rtol,
++                               int64_t ulps, MlirStringRef value);
++
++MLIR_CAPI_EXPORTED bool stablehloAttributeIsAResultAccuracyAttr(
++    MlirAttribute attr);
++
++MLIR_CAPI_EXPORTED double stablehloResultAccuracyAttrGetAtol(
++    MlirAttribute attr);
++
++MLIR_CAPI_EXPORTED double stablehloResultAccuracyAttrGetRtol(
++    MlirAttribute attr);
++
++MLIR_CAPI_EXPORTED int64_t
++stablehloResultAccuracyAttrGetUlps(MlirAttribute attr);
++
++MLIR_CAPI_EXPORTED MlirAttribute
++stablehloResultAccuracyAttrGetMode(MlirAttribute attr);
++
+ #ifdef __cplusplus
+ }
+ #endif
+diff --ruN a/stablehlo/stablehlo/integrations/python/StablehloModule.cpp b/stablehlo/stablehlo/integrations/python/StablehloModule.cpp
+--- stablehlo/stablehlo/integrations/python/StablehloModule.cpp
++++ stablehlo/stablehlo/integrations/python/StablehloModule.cpp
+@@ -599,6 +599,50 @@
+                                        stablehloTypeExtensionsGetBoundsElem);
+       });
+ 
++  mlir::python::nanobind_adaptors::mlir_attribute_subclass(
++      m, "ResultAccuracyAttr", stablehloAttributeIsAResultAccuracyAttr)
++      .def_classmethod(
++          "get",
++          [](nb::object cls, double atol, double rtol, int64_t ulps,
++             const std::string &mode, MlirContext ctx) {
++            return cls(stablehloResultAccuracyAttrGet(
++                ctx, atol, rtol, ulps,
++                mlirStringRefCreate(mode.c_str(), mode.size())));
++          },
++          nb::arg("cls"), nb::arg("atol"), nb::arg("rtol"), nb::arg("ulps"),
++          nb::arg("mode"), nb::arg("context") = nb::none(),
++          "Creates a ResultAccuracyAttr with the given values.")
++      .def_property_readonly("atol",
++                             [](MlirAttribute self) {
++                               return stablehloResultAccuracyAttrGetAtol(self);
++                             })
++      .def_property_readonly("rtol",
++                             [](MlirAttribute self) {
++                               return stablehloResultAccuracyAttrGetRtol(self);
++                             })
++      .def_property_readonly("ulps",
++                             [](MlirAttribute self) {
++                               return stablehloResultAccuracyAttrGetUlps(self);
++                             })
++      .def_property_readonly("mode", [](MlirAttribute self) {
++        return toPyString(stablehloResultAccuracyModeAttrGetValue(
++            stablehloResultAccuracyAttrGetMode(self)));
++      });
++
++  mlir::python::nanobind_adaptors::mlir_attribute_subclass(
++      m, "ResultAccuracyModeAttr", stablehloAttributeIsAResultAccuracyModeAttr)
++      .def_classmethod(
++          "get",
++          [](nb::object cls, const std::string &value, MlirContext ctx) {
++            return cls(stablehloResultAccuracyModeAttrGet(
++                ctx, mlirStringRefCreate(value.c_str(), value.size())));
++          },
++          nb::arg("cls"), nb::arg("value"), nb::arg("context") = nb::none(),
++          "Creates a ResultAccuracyModeAttr with the given values.")
++      .def_property_readonly("value", [](MlirAttribute self) {
++        return toPyString(stablehloResultAccuracyModeAttrGetValue(self));
++      });
++
+   //
+   // StableHLO APIs
+   //
+diff --ruN a/stablehlo/stablehlo/integrations/python/tests/stablehlo.py b/stablehlo/stablehlo/integrations/python/tests/stablehlo.py
+--- stablehlo/stablehlo/integrations/python/tests/stablehlo.py
++++ stablehlo/stablehlo/integrations/python/tests/stablehlo.py
+@@ -386,3 +386,23 @@
+     cloned_module = module.operation.clone()
+     pipeline.run(cloned_module.operation)
+     assert str(module) == str(cloned_module)
++
++
++@run
++def test_result_accuracy_attr_default():
++  attr = stablehlo.ResultAccuracyAttr.get(atol=0, rtol=0, ulps=0, mode="DEFAULT")
++  assert attr is not None
++  assert attr.mode == "DEFAULT"
++  assert attr.atol == 0
++  assert attr.rtol == 0
++  assert attr.ulps == 0
++
++@run
++def test_result_accuracy_attr_tolerance():
++  attr = stablehlo.ResultAccuracyAttr.get(atol=1e-5, rtol=1.0,
++                                          ulps=2, mode="TOLERANCE")
++  assert attr is not None
++  assert attr.mode == "TOLERANCE"
++  assert attr.atol == 1e-5
++  assert attr.rtol == 1.0
++  assert attr.ulps == 2
+diff --ruN a/stablehlo/stablehlo/reference/Types.cpp b/stablehlo/stablehlo/reference/Types.cpp
+--- stablehlo/stablehlo/reference/Types.cpp
++++ stablehlo/stablehlo/reference/Types.cpp
+@@ -48,13 +48,12 @@
+ }
+ 
+ bool isSupportedFloatType(Type type) {
+-  return type.isFloat4E2M1FN() || type.isFloat6E2M3FN() ||
+-         type.isFloat6E3M2FN() || type.isFloat8E3M4() ||
+-         type.isFloat8E4M3B11FNUZ() || type.isFloat8E4M3() ||
+-         type.isFloat8E4M3FN() || type.isFloat8E4M3FNUZ() ||
+-         type.isFloat8E5M2() || type.isFloat8E5M2FNUZ() ||
+-         type.isFloat8E8M0FNU() || type.isF16() || type.isBF16() ||
+-         type.isF32() || type.isF64();
++  return llvm::isa<
++      mlir::Float4E2M1FNType, mlir::Float6E2M3FNType, mlir::Float6E3M2FNType,
++      mlir::Float8E3M4Type, mlir::Float8E4M3B11FNUZType, mlir::Float8E4M3Type,
++      mlir::Float8E4M3FNType, mlir::Float8E4M3FNUZType, mlir::Float8E5M2Type,
++      mlir::Float8E5M2FNUZType, mlir::Float8E8M0FNUType, mlir::Float16Type,
++      mlir::BFloat16Type, mlir::Float32Type, mlir::Float64Type>(type);
+ }
+ 
+ bool isSupportedComplexType(Type type) {
+diff --ruN a/stablehlo/stablehlo/tests/ops_stablehlo.mlir b/stablehlo/stablehlo/tests/ops_stablehlo.mlir
+--- stablehlo/stablehlo/tests/ops_stablehlo.mlir
++++ stablehlo/stablehlo/tests/ops_stablehlo.mlir
+@@ -1274,6 +1274,22 @@
+ 
+ // -----
+ 
++// CHECK-LABEL: func @broadcast_in_dim_dynamic_i1
++func.func @broadcast_in_dim_dynamic_i1(%arg0: tensor<?xi32>) -> tensor<1x3xi32> {
++  %0 = stablehlo.broadcast_in_dim %arg0, dims = [1] : (tensor<?xi32>) -> tensor<1x3xi32>
++  return %0 : tensor<1x3xi32>
++}
++
++// -----
++
++func.func @broadcast_in_dim_dynamic_result(%arg0: tensor<3xi32>) -> tensor<?x3xi32> {
++  // expected-error@+1 {{must be statically shaped or single bounded dimension tensor}}
++  %0 = "stablehlo.broadcast_in_dim"(%arg0) {broadcast_dimensions = array<i64: 1>} : (tensor<3xi32>) -> tensor<?x3xi32>
++  func.return %0 : tensor<?x3xi32>
++}
++
++// -----
++
+ // Regression test for b/180052624, where this was improperly marked as an
+ // invalid stablehlo.broadcast_in_dim op.
+ // CHECK-LABEL: func @broadcast_in_dim_dynamic_shaped_operand
+@@ -1775,6 +1791,30 @@
+   // expected-error@+1 {{'precision_config' failed to satisfy constraint}}
+   %0 = "stablehlo.dot"(%arg0, %arg1) {precision_config = ["FOO", #stablehlo<precision HIGHEST>]} : (tensor<2x2xi32>, tensor<2x2xi32>) -> tensor<2x2xi32>
+   func.return %0: tensor<2x2xi32>
++}
++
++// -----
++
++// CHECK-LABEL: func @exponential_result_accuracy
++func.func @exponential_result_accuracy(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.exponential"(%arg0) {result_accuracy = #stablehlo.result_accuracy<atol = 0.0, rtol = 0.0, ulps = 0, mode = #stablehlo.result_accuracy_mode<DEFAULT>>} : (tensor<f32>) -> tensor<f32>
++  func.return %0: tensor<f32>
++}
++
++// -----
++
++// CHECK-LABEL: func @exponential_result_accuracy_tol
++func.func @exponential_result_accuracy_tol(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.exponential"(%arg0) {result_accuracy = #stablehlo.result_accuracy<atol = 1.0, rtol = 0.0, ulps = 4, mode = #stablehlo.result_accuracy_mode<TOLERANCE>>} : (tensor<f32>) -> tensor<f32>
++  func.return %0: tensor<f32>
++}
++
++// -----
++
++func.func @exponential_result_accuracy_tol(%arg0: tensor<f32>) -> tensor<f32> {
++  // expected-error@+1 {{Invalid tolerances for ResultAccuracyAttr with mode HIGHEST, must be all zero.}}
++  %0 = "stablehlo.exponential"(%arg0) {result_accuracy = #stablehlo.result_accuracy<atol = 1.0, rtol = 0.0, ulps = 4, mode = #stablehlo.result_accuracy_mode<HIGHEST>>} : (tensor<f32>) -> tensor<f32>
++  func.return %0: tensor<f32>
+ }
+ 
+ // -----
+diff --ruN a/stablehlo/stablehlo/tests/ops_stablehlo_bounded_dynamism.mlir b/stablehlo/stablehlo/tests/ops_stablehlo_bounded_dynamism.mlir
+--- stablehlo/stablehlo/tests/ops_stablehlo_bounded_dynamism.mlir
++++ stablehlo/stablehlo/tests/ops_stablehlo_bounded_dynamism.mlir
+@@ -0,0 +1,63 @@
++// RUN: stablehlo-opt %s -verify-diagnostics -split-input-file -allow-unregistered-dialect | FileCheck %s
++
++// This file captures some quirks to bounded dynamism in StableHLO that are
++// included to allow StableHLO to repersent existing TF programs.
++
++// CHECK-LABEL: reshape_with_single_bounded_dimension
++func.func @reshape_with_single_bounded_dimension(%arg0: tensor<?x2xf32, #stablehlo.bounds<5, ?>>) -> tensor<2x?xf32, #stablehlo.bounds<?, 5>> {
++  %0 = stablehlo.reshape %arg0 : (tensor<?x2xf32, #stablehlo.bounds<5, ?>>) -> tensor<2x?xf32, #stablehlo.bounds<?, 5>>
++  // CHECK: return {{.*}} #stablehlo.bounds<?, 5>
++  return %0 : tensor<2x?xf32, #stablehlo.bounds<?, 5>>
++}
++
++// -----
++
++// CHECK-LABEL: reshape_scalar_with_single_bounded_dimension
++func.func @reshape_scalar_with_single_bounded_dimension(%arg0: tensor<?xf32, #stablehlo.bounds<5>>) -> tensor<1x?xf32, #stablehlo.bounds<?, 5>> {
++  %0 = stablehlo.reshape %arg0 : (tensor<?xf32, #stablehlo.bounds<5>>) -> tensor<1x?xf32, #stablehlo.bounds<?, 5>>
++  // CHECK: return {{.*}} #stablehlo.bounds<?, 5>
++  return %0 : tensor<1x?xf32, #stablehlo.bounds<?, 5>>
++}
++
++// -----
++
++func.func @reshape_with_multiple_bounded_dimensions(%arg0: tensor<?x?xf32, #stablehlo.bounds<5, 5>>) -> tensor<?x?xf32, #stablehlo.bounds<5, 5>> {
++  // expected-error@+1 {{result #0 must be statically shaped or single bounded dimension tensor}}
++  %0 = stablehlo.reshape %arg0 : (tensor<?x?xf32, #stablehlo.bounds<5, 5>>) -> tensor<?x?xf32, #stablehlo.bounds<5, 5>>
++  return %0 : tensor<?x?xf32, #stablehlo.bounds<5, 5>>
++}
++
++// -----
++
++// CHECK-LABEL: broadcast_in_dim_with_single_bounded_dimension
++func.func @broadcast_in_dim_with_single_bounded_dimension(%arg0: tensor<1x?xf32, #stablehlo.bounds<?, 5>>) -> tensor<2x1x?xf32, #stablehlo.bounds<?, ?, 5>> {
++  %0 = stablehlo.broadcast_in_dim %arg0, dims = [0, 1] : (tensor<1x?xf32, #stablehlo.bounds<?, 5>>) -> tensor<2x1x?xf32, #stablehlo.bounds<?, ?, 5>>
++  // CHECK: return {{.*}} #stablehlo.bounds<?, ?, 5>
++  return %0 : tensor<2x1x?xf32, #stablehlo.bounds<?, ?, 5>>
++}
++
++// -----
++
++func.func @broadcast_in_dim_with_multiple_bounded_dimensions(%arg0: tensor<?x?xf32, #stablehlo.bounds<5, 5>>) -> tensor<2x?x?xf32, #stablehlo.bounds<?, 5, 5>> {
++  // expected-error@+1 {{result #0 must be statically shaped or single bounded dimension tensor}}
++  %0 = stablehlo.broadcast_in_dim %arg0, dims = [0, 1] : (tensor<?x?xf32, #stablehlo.bounds<5, 5>>) -> tensor<2x?x?xf32, #stablehlo.bounds<?, 5, 5>>
++  return %0 : tensor<2x?x?xf32, #stablehlo.bounds<?, 5, 5>>
++}
++
++// -----
++
++// CHECK-LABEL: constant_splat_broadcast
++func.func @constant_splat_broadcast() -> tensor<1x?xf32, #stablehlo.bounds<?, 5>> {
++  %0 = stablehlo.constant dense<1.0> : tensor<f32>
++  %1 = stablehlo.broadcast_in_dim %0, dims = [] : (tensor<f32>) -> tensor<1x?xf32, #stablehlo.bounds<?, 5>>
++  // CHECK: tensor<1x?xf32, #stablehlo.bounds<?, 5>>
++  return %1 : tensor<1x?xf32, #stablehlo.bounds<?, 5>>
++}
++
++// -----
++
++func.func @constant_with_dynamic_shape() -> tensor<1x?xf32, #stablehlo.bounds<?, 5>> {
++  // expected-error@+2 {{elements literal type must have static shape}}
++  %c = stablehlo.constant dense<1> : tensor<1x?xf32, #stablehlo.bounds<?, 5>>
++  return %c : tensor<1x?xf32, #stablehlo.bounds<?, 5>>
++}
+diff --ruN a/stablehlo/stablehlo/tests/ops_stablehlo_roundtrip.mlir b/stablehlo/stablehlo/tests/ops_stablehlo_roundtrip.mlir
+--- stablehlo/stablehlo/tests/ops_stablehlo_roundtrip.mlir
++++ stablehlo/stablehlo/tests/ops_stablehlo_roundtrip.mlir
+@@ -766,6 +766,11 @@
+   func.return %0 : tensor<3x4xf32>
+ }
+ 
++func.func @test_unary_result_accuracy(%arg0: tensor<2xf32>) -> tensor<2xf32> {
++  %exp = "stablehlo.exponential"(%arg0) {result_accuracy = #stablehlo.result_accuracy<atol = 1.000000e+00, rtol = 1.000000e+00, ulps = 5, mode = #stablehlo.result_accuracy_mode<TOLERANCE>>} : (tensor<2xf32>) -> tensor<2xf32>
++  func.return %exp : tensor<2xf32>
++}
++
+ func.func @test_unary_round_nearest_even(%arg0: tensor<2xf32>) -> tensor<2xf32> {
+     %0 = "stablehlo.round_nearest_even"(%arg0) {} : (tensor<2xf32>) -> tensor<2xf32>
+     func.return %0 : tensor<2xf32>
+diff --ruN a/stablehlo/stablehlo/tests/print_stablehlo.mlir b/stablehlo/stablehlo/tests/print_stablehlo.mlir
+--- stablehlo/stablehlo/tests/print_stablehlo.mlir
++++ stablehlo/stablehlo/tests/print_stablehlo.mlir
+@@ -406,3 +406,16 @@
+   %slice6 = stablehlo.slice %arg0 [1:3:1, 4:8:2] : (tensor<3x8xf32>) -> tensor<2x2xf32>
+   return %slice1, %slice2, %slice3, %slice4, %slice5, %slice6 : tensor<1xf32>, tensor<2xf32>, tensor<1xf32>, tensor<1xf32>, tensor<2x2xf32>, tensor<2x2xf32>
+ }
++
++func.func @result_accuracy_default() -> () attributes {
++  // CHECK: mode.default = #stablehlo.result_accuracy<mode = #stablehlo.result_accuracy_mode<DEFAULT>>
++  // CHECK: mode.highest = #stablehlo.result_accuracy<mode = #stablehlo.result_accuracy_mode<HIGHEST>>
++  // CHECK: mode.tolerance_full = #stablehlo.result_accuracy<atol = 1.000000e-05, rtol = 1.000000e-04, ulps = 2, mode = #stablehlo.result_accuracy_mode<TOLERANCE>>
++  // CHECK: mode.tolerance_partial = #stablehlo.result_accuracy<atol = 1.000000e-05, mode = #stablehlo.result_accuracy_mode<TOLERANCE>>
++  mode.default = #stablehlo.result_accuracy<atol = 0.0, rtol = 0.0, ulps = 0, mode = #stablehlo.result_accuracy_mode<DEFAULT>>,
++  mode.highest = #stablehlo.result_accuracy<atol = 0.0, rtol = 0.0, ulps = 0, mode = #stablehlo.result_accuracy_mode<HIGHEST>>,
++  mode.tolerance_full = #stablehlo.result_accuracy<atol = 1.0e-5, rtol = 1.0e-4, ulps = 2, mode = #stablehlo.result_accuracy_mode<TOLERANCE>>,
++  mode.tolerance_partial = #stablehlo.result_accuracy<atol = 1.0e-5, rtol = 0.0, ulps = 0, mode = #stablehlo.result_accuracy_mode<TOLERANCE>>
++} {
++  func.return
++}
+diff --ruN a/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_simplification.mlir b/stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_simplification.mlir
+--- stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_simplification.mlir
++++ stablehlo/stablehlo/tests/transforms/stablehlo_aggressive_simplification.mlir
+@@ -1940,6 +1940,17 @@
+   return %1 : tensor<12xi64>
+ }
+ 
++// -----
++
++// CHECK-LABEL: @reorder_invalid_with_dynamic_shape
++func.func @reorder_invalid_with_dynamic_shape(%arg0: tensor<1x3x4xf32>) -> (tensor<?x4xf32>) {
++  // CHECK:      %[[RESHAPE:.+]] = stablehlo.reshape %arg0 : (tensor<1x3x4xf32>) -> tensor<3x4xf32>
++  // CHECK-NEXT: %[[CONVERT:.+]] = stablehlo.convert %[[RESHAPE]] : (tensor<3x4xf32>) -> tensor<?x4xf32>
++  // CHECK: return %[[CONVERT]]
++  %0 = stablehlo.reshape %arg0 : (tensor<1x3x4xf32>) -> tensor<3x4xf32>
++  %1 = stablehlo.convert %0 : (tensor<3x4xf32>) -> tensor<?x4xf32>
++  return %1 : tensor<?x4xf32>
++}
+ 
+ // -----
+ 
+diff --ruN a/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo.1_9_0.mlir b/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo.1_9_0.mlir
+--- stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo.1_9_0.mlir
++++ stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo.1_9_0.mlir
+@@ -0,0 +1,2966 @@
++// RUN: stablehlo-opt --mlir-print-op-generic %s.bc | FileCheck %s
++// RUN: stablehlo-translate --deserialize %s.bc | stablehlo-translate --serialize --target=1.9.0 | stablehlo-opt --mlir-print-op-generic | FileCheck %s
++// RUN: stablehlo-translate --deserialize %s.bc | stablehlo-opt > %t.0
++// RUN: stablehlo-opt --strip-debuginfo %s > %t.1
++// RUN: diff %t.0 %t.1
++// RUN: stablehlo-translate --serialize --target=1.9.0 --strip-debuginfo %s > %t.2
++// RUN: diff %s.bc %t.2
++// RUN: stablehlo-opt --stablehlo-legalize-to-vhlo -emit-bytecode -debug-only=vhlo-bytecode %s 2>&1 | FileCheck --check-prefix=CHECK-WARN %s
++// RUN: stablehlo-opt --stablehlo-legalize-to-vhlo -emit-bytecode %s | stablehlo-opt -debug-only=vhlo-bytecode 2>&1 | FileCheck --check-prefix=CHECK-WARN %s
++
++// CHECK-WARN-NOT: Not Implemented
++
++// ============ ATTRIBUTES ============
++
++// CHECK-LABEL: "attr_comparison_direction_eq"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_direction_eq(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    // CHECK: comparison_direction = #vhlo<comparison_direction_v1 EQ>
++    comparison_direction = #stablehlo<comparison_direction EQ>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_direction_ne"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_direction_ne(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    // CHECK: comparison_direction = #vhlo<comparison_direction_v1 NE>
++    comparison_direction = #stablehlo<comparison_direction NE>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_direction_ge"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_direction_ge(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    // CHECK: comparison_direction = #vhlo<comparison_direction_v1 GE>
++    comparison_direction = #stablehlo<comparison_direction GE>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_direction_gt"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_direction_gt(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    // CHECK: comparison_direction = #vhlo<comparison_direction_v1 GT>
++    comparison_direction = #stablehlo<comparison_direction GT>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_direction_le"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_direction_le(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    // CHECK: comparison_direction = #vhlo<comparison_direction_v1 LE>
++    comparison_direction = #stablehlo<comparison_direction LE>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_direction_lt"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_direction_lt(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    // CHECK: comparison_direction = #vhlo<comparison_direction_v1 LT>
++    comparison_direction = #stablehlo<comparison_direction LT>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_type_notype"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_type_notype(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    comparison_direction = #stablehlo<comparison_direction EQ>
++    // CHECK: compare_type = #vhlo<comparison_type_v1 NOTYPE>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_type_float"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_type_float(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    comparison_direction = #stablehlo<comparison_direction EQ>,
++    // CHECK: compare_type = #vhlo<comparison_type_v1 FLOAT>,
++    compare_type = #stablehlo<comparison_type FLOAT>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_type_totalorder"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_type_totalorder(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    comparison_direction = #stablehlo<comparison_direction EQ>,
++    // CHECK: compare_type = #vhlo<comparison_type_v1 TOTALORDER>,
++    compare_type = #stablehlo<comparison_type TOTALORDER>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_type_signed"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_type_signed(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    comparison_direction = #stablehlo<comparison_direction EQ>,
++    // CHECK: compare_type = #vhlo<comparison_type_v1 SIGNED>,
++    compare_type = #stablehlo<comparison_type SIGNED>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "attr_comparison_type_unsigned"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_comparison_type_unsigned(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    comparison_direction = #stablehlo<comparison_direction EQ>,
++    // CHECK: compare_type = #vhlo<comparison_type_v1 UNSIGNED>,
++    compare_type = #stablehlo<comparison_type UNSIGNED>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// ConvDimensionNumbers aka #stablehlo.conv is covered below.
++
++// CHECK-LABEL: "attr_custom_call_api_version_unspecified"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_custom_call_api_version_unspecified(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo",
++    // CHECK: api_version = #vhlo<api_version_v1 API_VERSION_UNSPECIFIED>
++    api_version = 0 : i32
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "attr_custom_call_api_version_original"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_custom_call_api_version_original(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo",
++    // CHECK: api_version = #vhlo<api_version_v1 API_VERSION_ORIGINAL>
++    api_version = 1 : i32
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "attr_custom_call_api_version_status_returning"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_custom_call_api_version_status_returning(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo",
++    // CHECK: api_version = #vhlo<api_version_v1 API_VERSION_STATUS_RETURNING>
++    api_version = 2 : i32
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "attr_custom_call_api_version_status_returning_unified"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_custom_call_api_version_status_returning_unified(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo",
++    // CHECK: api_version = #vhlo<api_version_v1 API_VERSION_STATUS_RETURNING_UNIFIED>
++    api_version = 3 : i32
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "attr_dict"
++// CHECK: #vhlo.dict_v1<{#vhlo.string_v1<"attr1"> = #vhlo.integer_v1<1 : i32>, #vhlo.string_v1<"attr2"> = #vhlo.integer_v1<2 : i32>}
++func.func @attr_dict() attributes {stablehlo.attr = {attr1 = 1 : i32, attr2 = 2 : i32}} {
++  return
++}
++
++// CHECK-LABEL: "attr_custom_call_api_version_typed_ffi"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++// CHECK: api_version = #vhlo<api_version_v1 API_VERSION_TYPED_FFI>
++// CHECK-SAME: backend_config = #vhlo.dict_v1<{#vhlo.string_v1<"bar"> = #vhlo.integer_v1<42 : i32>}>
++func.func @attr_custom_call_api_version_typed_ffi(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo",
++    backend_config= {bar = 42 : i32},
++    api_version = 4 : i32
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++
++// CHECK-LABEL: "attr_custom_call_api_version_typed_ffi_no_backend_config"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++// CHECK: api_version = #vhlo<api_version_v1 API_VERSION_TYPED_FFI>
++// CHECK-SAME: backend_config = #vhlo.dict_v1<{}>
++func.func @attr_custom_call_api_version_typed_ffi_no_backend_config(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo",
++    api_version = 4 : i32
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// DotDimensionNumbers aka #stablehlo.dot is covered below.
++
++// CHECK-LABEL: "attr_fft_type_fft"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_fft_type_fft(%arg0: tensor<16xcomplex<f32>>) -> tensor<16xcomplex<f32>> {
++  %0 = "stablehlo.fft"(%arg0) {
++    // CHECK: fft_type = #vhlo<fft_type_v1 FFT>
++    fft_type = #stablehlo<fft_type FFT>,
++    fft_length = array<i64: 16>
++  } : (tensor<16xcomplex<f32>>) -> tensor<16xcomplex<f32>>
++  func.return %0 : tensor<16xcomplex<f32>>
++}
++
++// CHECK-LABEL: "attr_fft_type_ifft"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_fft_type_ifft(%arg0: tensor<16xcomplex<f32>>) -> tensor<16xcomplex<f32>> {
++  %0 = "stablehlo.fft"(%arg0) {
++    // CHECK: fft_type = #vhlo<fft_type_v1 IFFT>
++    fft_type = #stablehlo<fft_type IFFT>,
++    fft_length = array<i64: 16>
++  } : (tensor<16xcomplex<f32>>) -> tensor<16xcomplex<f32>>
++  func.return %0 : tensor<16xcomplex<f32>>
++}
++
++// CHECK-LABEL: "attr_fft_type_rfft"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_fft_type_rfft(%arg0: tensor<16xf32>) -> tensor<9xcomplex<f32>> {
++  %0 = "stablehlo.fft"(%arg0) {
++    // CHECK: fft_type = #vhlo<fft_type_v1 RFFT>
++    fft_type = #stablehlo<fft_type RFFT>,
++    fft_length = array<i64: 16>
++  } : (tensor<16xf32>) -> tensor<9xcomplex<f32>>
++  func.return %0 : tensor<9xcomplex<f32>>
++}
++
++// CHECK-LABEL: "attr_fft_type_irfft"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_fft_type_irfft(%arg0: tensor<9xcomplex<f32>>) -> tensor<16xf32> {
++  %0 = "stablehlo.fft"(%arg0) {
++    // CHECK: fft_type = #vhlo<fft_type_v1 IRFFT>
++    fft_type = #stablehlo<fft_type IRFFT>,
++    fft_length = array<i64: 16>
++  } : (tensor<9xcomplex<f32>>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "attr_result_accuracy_HIGHEST"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}
++func.func @attr_result_accuracy_HIGHEST(%arg0: tensor<8x16xf32>) -> tensor<8x16xf32> {
++  %0 = "stablehlo.exponential"(%arg0) {
++    // CHECK: result_accuracy = #vhlo.result_accuracy_v1<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #vhlo<result_accuracy_mode_v1 HIGHEST>>
++    result_accuracy = #stablehlo.result_accuracy<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #stablehlo.result_accuracy_mode<HIGHEST>>
++  } : (tensor<8x16xf32>) -> tensor<8x16xf32>
++  func.return %0 : tensor<8x16xf32>
++}
++
++// CHECK-LABEL: "attr_result_accuracy_TOLERANCE"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}
++func.func @attr_result_accuracy_TOLERANCE(%arg0: tensor<8x16xf32>) -> tensor<8x16xf32> {
++  %0 = "stablehlo.exponential"(%arg0) {
++    // CHECK: result_accuracy = #vhlo.result_accuracy_v1<atol = 1.000000e-05, rtol = 0.000000e+00, ulps = 1, mode = #vhlo<result_accuracy_mode_v1 TOLERANCE>>
++    result_accuracy = #stablehlo.result_accuracy<atol = 1.000000e-5, rtol = 0.000000e+00, ulps = 1, mode = #stablehlo.result_accuracy_mode<TOLERANCE>>
++  } : (tensor<8x16xf32>) -> tensor<8x16xf32>
++  func.return %0 : tensor<8x16xf32>
++}
++
++// CHECK-LABEL: "attr_result_accuracy_DEFAULT"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}
++func.func @attr_result_accuracy_DEFAULT(%arg0: tensor<8x16xf32>) -> tensor<8x16xf32> {
++  %0 = "stablehlo.exponential"(%arg0) {
++    // CHECK: result_accuracy = #vhlo.result_accuracy_v1<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #vhlo<result_accuracy_mode_v1 DEFAULT>>
++    result_accuracy = #stablehlo.result_accuracy<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #stablehlo.result_accuracy_mode<DEFAULT>>
++  } : (tensor<8x16xf32>) -> tensor<8x16xf32>
++  func.return %0 : tensor<8x16xf32>
++}
++
++// GatherDimensionNumbers aka #stablehlo.gather is covered below.
++
++// CHECK-LABEL: "attr_precision_config_default"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_precision_config_default(%arg0: tensor<8x16xf32>, %arg1: tensor<16x8xf32>) -> tensor<8x8xf32> {
++  %0 = "stablehlo.dot"(%arg0, %arg1) {
++    // CHECK: precision_config = #vhlo.array_v1<[#vhlo<precision_v1 DEFAULT>, #vhlo<precision_v1 DEFAULT>]>
++  } : (tensor<8x16xf32>, tensor<16x8xf32>) -> tensor<8x8xf32>
++  func.return %0 : tensor<8x8xf32>
++}
++
++// CHECK-LABEL: "attr_precision_config_high"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_precision_config_high(%arg0: tensor<8x16xf32>, %arg1: tensor<16x8xf32>) -> tensor<8x8xf32> {
++  %0 = "stablehlo.dot"(%arg0, %arg1) {
++    // CHECK: precision_config = #vhlo.array_v1<[#vhlo<precision_v1 HIGH>, #vhlo<precision_v1 HIGH>]>
++    precision_config = [#stablehlo<precision HIGH>, #stablehlo<precision HIGH>]
++  } : (tensor<8x16xf32>, tensor<16x8xf32>) -> tensor<8x8xf32>
++  func.return %0 : tensor<8x8xf32>
++}
++
++// CHECK-LABEL: "attr_precision_config_highest"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_precision_config_highest(%arg0: tensor<8x16xf32>, %arg1: tensor<16x8xf32>) -> tensor<8x8xf32> {
++  %0 = "stablehlo.dot"(%arg0, %arg1) {
++    // CHECK: precision_config = #vhlo.array_v1<[#vhlo<precision_v1 HIGHEST>, #vhlo<precision_v1 HIGHEST>]>
++    precision_config = [#stablehlo<precision HIGHEST>, #stablehlo<precision HIGHEST>]
++  } : (tensor<8x16xf32>, tensor<16x8xf32>) -> tensor<8x8xf32>
++  func.return %0 : tensor<8x8xf32>
++}
++
++// CHECK-LABEL: "attr_rng_algorithm_default"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_rng_algorithm_default(%arg0: tensor<f32>) -> (tensor<f32>, tensor<f32>) {
++  %0:2 = "stablehlo.rng_bit_generator"(%arg0) {
++    // CHECK: rng_algorithm = #vhlo<rng_algorithm_v1 DEFAULT>
++    rng_algorithm = #stablehlo<rng_algorithm DEFAULT>
++  } : (tensor<f32>) -> (tensor<f32>, tensor<f32>)
++  func.return %0#0, %0#1 : tensor<f32>, tensor<f32>
++}
++
++// CHECK-LABEL: "attr_rng_algorithm_three_fry"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_rng_algorithm_three_fry(%arg0: tensor<f32>) -> (tensor<f32>, tensor<f32>) {
++  %0:2 = "stablehlo.rng_bit_generator"(%arg0) {
++    // CHECK: rng_algorithm = #vhlo<rng_algorithm_v1 THREE_FRY>
++    rng_algorithm = #stablehlo<rng_algorithm THREE_FRY>
++  } : (tensor<f32>) -> (tensor<f32>, tensor<f32>)
++  func.return %0#0, %0#1 : tensor<f32>, tensor<f32>
++}
++
++// CHECK-LABEL: "attr_rng_algorithm_philox"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_rng_algorithm_philox(%arg0: tensor<f32>) -> (tensor<f32>, tensor<f32>) {
++  %0:2 = "stablehlo.rng_bit_generator"(%arg0) {
++    // CHECK: rng_algorithm = #vhlo<rng_algorithm_v1 PHILOX>
++    rng_algorithm = #stablehlo<rng_algorithm PHILOX>
++  } : (tensor<f32>) -> (tensor<f32>, tensor<f32>)
++  func.return %0#0, %0#1 : tensor<f32>, tensor<f32>
++}
++
++// CHECK-LABEL: "attr_rng_distribution_uniform"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @attr_rng_distribution_uniform(%arg0: tensor<f32>, %arg1: tensor<f32>, %arg2: tensor<0xindex>) -> tensor<f32> {
++  %0 = "stablehlo.rng"(%arg0, %arg1, %arg2) {
++    // CHECK: rng_distribution = #vhlo<rng_distribution_v1 UNIFORM>
++    rng_distribution = #stablehlo<rng_distribution UNIFORM>
++  } : (tensor<f32>, tensor<f32>, tensor<0xindex>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "attr_rng_distribution_normal"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @attr_rng_distribution_normal(%arg0: tensor<f32>, %arg1: tensor<f32>, %arg2: tensor<0xindex>) -> tensor<f32> {
++  %0 = "stablehlo.rng"(%arg0, %arg1, %arg2) {
++    // CHECK: rng_distribution = #vhlo<rng_distribution_v1 NORMAL>
++    rng_distribution = #stablehlo<rng_distribution NORMAL>
++  } : (tensor<f32>, tensor<f32>, tensor<0xindex>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// ScatterDimensionNumbers aka #stablehlo.scatter is covered below.
++
++// CHECK-LABEL: "attr_transpose_no_transpose"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_transpose_no_transpose(%arg0: tensor<16x16xf32>, %arg1: tensor<16x16xf32>) ->  tensor<16x16xf32> {
++  %0 = "stablehlo.triangular_solve"(%arg0, %arg1) {
++    left_side = true,
++    lower = true,
++    unit_diagonal = true,
++    // transpose_a = #vhlo<transpose_v1 NO_TRANSPOSE>,
++    transpose_a = #stablehlo<transpose NO_TRANSPOSE>
++  } : (tensor<16x16xf32>, tensor<16x16xf32>) -> tensor<16x16xf32>
++  func.return %0 : tensor<16x16xf32>
++}
++
++// CHECK-LABEL: "attr_transpose_transpose"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_transpose_transpose(%arg0: tensor<16x16xf32>, %arg1: tensor<16x16xf32>) ->  tensor<16x16xf32> {
++  %0 = "stablehlo.triangular_solve"(%arg0, %arg1) {
++    left_side = true,
++    lower = true,
++    unit_diagonal = true,
++    // transpose_a = #vhlo<transpose_v1 TRANSPOSE>,
++    transpose_a = #stablehlo<transpose TRANSPOSE>
++  } : (tensor<16x16xf32>, tensor<16x16xf32>) -> tensor<16x16xf32>
++  func.return %0 : tensor<16x16xf32>
++}
++
++// CHECK-LABEL: "attr_transpose_adjoint"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @attr_transpose_adjoint(%arg0: tensor<16x16xf32>, %arg1: tensor<16x16xf32>) ->  tensor<16x16xf32> {
++  %0 = "stablehlo.triangular_solve"(%arg0, %arg1) {
++    left_side = true,
++    lower = true,
++    unit_diagonal = true,
++    // transpose_a = #vhlo<transpose_v1 ADJOINT>,
++    transpose_a = #stablehlo<transpose ADJOINT>
++  } : (tensor<16x16xf32>, tensor<16x16xf32>) -> tensor<16x16xf32>
++  func.return %0 : tensor<16x16xf32>
++}
++
++// TypeExtensionsAttr aka #stablehlo.type_extensions is covered below.
++
++// CHECK-LABEL: "attr_type_extensions_bounds"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @attr_type_extensions_bounds(%arg0: tensor<?x?xf32, #stablehlo.type_extensions<bounds = [16, ?]>>) -> tensor<?x?xf32, #stablehlo.type_extensions<bounds = [16, ?]>> {
++  // CHECK: "vhlo.return_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<?x?x!vhlo.f32_v1, #vhlo.type_extensions_v1<bounds = [16, ?]>>) -> ()
++  func.return %arg0 : tensor<?x?xf32, #stablehlo.type_extensions<bounds = [16, ?]>>
++}
++
++
++// ============ DEFAULTS ============
++
++// CHECK-LABEL: "default_all_gather"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_all_gather(%arg0: tensor<16x8xf32>) -> tensor<16x16xf32> {
++  //               CHECK: "vhlo.all_gather_v2"(%[[ARG0]]) <{
++  //          CHECK-SAME:   all_gather_dim = #vhlo.integer_v1<1 : i64>
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0], [1]]> : tensor<2x1xi64>>,
++  //          CHECK-SAME:   use_global_device_ids = #vhlo.bool_v1<false>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x16x!vhlo.f32_v1>
++  %0 = "stablehlo.all_gather"(%arg0) {
++    all_gather_dim = 1 : i64,
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>
++  } : (tensor<16x8xf32>) -> tensor<16x16xf32>
++  func.return %0 : tensor<16x16xf32>
++}
++
++// CHECK-LABEL: "default_all_gather_variadic"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_all_gather_variadic(%arg0: tensor<16x8xf32>, %arg1: tensor<16x8xf32>) -> (tensor<16x16xf32>, tensor<16x16xf32>) {
++  %0:2 = "stablehlo.all_gather"(%arg0, %arg1) {
++    all_gather_dim = 1 : i64,
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>
++  } : (tensor<16x8xf32>, tensor<16x8xf32>) -> (tensor<16x16xf32>, tensor<16x16xf32>)
++  func.return %0#0, %0#1 : tensor<16x16xf32>, tensor<16x16xf32>
++}
++
++// CHECK-LABEL: "default_all_reduce"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_all_reduce(%arg0: tensor<f32>) -> tensor<f32> {
++  //               CHECK: "vhlo.all_reduce_v2"(%[[ARG0]])
++  //          CHECK-SAME: <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0], [1]]> : tensor<2x1xi64>>,
++  //          CHECK-SAME:   use_global_device_ids = #vhlo.bool_v1<false>
++  //          CHECK-SAME: }> ({
++  //          CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  //          CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.add_v1"(%[[ARG1]], %[[ARG2]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  //          CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  //          CHECK-NEXT: }) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++
++  %0 = "stablehlo.all_reduce"(%arg0) ({
++    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):
++      %1 = "stablehlo.add"(%arg1, %arg2) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "default_all_to_all"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_all_to_all(%arg0: tensor<4x16xf32>) -> tensor<16x4xf32> {
++  //               CHECK: "vhlo.all_to_all_v2"(%[[ARG0]]) <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  //          CHECK-SAME:   concat_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0, 1, 2, 3]]> : tensor<1x4xi64>>,
++  //          CHECK-SAME:   split_count = #vhlo.integer_v1<4 : i64>
++  //          CHECK-SAME:   split_dimension = #vhlo.integer_v1<1 : i64>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<4x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x4x!vhlo.f32_v1>
++  %0 = "stablehlo.all_to_all"(%arg0) {
++    split_dimension = 1 : i64,
++    concat_dimension = 0 : i64,
++    split_count = 4 : i64,
++    replica_groups = dense<[[0, 1, 2, 3]]> : tensor<1x4xi64>
++  } : (tensor<4x16xf32>) -> tensor<16x4xf32>
++  func.return %0 : tensor<16x4xf32>
++}
++
++// CHECK-LABEL: "default_all_to_all_variadic"
++func.func @default_all_to_all_variadic(%arg0: tensor<4x16xf32>, %arg1: tensor<5x16xf32>) -> (tensor<16x4xf32>, tensor<20x4xf32>) {
++  %0:2 = "stablehlo.all_to_all"(%arg0, %arg1) {
++    split_dimension = 1 : i64,
++    concat_dimension = 0 : i64,
++    split_count = 4 : i64,
++    replica_groups = dense<[[0, 1, 2, 3]]> : tensor<1x4xi64>,
++    channel_handle = #stablehlo.channel_handle<handle = 1, type = 0>
++  } : (tensor<4x16xf32>, tensor<5x16xf32>) -> (tensor<16x4xf32>, tensor<20x4xf32>)
++  func.return %0#0, %0#1 : tensor<16x4xf32>, tensor<20x4xf32>
++}
++
++// CHECK-LABEL: "default_cholesky"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_cholesky(%arg0: tensor<1x16x16xf32>) -> tensor<1x16x16xf32> {
++  //      CHECK: "vhlo.cholesky_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   lower = #vhlo.bool_v1<false>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<1x16x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<1x16x16x!vhlo.f32_v1>
++  %0 = "stablehlo.cholesky"(%arg0) : (tensor<1x16x16xf32>) -> tensor<1x16x16xf32>
++  func.return %0 : tensor<1x16x16xf32>
++}
++
++// CHECK-LABEL: "default_collective_permute"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_collective_permute(%arg0: tensor<16x8xf32>) -> tensor<16x8xf32> {
++  //               CHECK: "vhlo.collective_permute_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME{LITERAL}:   source_target_pairs = #vhlo.tensor_v1<dense<[[0, 1], [1, 2], [2, 3]]> : tensor<3x2xi64>>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x8x!vhlo.f32_v1>
++  %0 = "stablehlo.collective_permute"(%arg0) {
++    source_target_pairs = dense<[[0, 1], [1, 2], [2, 3]]> : tensor<3x2xi64>
++  } : (tensor<16x8xf32>) -> tensor<16x8xf32>
++  func.return %0 : tensor<16x8xf32>
++}
++
++// CHECK-LABEL: "default_collective_broadcast"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_collective_broadcast(%arg0: tensor<16x8xf32>) -> tensor<16x8xf32> {
++  //               CHECK: "vhlo.collective_broadcast_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0, 1]]> : tensor<1x2xi64>>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x8x!vhlo.f32_v1>
++  %0 = "stablehlo.collective_broadcast"(%arg0) {
++    replica_groups = dense<[[0, 1]]> : tensor<1x2xi64>
++  } : (tensor<16x8xf32>) -> tensor<16x8xf32>
++  func.return %0 : tensor<16x8xf32>
++}
++
++// CHECK-LABEL: "default_compare"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @default_compare(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  //      CHECK: "vhlo.compare_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   compare_type = #vhlo<comparison_type_v1 NOTYPE>,
++  // CHECK-SAME:   comparison_direction = #vhlo<comparison_direction_v1 EQ>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    comparison_direction = #stablehlo<comparison_direction EQ>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "default_composite"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_composite(%arg0: tensor<f32>) -> tensor<f32> {
++  //               CHECK: "vhlo.composite_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   composite_attributes = #vhlo.dict_v1<{}>
++  //          CHECK-SAME:   decomposition = #vhlo.string_v1<"composite_target">
++  //          CHECK-SAME:   name = #vhlo.string_v1<"stablehlo.composite_target">
++  //          CHECK-SAME:   version = #vhlo.integer_v1<0 : i64>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.composite"(%arg0) {
++    name = "stablehlo.composite_target",
++    decomposition = @composite_target
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "default_convolution"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @default_convolution(%arg0: tensor<1x8x8x207xf32>, %arg1: tensor<3x3x207x16xf32>) -> tensor<1x6x6x16xf32> {
++  //      CHECK: "vhlo.convolution_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   batch_group_count = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   feature_group_count = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   input_batch_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   input_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   input_spatial_dimensions = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   kernel_input_feature_dimension = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   kernel_output_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   kernel_spatial_dimensions = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   lhs_dilation = #vhlo.tensor_v1<dense<1> : tensor<2xi64>>,
++  // CHECK-SAME:   output_batch_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   output_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   output_spatial_dimensions = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   padding = #vhlo.tensor_v1<dense<0> : tensor<2x2xi64>>,
++  // CHECK-SAME:   precision_config = #vhlo.array_v1<[#vhlo<precision_v1 DEFAULT>, #vhlo<precision_v1 DEFAULT>]>,
++  // CHECK-SAME:   rhs_dilation = #vhlo.tensor_v1<dense<1> : tensor<2xi64>>,
++  // CHECK-SAME:   window_reversal = #vhlo.tensor_v1<dense<false> : tensor<2xi1>>,
++  // CHECK-SAME:   window_strides = #vhlo.tensor_v1<dense<1> : tensor<2xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<1x8x8x207x!vhlo.f32_v1>, !vhlo.tensor_v1<3x3x207x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<1x6x6x16x!vhlo.f32_v1>
++  %0 = "stablehlo.convolution"(%arg0, %arg1) {
++    dimension_numbers = #stablehlo.conv<[b, 0, 1, f]x[0, 1, i, o]->[b, 0, 1, f]>,
++    feature_group_count = 1 : i64,
++    batch_group_count = 1 : i64
++  } : (tensor<1x8x8x207xf32>, tensor<3x3x207x16xf32>) -> tensor<1x6x6x16xf32>
++  func.return %0 : tensor<1x6x6x16xf32>
++}
++
++// CHECK-LABEL: "default_custom_call"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_custom_call(%arg0: tensor<f32>) -> tensor<f32> {
++  //      CHECK: "vhlo.custom_call_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   api_version = #vhlo<api_version_v1 API_VERSION_ORIGINAL>,
++  // CHECK-SAME:   backend_config = #vhlo.string_v1<"">,
++  // CHECK-SAME:   call_target_name = #vhlo.string_v1<"foo">,
++  // CHECK-SAME:   called_computations = #vhlo.array_v1<[]>,
++  // CHECK-SAME:   has_side_effect = #vhlo.bool_v1<false>,
++  // CHECK-SAME:   operand_layouts = #vhlo.array_v1<[]>,
++  // CHECK-SAME:   output_operand_aliases = #vhlo.array_v1<[]>
++  // CHECK-SAME:   result_layouts = #vhlo.array_v1<[]>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo"
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "default_dot_general"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @default_dot_general(%arg0: tensor<8x8x16xf32>, %arg1: tensor<8x16x8xf32>) -> tensor<8x8x8xf32> {
++  //      CHECK: "vhlo.dot_general_v2"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   accumulation_type = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   allow_imprecise_accumulation = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   lhs_batching_dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   lhs_component_count = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   lhs_contracting_dimensions = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++  // CHECK-SAME:   lhs_precision_type = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   num_primitive_operations = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   precision_config = #vhlo.array_v1<[#vhlo<precision_v1 DEFAULT>, #vhlo<precision_v1 DEFAULT>]>,
++  // CHECK-SAME:   rhs_batching_dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   rhs_component_count = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   rhs_contracting_dimensions = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>,
++  // CHECK-SAME:   rhs_precision_type = #vhlo.type_v1<!vhlo.none_v1>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<8x8x16x!vhlo.f32_v1>, !vhlo.tensor_v1<8x16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<8x8x8x!vhlo.f32_v1>
++  %0 = "stablehlo.dot_general"(%arg0, %arg1) {
++    dot_dimension_numbers = #stablehlo.dot<
++      lhs_batching_dimensions = [0],
++      lhs_contracting_dimensions = [2],
++      rhs_batching_dimensions = [0],
++      rhs_contracting_dimensions = [1]
++    >
++  } : (tensor<8x8x16xf32>, tensor<8x16x8xf32>) -> tensor<8x8x8xf32>
++  func.return %0 : tensor<8x8x8xf32>
++}
++
++// CHECK-LABEL: "dot_general_algorithm"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @dot_general_algorithm(%arg0: tensor<8x8x16xf32>, %arg1: tensor<8x16x8xf32>) -> tensor<8x8x8xf32> {
++//      CHECK: "vhlo.dot_general_v2"(%[[ARG0]], %[[ARG1]]) <{
++// CHECK-SAME:   accumulation_type = #vhlo.type_v1<!vhlo.f32_v1>,
++// CHECK-SAME:   allow_imprecise_accumulation = #vhlo.bool_v1<false>,
++// CHECK-SAME:   lhs_batching_dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++// CHECK-SAME:   lhs_component_count = #vhlo.integer_v1<1 : i64>,
++// CHECK-SAME:   lhs_contracting_dimensions = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++// CHECK-SAME:   lhs_precision_type = #vhlo.type_v1<!vhlo.tf31_v1>,
++// CHECK-SAME:   num_primitive_operations = #vhlo.integer_v1<1 : i64>,
++// CHECK-SAME:   precision_config = #vhlo.array_v1<[#vhlo<precision_v1 DEFAULT>, #vhlo<precision_v1 DEFAULT>]>,
++// CHECK-SAME:   rhs_batching_dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++// CHECK-SAME:   rhs_component_count = #vhlo.integer_v1<1 : i64>,
++// CHECK-SAME:   rhs_contracting_dimensions = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>,
++// CHECK-SAME:   rhs_precision_type = #vhlo.type_v1<!vhlo.tf31_v1>
++// CHECK-SAME: }> : (!vhlo.tensor_v1<8x8x16x!vhlo.f32_v1>, !vhlo.tensor_v1<8x16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<8x8x8x!vhlo.f32_v1>
++  %0 = "stablehlo.dot_general"(%arg0, %arg1) {
++    dot_dimension_numbers = #stablehlo.dot<
++      lhs_batching_dimensions = [0],
++      lhs_contracting_dimensions = [2],
++      rhs_batching_dimensions = [0],
++      rhs_contracting_dimensions = [1]
++    >,
++    algorithm = #stablehlo.dot_algorithm<
++      lhs_precision_type = tf32,
++      rhs_precision_type = tf32,
++      accumulation_type = f32,
++      lhs_component_count = 1,
++      rhs_component_count = 1,
++      num_primitive_operations = 1,
++      allow_imprecise_accumulation = false
++    >
++  } : (tensor<8x8x16xf32>, tensor<8x16x8xf32>) -> tensor<8x8x8xf32>
++  func.return %0 : tensor<8x8x8xf32>
++}
++
++// CHECK-LABEL: "default_dynamic_broadcast_in_dim"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @default_dynamic_broadcast_in_dim(%arg0: tensor<?x?xf32>, %arg1: tensor<2xindex>) -> tensor<?x?xf32> {
++  //      CHECK: "vhlo.dynamic_broadcast_in_dim_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   broadcast_dimensions = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   known_expanding_dimensions = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   known_nonexpanding_dimensions = #vhlo.tensor_v1<dense<> : tensor<0xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<?x?x!vhlo.f32_v1>, !vhlo.tensor_v1<2x!vhlo.index_v1>) -> !vhlo.tensor_v1<?x?x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_broadcast_in_dim"(%arg0, %arg1) {
++    broadcast_dimensions = array<i64: 0, 1>
++  } : (tensor<?x?xf32>, tensor<2xindex>) -> tensor<?x?xf32>
++  func.return %0 : tensor<?x?xf32>
++}
++
++// CHECK-LABEL: "default_dynamic_conv"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @default_dynamic_conv(%arg0: tensor<1x8x8x207xf32>, %arg1: tensor<3x3x207x16xf32>, %arg2: tensor<2x2xi64>) -> tensor<1x?x?x16xf32> {
++  //      CHECK: "vhlo.dynamic_conv_v2"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   batch_group_count = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   feature_group_count = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   input_batch_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   input_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   input_spatial_dimensions = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   kernel_input_feature_dimension = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   kernel_output_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   kernel_spatial_dimensions = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   lhs_dilation = #vhlo.tensor_v1<dense<1> : tensor<2xi64>>,
++  // CHECK-SAME:   output_batch_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   output_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   output_spatial_dimensions = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   precision_config = #vhlo.array_v1<[#vhlo<precision_v1 DEFAULT>, #vhlo<precision_v1 DEFAULT>]>,
++  // CHECK-SAME:   rhs_dilation = #vhlo.tensor_v1<dense<1> : tensor<2xi64>>,
++  // CHECK-SAME:   window_reversal = #vhlo.tensor_v1<dense<false> : tensor<2xi1>>,
++  // CHECK-SAME:   window_strides = #vhlo.tensor_v1<dense<1> : tensor<2xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<1x8x8x207x!vhlo.f32_v1>, !vhlo.tensor_v1<3x3x207x16x!vhlo.f32_v1>, !vhlo.tensor_v1<2x2x!vhlo.i64_v1>) -> !vhlo.tensor_v1<1x?x?x16x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_conv"(%arg0, %arg1, %arg2) {
++    dimension_numbers = #stablehlo.conv<[b, 0, 1, f]x[0, 1, i, o]->[b, 0, 1, f]>,
++    feature_group_count = 1 : i64,
++    batch_group_count = 1 : i64
++  } : (tensor<1x8x8x207xf32>, tensor<3x3x207x16xf32>, tensor<2x2xi64>) -> tensor<1x?x?x16xf32>
++  func.return %0 : tensor<1x?x?x16xf32>
++}
++
++// CHECK-LABEL: "default_dynamic_gather"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @default_dynamic_gather(%arg0 : tensor<2x4x9xf32>, %arg1 : tensor<1x5x2xi32>, %arg2 : tensor<3xi32>) -> tensor<1x5x8xf32> {
++  //      CHECK: "vhlo.dynamic_gather_v2"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   collapsed_slice_dims = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<false>,
++  // CHECK-SAME:   offset_dims = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++  // CHECK-SAME:   operand_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   start_index_map = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   start_indices_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<2x4x9x!vhlo.f32_v1>, !vhlo.tensor_v1<1x5x2x!vhlo.i32_v1>, !vhlo.tensor_v1<3x!vhlo.i32_v1>) -> !vhlo.tensor_v1<1x5x8x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_gather"(%arg0, %arg1, %arg2) {
++    dimension_numbers = #stablehlo.gather<
++      offset_dims = [2],
++      collapsed_slice_dims = [0, 1],
++      start_index_map = [0, 1],
++      index_vector_dim = 2
++    >
++  } : (tensor<2x4x9xf32>, tensor<1x5x2xi32>, tensor<3xi32>) -> tensor<1x5x8xf32>
++  func.return %0 : tensor<1x5x8xf32>
++}
++
++func.func @default_func(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK:      "vhlo.func_v1"() <{
++  // CHECK-SAME:   arg_attrs = #vhlo.array_v1<[]>,
++  // CHECK-SAME:   function_type = #vhlo.type_v1<!vhlo.func_v1<(!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>>>,
++  // CHECK-SAME:   res_attrs = #vhlo.array_v1<[]>,
++  // CHECK-SAME:   sym_name = #vhlo.string_v1<"default_func">,
++  // CHECK-SAME:   sym_visibility = #vhlo.string_v1<"">
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG0:.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : () -> ()
++  func.return %arg0 : tensor<f32>
++}
++
++// CHECK-LABEL: "default_gather"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @default_gather(%arg0 : tensor<2x4x9xf32>, %arg1 : tensor<1x5x2xi32>) -> tensor<1x5x1xf32> {
++  //      CHECK: "vhlo.gather_v2"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   collapsed_slice_dims = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<false>,
++  // CHECK-SAME:   offset_dims = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++  // CHECK-SAME:   operand_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   slice_sizes = #vhlo.tensor_v1<dense<1> : tensor<3xi64>>,
++  // CHECK-SAME:   start_index_map = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   start_indices_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<2x4x9x!vhlo.f32_v1>, !vhlo.tensor_v1<1x5x2x!vhlo.i32_v1>) -> !vhlo.tensor_v1<1x5x1x!vhlo.f32_v1>
++  %0 = "stablehlo.gather"(%arg0, %arg1) {
++    dimension_numbers = #stablehlo.gather<
++      offset_dims = [2],
++      collapsed_slice_dims = [0, 1],
++      start_index_map = [0, 1],
++      index_vector_dim = 2
++    >,
++    slice_sizes = array<i64: 1, 1, 1>
++  } : (tensor<2x4x9xf32>, tensor<1x5x2xi32>) -> tensor<1x5x1xf32>
++  func.return %0 : tensor<1x5x1xf32>
++}
++
++// CHECK-LABEL: "default_infeed"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_infeed(%arg0: !stablehlo.token) -> (tensor<f32>, !stablehlo.token) {
++  //               CHECK: "vhlo.infeed_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   infeed_config = #vhlo.string_v1<"">,
++  // CHECK-SAME{LITERAL}:   layout = #vhlo.array_v1<[]>
++  //          CHECK-SAME: }> : (!vhlo.token_v1) -> (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.token_v1)
++  %0:2 = "stablehlo.infeed"(%arg0) : (!stablehlo.token) -> (tensor<f32>, !stablehlo.token)
++  func.return %0#0, %0#1 : tensor<f32>, !stablehlo.token
++}
++
++// CHECK-LABEL: "default_outfeed"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @default_outfeed(%arg0: tensor<f32>, %arg1: !stablehlo.token) -> !stablehlo.token {
++  //      CHECK: "vhlo.outfeed_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   outfeed_config = #vhlo.string_v1<"">
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.token_v1) -> !vhlo.token_v1
++  %0 = "stablehlo.outfeed"(%arg0, %arg1) : (tensor<f32>, !stablehlo.token) -> !stablehlo.token
++  func.return %0 : !stablehlo.token
++}
++
++// CHECK-LABEL: "default_recv"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_recv(%arg0: !stablehlo.token) -> (tensor<f32>, !stablehlo.token) {
++  //      CHECK: "vhlo.recv_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   channel_type = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   is_host_transfer = #vhlo.bool_v1<false>
++  // CHECK-SAME: }> : (!vhlo.token_v1) -> (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.token_v1)
++  %0:2 = "stablehlo.recv"(%arg0) {
++    channel_handle = #stablehlo.channel_handle<handle = 0, type = 1>
++  } : (!stablehlo.token) -> (tensor<f32>, !stablehlo.token)
++  func.return %0#0, %0#1 : tensor<f32>, !stablehlo.token
++}
++
++// CHECK-LABEL: "default_send"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @default_send(%arg0: tensor<f32>, %arg1: !stablehlo.token) -> !stablehlo.token {
++  //      CHECK: "vhlo.send_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   channel_type = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   is_host_transfer = #vhlo.bool_v1<false>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.token_v1) -> !vhlo.token_v1
++  %0 = "stablehlo.send"(%arg0, %arg1) {
++    channel_handle = #stablehlo.channel_handle<handle = 0, type = 1>
++  } : (tensor<f32>, !stablehlo.token) -> !stablehlo.token
++  func.return %0 : !stablehlo.token
++}
++
++// CHECK-LABEL: "default_reduce_scatter"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_reduce_scatter(%arg0: tensor<16xf32>) -> tensor<16xf32> {
++  //               CHECK: "vhlo.reduce_scatter_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0], [1]]> : tensor<2x1xi64>>,
++  //          CHECK-SAME:   scatter_dimension = #vhlo.integer_v1<0 : i64>
++  //          CHECK-SAME:   use_global_device_ids = #vhlo.bool_v1<false>
++  //          CHECK-SAME: }> ({
++  //          CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  //          CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.add_v1"(%[[ARG1]], %[[ARG2]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  //          CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  //          CHECK-NEXT: }) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.reduce_scatter"(%arg0) ({
++    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):
++      %1 = "stablehlo.add"(%arg1, %arg2) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    scatter_dimension = 0 : i64,
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>
++  } : (tensor<16xf32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "default_reduce_window"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @default_reduce_window(%arg0: tensor<2x17x31x7xf32>, %arg1: tensor<f32>) -> tensor<2x16x30x7xf32> {
++  //               CHECK: "vhlo.reduce_window_v1"(%[[ARG0]], %[[ARG1]])  <{
++  //          CHECK-SAME:   base_dilations = #vhlo.tensor_v1<dense<1> : tensor<4xi64>>,
++  // CHECK-SAME{LITERAL}:   padding = #vhlo.tensor_v1<dense<0> : tensor<4x2xi64>>,
++  //          CHECK-SAME:   window_dilations = #vhlo.tensor_v1<dense<1> : tensor<4xi64>>,
++  //          CHECK-SAME:   window_dimensions = #vhlo.tensor_v1<dense<[1, 2, 2, 1]> : tensor<4xi64>>,
++  //          CHECK-SAME:   window_strides = #vhlo.tensor_v1<dense<1> : tensor<4xi64>>
++  //          CHECK-SAME: }> ({
++  //          CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG3:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  //          CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.maximum_v1"(%[[ARG2]], %[[ARG3]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  //          CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  //          CHECK-NEXT: }) : (!vhlo.tensor_v1<2x17x31x7x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<2x16x30x7x!vhlo.f32_v1>
++  %0 = "stablehlo.reduce_window"(%arg0, %arg1) ({
++    ^bb0(%arg2: tensor<f32>, %arg3: tensor<f32>):
++      %1 = "stablehlo.maximum"(%arg2, %arg3) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    window_dimensions = array<i64: 1, 2, 2, 1>
++  } : (tensor<2x17x31x7xf32>, tensor<f32>) -> tensor<2x16x30x7xf32>
++  func.return %0 : tensor<2x16x30x7xf32>
++}
++
++// CHECK-LABEL: "default_scatter"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @default_scatter(%arg0: tensor<200x100x300xf32>, %arg1: tensor<10x2xi32>, %arg2: tensor<10x300xf32>) -> tensor<200x100x300xf32> {
++  //      CHECK: "vhlo.scatter_v2"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<false>,
++  // CHECK-SAME:   input_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   inserted_window_dims = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   scatter_dims_to_operand_dims = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   scatter_indices_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   unique_indices = #vhlo.bool_v1<false>,
++  // CHECK-SAME:   update_window_dims = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG3:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG4:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.add_v1"(%[[ARG3]], %[[ARG4]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<200x100x300x!vhlo.f32_v1>, !vhlo.tensor_v1<10x2x!vhlo.i32_v1>, !vhlo.tensor_v1<10x300x!vhlo.f32_v1>) -> !vhlo.tensor_v1<200x100x300x!vhlo.f32_v1>
++  %0 = "stablehlo.scatter"(%arg0, %arg1, %arg2) ({
++    ^bb0(%arg3: tensor<f32>, %arg4: tensor<f32>):
++      %1 = "stablehlo.add"(%arg3, %arg4) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    scatter_dimension_numbers = #stablehlo.scatter<
++      update_window_dims = [1],
++      inserted_window_dims = [0, 1],
++      scatter_dims_to_operand_dims = [0, 1],
++      index_vector_dim = 1
++    >
++  } : (tensor<200x100x300xf32>, tensor<10x2xi32>, tensor<10x300xf32>) -> tensor<200x100x300xf32>
++  func.return %0 : tensor<200x100x300xf32>
++}
++
++// CHECK-LABEL: "default_select_and_scatter"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @default_select_and_scatter(%arg0: tensor<10x24x24x64xf32>, %arg1: tensor<10x23x23x64xf32>, %arg2: tensor<f32>) -> tensor<10x24x24x64xf32> {
++  //      CHECK: "vhlo.select_and_scatter_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   padding = #vhlo.tensor_v1<dense<0> : tensor<4x2xi64>>,
++  // CHECK-SAME:   window_dimensions = #vhlo.tensor_v1<dense<[1, 2, 2, 1]> : tensor<4xi64>>,
++  // CHECK-SAME:   window_strides = #vhlo.tensor_v1<dense<1> : tensor<4xi64>>
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG31:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG41:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL11:.*]] = "vhlo.compare_v1"(%[[ARG31]], %[[ARG41]]) <{compare_type = #vhlo<comparison_type_v1 TOTALORDER>, comparison_direction = #vhlo<comparison_direction_v1 GE>}>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL11]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> ()
++  // CHECK-NEXT: }, {
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG32:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG42:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL12:.*]] = "vhlo.add_v1"(%[[ARG32]], %[[ARG42]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL12]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<10x24x24x64x!vhlo.f32_v1>, !vhlo.tensor_v1<10x23x23x64x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<10x24x24x64x!vhlo.f32_v1>
++  %0 = "stablehlo.select_and_scatter"(%arg0, %arg1, %arg2) ({
++    ^bb0(%arg3: tensor<f32>, %arg4: tensor<f32>):
++      %1 = "stablehlo.compare"(%arg3, %arg4) {compare_type = #stablehlo<comparison_type TOTALORDER>, comparison_direction = #stablehlo<comparison_direction GE>} : (tensor<f32>, tensor<f32>) -> tensor<i1>
++      "stablehlo.return"(%1) : (tensor<i1>) -> ()
++  }, {
++    ^bb0(%arg3: tensor<f32>, %arg4: tensor<f32>):
++      %1 = "stablehlo.add"(%arg3, %arg4) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    window_dimensions = array<i64: 1, 2, 2, 1>
++  } : (tensor<10x24x24x64xf32>, tensor<10x23x23x64xf32>, tensor<f32>) -> tensor<10x24x24x64xf32>
++  func.return %0 : tensor<10x24x24x64xf32>
++}
++
++// CHECK-LABEL: "default_sort"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @default_sort(%arg0: tensor<16xf32>) -> tensor<16xf32> {
++  //      CHECK: "vhlo.sort_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   dimension = #vhlo.integer_v1<-1 : i64>
++  // CHECK-SAME:   is_stable = #vhlo.bool_v1<false>
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.compare_v1"(%[[ARG1]], %[[ARG2]]) <{compare_type = #vhlo<comparison_type_v1 FLOAT>, comparison_direction = #vhlo<comparison_direction_v1 GT>}>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.sort"(%arg0) ({
++    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):
++      %1 = "stablehlo.compare"(%arg1, %arg2) {compare_type = #stablehlo<comparison_type FLOAT>, comparison_direction = #stablehlo<comparison_direction GT>} : (tensor<f32>, tensor<f32>) -> tensor<i1>
++      "stablehlo.return"(%1) : (tensor<i1>) -> ()
++  }) : (tensor<16xf32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// ============ OPS ============
++
++// CHECK-LABEL: "op_abs"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_abs(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.abs_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.abs"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_add"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_add(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_after_all"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_after_all(%arg0: !stablehlo.token) -> !stablehlo.token {
++  // CHECK: "vhlo.after_all_v1"(%[[ARG0]]) : (!vhlo.token_v1) -> !vhlo.token_v1
++  %0 = "stablehlo.after_all"(%arg0) : (!stablehlo.token) -> !stablehlo.token
++  func.return %0 : !stablehlo.token
++}
++
++// CHECK-LABEL: "op_all_gather"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_all_gather(%arg0: tensor<16x8xf32>) -> tensor<16x16xf32> {
++  //               CHECK: "vhlo.all_gather_v2"(%[[ARG0]]) <{
++  //          CHECK-SAME:   all_gather_dim = #vhlo.integer_v1<1 : i64>
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0], [1]]> : tensor<2x1xi64>>,
++  //          CHECK-SAME:   use_global_device_ids = #vhlo.bool_v1<true>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x16x!vhlo.f32_v1>
++  %0 = "stablehlo.all_gather"(%arg0) {
++    all_gather_dim = 1 : i64,
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>,
++    channel_handle = #stablehlo.channel_handle<handle = 1, type = 0>,
++    use_global_device_ids
++  } : (tensor<16x8xf32>) -> tensor<16x16xf32>
++  func.return %0 : tensor<16x16xf32>
++}
++
++// CHECK-LABEL: "op_all_reduce"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_all_reduce(%arg0: tensor<f32>) -> tensor<f32> {
++  //               CHECK: "vhlo.all_reduce_v2"(%[[ARG0]]) <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0], [1]]> : tensor<2x1xi64>>,
++  //          CHECK-SAME:   use_global_device_ids = #vhlo.bool_v1<true>
++  //          CHECK-SAME: }> ({
++  //          CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  //          CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.add_v1"(%[[ARG1]], %[[ARG2]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  //          CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  //          CHECK-NEXT: }) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.all_reduce"(%arg0) ({
++    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):
++      %1 = "stablehlo.add"(%arg1, %arg2) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>,
++    channel_handle = #stablehlo.channel_handle<handle = 1, type = 0>,
++    use_global_device_ids
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_all_reduce_with_promotable_types"
++func.func @op_all_reduce_with_promotable_types(%operand: tensor<f32>) -> tensor<f64> {
++  //  CHECK: "vhlo.all_reduce_v2"(%[[ARG0:.*]])
++  //  CHECK:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>):
++  //  CHECK:     "vhlo.return_v1"(%[[VAL1:.*]]) : (!vhlo.tensor_v1<!vhlo.f64_v1>) -> ()
++  //  CHECK: }) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f64_v1>
++  %result = "stablehlo.all_reduce"(%operand) ({
++    ^bb0(%arg0: tensor<f64>, %arg1: tensor<f64>):
++      %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f64>, tensor<f64>) -> tensor<f64>
++      "stablehlo.return"(%0) : (tensor<f64>) -> ()
++  }) {
++    replica_groups = dense<[[0, 1]]> : tensor<1x2xi64>,
++    channel_handle = #stablehlo.channel_handle<handle = 1, type = 0>,
++    use_global_device_ids
++  } : (tensor<f32>) -> tensor<f64>
++
++  func.return %result : tensor<f64>
++}
++
++// CHECK-LABEL: "default_all_reduce_variadic"
++func.func @default_all_reduce_variadic(%arg0: tensor<f32>, %arg1: tensor<f32>) -> (tensor<f32>, tensor<f32>) {
++  %0:2 = "stablehlo.all_reduce"(%arg0, %arg1) ({
++    ^bb0(%arg2: tensor<f32>, %arg3: tensor<f32>):
++      %1 = "stablehlo.add"(%arg2, %arg3) : (tensor<f32>, tensor<f32>) -> (tensor<f32>)
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>
++  } : (tensor<f32>, tensor<f32>) -> (tensor<f32>, tensor<f32>)
++  func.return %0#0, %0#1 : tensor<f32>, tensor<f32>
++}
++
++// CHECK-LABEL: "op_all_to_all"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_all_to_all(%arg0: tensor<4x16xf32>) -> tensor<16x4xf32> {
++  //               CHECK: "vhlo.all_to_all_v2"(%[[ARG0]]) <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<1 : i64>,
++  //          CHECK-SAME:   concat_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0, 1, 2, 3]]> : tensor<1x4xi64>>,
++  //          CHECK-SAME:   split_count = #vhlo.integer_v1<4 : i64>
++  //          CHECK-SAME:   split_dimension = #vhlo.integer_v1<1 : i64>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<4x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x4x!vhlo.f32_v1>
++  %0 = "stablehlo.all_to_all"(%arg0) {
++    split_dimension = 1 : i64,
++    concat_dimension = 0 : i64,
++    split_count = 4 : i64,
++    replica_groups = dense<[[0, 1, 2, 3]]> : tensor<1x4xi64>,
++    channel_handle = #stablehlo.channel_handle<handle = 1, type = 0>
++  } : (tensor<4x16xf32>) -> tensor<16x4xf32>
++  func.return %0 : tensor<16x4xf32>
++}
++
++// CHECK-LABEL: "op_and"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_and(%arg0: tensor<i1>, %arg1: tensor<i1>) -> tensor<i1> {
++  // CHECK: "vhlo.and_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>, !vhlo.tensor_v1<!vhlo.bool_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.and"(%arg0, %arg1) : (tensor<i1>, tensor<i1>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "op_atan2"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_atan2(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.atan2_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.atan2"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_batch_norm_grad"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}}, %[[ARG3:.*]]: {{.*}}, %[[ARG4:.*]]: {{.*}})
++func.func @op_batch_norm_grad(%arg0: tensor<16x16x16x16xf32>, %arg1: tensor<16xf32>, %arg2: tensor<16xf32>, %arg3: tensor<16xf32>, %arg4: tensor<16x16x16x16xf32>) -> (tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>) {
++  //      CHECK: "vhlo.batch_norm_grad_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]], %[[ARG3]], %[[ARG4]]) <{
++  // CHECK-SAME:   epsilon = #vhlo.float_v1<1.000000e-03 : !vhlo.f32_v1>,
++  // CHECK-SAME:   feature_index = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x16x16x16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x16x16x16x!vhlo.f32_v1>) -> (!vhlo.tensor_v1<16x16x16x16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>)
++  %0:3 = "stablehlo.batch_norm_grad"(%arg0, %arg1, %arg2, %arg3, %arg4) {
++    epsilon = 0.001 : f32,
++    feature_index = 0 : i64
++  } : (tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>, tensor<16xf32>, tensor<16x16x16x16xf32>) -> (tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>)
++  func.return %0#0, %0#1, %0#2 : tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_batch_norm_inference"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}}, %[[ARG3:.*]]: {{.*}}, %[[ARG4:.*]]: {{.*}})
++func.func @op_batch_norm_inference(%arg0: tensor<16x16x16x16xf32>, %arg1: tensor<16xf32>, %arg2: tensor<16xf32>, %arg3: tensor<16xf32>, %arg4: tensor<16xf32>) -> tensor<16x16x16x16xf32> {
++  //      CHECK: "vhlo.batch_norm_inference_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]], %[[ARG3]], %[[ARG4]]) <{
++  // CHECK-SAME:   epsilon = #vhlo.float_v1<1.000000e-03 : !vhlo.f32_v1>,
++  // CHECK-SAME:   feature_index = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x16x16x16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x16x16x16x!vhlo.f32_v1>
++  %0 = "stablehlo.batch_norm_inference"(%arg0, %arg1, %arg2, %arg3, %arg4) {
++    epsilon = 0.001 : f32,
++    feature_index = 0 : i64
++  } : (tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>, tensor<16xf32>, tensor<16xf32>) -> tensor<16x16x16x16xf32>
++  func.return %0 : tensor<16x16x16x16xf32>
++}
++
++// CHECK-LABEL: "op_batch_norm_training"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_batch_norm_training(%arg0: tensor<16x16x16x16xf32>, %arg1: tensor<16xf32>, %arg2: tensor<16xf32>) -> (tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>) {
++  //      CHECK: "vhlo.batch_norm_training_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   epsilon = #vhlo.float_v1<1.000000e-03 : !vhlo.f32_v1>,
++  // CHECK-SAME:   feature_index = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x16x16x16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>) -> (!vhlo.tensor_v1<16x16x16x16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x!vhlo.f32_v1>)
++  %0:3 = "stablehlo.batch_norm_training"(%arg0, %arg1, %arg2) {
++    epsilon = 0.001 : f32,
++    feature_index = 0 : i64
++  } : (tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>) -> (tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>)
++  func.return %0#0, %0#1, %0#2 : tensor<16x16x16x16xf32>, tensor<16xf32>, tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_bitcast_convert"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_bitcast_convert(%arg0: tensor<i32>) -> tensor<f32> {
++  // CHECK: "vhlo.bitcast_convert_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.bitcast_convert"(%arg0) : (tensor<i32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_broadcast_in_dim"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_broadcast_in_dim(%arg0: tensor<16xf32>) -> tensor<16x16xf32> {
++  //      CHECK: "vhlo.broadcast_in_dim_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   broadcast_dimensions = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x16x!vhlo.f32_v1>
++  %0 = "stablehlo.broadcast_in_dim"(%arg0) {
++    broadcast_dimensions = array<i64: 1>
++  } : (tensor<16xf32>) -> tensor<16x16xf32>
++  func.return %0 : tensor<16x16xf32>
++}
++
++// CHECK-LABEL: "op_broadcast"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_broadcast(%arg0: tensor<16xf32>) -> tensor<16x16xf32> {
++  //      CHECK: "vhlo.broadcast_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   broadcast_sizes = #vhlo.tensor_v1<dense<16> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x16x!vhlo.f32_v1>
++  %0 = "stablehlo.broadcast"(%arg0) {
++    broadcast_sizes = array<i64: 16>
++  } : (tensor<16xf32>) -> tensor<16x16xf32>
++  func.return %0 : tensor<16x16xf32>
++}
++
++// CHECK-LABEL: "op_case"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_case(%arg0: tensor<i32>, %arg1: tensor<f32>) -> tensor<f32> {
++  //      CHECK: "vhlo.case_v1"(%[[ARG0]]) ({
++  // CHECK-NEXT:   "vhlo.return_v1"(%[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.case"(%arg0) ({
++    "stablehlo.return"(%arg1) : (tensor<f32>) -> ()
++  }) : (tensor<i32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_cbrt"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_cbrt(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.cbrt_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.cbrt"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_ceil"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_ceil(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.ceil_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.ceil"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_cholesky"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_cholesky(%arg0: tensor<1x16x16xf32>) -> tensor<1x16x16xf32> {
++  //      CHECK: "vhlo.cholesky_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   lower = #vhlo.bool_v1<true>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<1x16x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<1x16x16x!vhlo.f32_v1>
++  %0 = "stablehlo.cholesky"(%arg0) {
++    lower = true
++  } : (tensor<1x16x16xf32>) -> tensor<1x16x16xf32>
++  func.return %0 : tensor<1x16x16xf32>
++}
++
++// CHECK-LABEL: "op_clamp"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_clamp(%arg0: tensor<f32>, %arg1: tensor<f32>, %arg2: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.clamp_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.clamp"(%arg0, %arg1, %arg2) : (tensor<f32>, tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_count_leading_zeros"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_count_leading_zeros(%arg0: tensor<i32>) -> tensor<i32> {
++  // CHECK: "vhlo.count_leading_zeros_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.i32_v1>
++  %0 = "stablehlo.count_leading_zeros"(%arg0) : (tensor<i32>) -> tensor<i32>
++  func.return %0 : tensor<i32>
++}
++
++// CHECK-LABEL: "op_collective_permute"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_collective_permute(%arg0: tensor<16x8xf32>) -> tensor<16x8xf32> {
++  //               CHECK: "vhlo.collective_permute_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME{LITERAL}:   source_target_pairs = #vhlo.tensor_v1<dense<[[0, 1], [1, 2], [2, 3]]> : tensor<3x2xi64>>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x8x!vhlo.f32_v1>
++  %0 = "stablehlo.collective_permute"(%arg0) {
++    source_target_pairs = dense<[[0, 1], [1, 2], [2, 3]]> : tensor<3x2xi64>,
++    channel_handle = #stablehlo.channel_handle<handle = 1, type = 0>
++  } : (tensor<16x8xf32>) -> tensor<16x8xf32>
++  func.return %0 : tensor<16x8xf32>
++}
++
++// CHECK-LABEL: "op_compare"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_compare(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<i1> {
++  //      CHECK: "vhlo.compare_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   compare_type = #vhlo<comparison_type_v1 TOTALORDER>,
++  // CHECK-SAME:   comparison_direction = #vhlo<comparison_direction_v1 EQ>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.compare"(%arg0, %arg1) {
++    comparison_direction = #stablehlo<comparison_direction EQ>,
++    compare_type = #stablehlo<comparison_type TOTALORDER>
++  } : (tensor<f32>, tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "op_complex"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_complex(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<complex<f32>> {
++  // CHECK: "vhlo.complex_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f32_v1>>
++  %0 = "stablehlo.complex"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<complex<f32>>
++  func.return %0 : tensor<complex<f32>>
++}
++
++// CHECK-LABEL: "op_composite"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_composite(%arg0: tensor<f32>) -> tensor<f32> {
++  //               CHECK: "vhlo.composite_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   composite_attributes = #vhlo.dict_v1<{#vhlo.string_v1<"my_int"> = #vhlo.integer_v1<1 : i64>, #vhlo.string_v1<"my_string"> = #vhlo.string_v1<"foo">}>
++  //          CHECK-SAME:   decomposition = #vhlo.string_v1<"composite_target">
++  //          CHECK-SAME:   name = #vhlo.string_v1<"stablehlo.composite_target">
++  //          CHECK-SAME:   version = #vhlo.integer_v1<1 : i32>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.composite"(%arg0) {
++    name = "stablehlo.composite_target",
++    decomposition = @composite_target,
++    version = 1 : i32,
++    composite_attributes = {
++      my_string = "foo",
++      my_int = 1 : i64
++    }
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_concatenate"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_concatenate(%arg0: tensor<8xf32>, %arg1: tensor<8xf32>) -> tensor<16xf32> {
++  //      CHECK: "vhlo.concatenate_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   dimension = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<8x!vhlo.f32_v1>, !vhlo.tensor_v1<8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.concatenate"(%arg0, %arg1) {
++    dimension = 0 : i64
++  } : (tensor<8xf32>, tensor<8xf32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_constant"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_constant(%arg0: tensor<f32>) -> tensor<f32> {
++  //      CHECK: "vhlo.constant_v1"() <{
++  // CHECK-SAME:   value = #vhlo.tensor_v1<dense<0.000000e+00> : tensor<f32>>
++  // CHECK-SAME: }> : () -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.constant"() {
++    value = dense<0.0> : tensor<f32>
++  } : () -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_convert"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_convert(%arg0: tensor<i32>) -> tensor<f32> {
++  // CHECK: "vhlo.convert_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.convert"(%arg0) : (tensor<i32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_convolution"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_convolution(%arg0: tensor<1x8x8x207xf32>, %arg1: tensor<3x3x207x16xf32>) -> tensor<1x7x7x16xf32> {
++  //      CHECK: "vhlo.convolution_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   batch_group_count = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   feature_group_count = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   input_batch_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   input_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   input_spatial_dimensions = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   kernel_input_feature_dimension = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   kernel_output_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   kernel_spatial_dimensions = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   lhs_dilation = #vhlo.tensor_v1<dense<2> : tensor<2xi64>>,
++  // CHECK-SAME:   output_batch_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   output_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   output_spatial_dimensions = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   padding = #vhlo.tensor_v1<dense<1> : tensor<2x2xi64>>,
++  // CHECK-SAME:   precision_config = #vhlo.array_v1<[#vhlo<precision_v1 HIGHEST>, #vhlo<precision_v1 HIGHEST>]>,
++  // CHECK-SAME:   rhs_dilation = #vhlo.tensor_v1<dense<2> : tensor<2xi64>>,
++  // CHECK-SAME:   window_reversal = #vhlo.tensor_v1<dense<true> : tensor<2xi1>>,
++  // CHECK-SAME:   window_strides = #vhlo.tensor_v1<dense<2> : tensor<2xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<1x8x8x207x!vhlo.f32_v1>, !vhlo.tensor_v1<3x3x207x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<1x7x7x16x!vhlo.f32_v1>
++  %0 = "stablehlo.convolution"(%arg0, %arg1) {
++    window_strides = array<i64: 2, 2>,
++    padding = dense<1> : tensor<2x2xi64>,
++    lhs_dilation = array<i64: 2, 2>,
++    rhs_dilation = array<i64: 2, 2>,
++    window_reversal = array<i1: true, true>,
++    dimension_numbers = #stablehlo.conv<[b, 0, 1, f]x[0, 1, i, o]->[b, 0, 1, f]>,
++    feature_group_count = 1 : i64,
++    batch_group_count = 1 : i64,
++    precision_config = [#stablehlo<precision HIGHEST>, #stablehlo<precision HIGHEST>]
++  } : (tensor<1x8x8x207xf32>, tensor<3x3x207x16xf32>) -> tensor<1x7x7x16xf32>
++  func.return %0 : tensor<1x7x7x16xf32>
++}
++
++// CHECK-LABEL: "op_cosine"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_cosine(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.cosine_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.cosine"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_create_token"
++func.func @op_create_token() -> !stablehlo.token {
++  // CHECK: "vhlo.create_token_v1"() : () -> !vhlo.token_v1
++  %0 = "stablehlo.create_token"() : () -> !stablehlo.token
++  func.return %0 : !stablehlo.token
++}
++
++// CHECK-LABEL: "op_cross_replica_sum"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_cross_replica_sum(%arg0: tensor<f32>) -> tensor<f32> {
++  //               CHECK: "vhlo.cross-replica-sum_v1"(%[[ARG0]]) <{
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0], [1]]> : tensor<2x1xi64>>
++  //          CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.cross-replica-sum"(%arg0) {
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_custom_call"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_custom_call(%arg0: tensor<f32>) -> tensor<f32> {
++  //      CHECK: "vhlo.custom_call_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   api_version = #vhlo<api_version_v1 API_VERSION_STATUS_RETURNING>,
++  // CHECK-SAME:   backend_config = #vhlo.string_v1<"\08\03\1A\02">,
++  // CHECK-SAME:   call_target_name = #vhlo.string_v1<"foo">,
++  // CHECK-SAME:   called_computations = #vhlo.array_v1<[#vhlo.string_v1<"foo">]>,
++  // CHECK-SAME:   has_side_effect = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   operand_layouts = #vhlo.array_v1<[#vhlo.tensor_v1<dense<> : tensor<0xindex>>]>,
++  // CHECK-SAME:   output_operand_aliases = #vhlo.array_v1<[
++  // CHECK-SAME:     #vhlo.output_operand_alias_v1<
++  // CHECK-SAME:       outputTupleIndices = [],
++  // CHECK-SAME:       operandIndex = 0,
++  // CHECK-SAME:       operandTupleIndices = []>]>
++  // CHECK-SAME:   result_layouts = #vhlo.array_v1<[#vhlo.tensor_v1<dense<> : tensor<0xindex>>]>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo",
++    has_side_effect = true,
++    backend_config = "\08\03\1A\02",
++    api_version = 2 : i32,
++    called_computations = [@foo],
++    operand_layouts = [dense<> : tensor<0xindex>],
++    output_operand_aliases = [
++      #stablehlo.output_operand_alias<output_tuple_indices = [],
++                                 operand_index = 0,
++                                 operand_tuple_indices = []>],
++    result_layouts = [dense<> : tensor<0xindex>]
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_custom_call_empty_result_layout"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func public @op_custom_call_empty_result_layout(%arg0: tensor<i64>) -> tensor<i64> {
++  // %0 = "vhlo.custom_call_v1"(%arg0) <{>}> : (!vhlo.tensor_v1<!vhlo.i64_v1>) -> !vhlo.tuple_v1<>
++  //      CHECK: "vhlo.custom_call_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   api_version = #vhlo<api_version_v1 API_VERSION_STATUS_RETURNING>,
++  // CHECK-SAME:   backend_config = #vhlo.string_v1<"">,
++  // CHECK-SAME:   call_target_name = #vhlo.string_v1<"empty_output">,
++  // CHECK-SAME:   called_computations = #vhlo.array_v1<[]>,
++  // CHECK-SAME:   has_side_effect = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   operand_layouts = #vhlo.array_v1<[#vhlo.tensor_v1<dense<> : tensor<0xindex>>]>,
++  // CHECK-SAME:   output_operand_aliases = #vhlo.array_v1<[]>,
++  // CHECK-SAME:   result_layouts = #vhlo.array_v1<[]>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.i64_v1>) -> !vhlo.tuple_v1<>
++  %0 = "stablehlo.custom_call"(%arg0) <{
++    api_version = 2 : i32,
++    call_target_name = "empty_output",
++    has_side_effect = true,
++    operand_layouts = [dense<> : tensor<0xindex>],
++    result_layouts = []
++  }> : (tensor<i64>) -> tuple<>
++  return %arg0 : tensor<i64>
++}
++
++// CHECK-LABEL: "op_divide"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_divide(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.divide_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.divide"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_dot_general"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_dot_general(%arg0: tensor<8x8x16xf32>, %arg1: tensor<8x16x8xf32>) -> tensor<8x8x8xf32> {
++  //      CHECK: "vhlo.dot_general_v2"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   accumulation_type = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   allow_imprecise_accumulation = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   lhs_batching_dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   lhs_component_count = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   lhs_contracting_dimensions = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++  // CHECK-SAME:   lhs_precision_type = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   num_primitive_operations = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   precision_config = #vhlo.array_v1<[#vhlo<precision_v1 HIGHEST>, #vhlo<precision_v1 HIGHEST>]>,
++  // CHECK-SAME:   rhs_batching_dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   rhs_component_count = #vhlo.type_v1<!vhlo.none_v1>,
++  // CHECK-SAME:   rhs_contracting_dimensions = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>,
++  // CHECK-SAME:   rhs_precision_type = #vhlo.type_v1<!vhlo.none_v1>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<8x8x16x!vhlo.f32_v1>, !vhlo.tensor_v1<8x16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<8x8x8x!vhlo.f32_v1>
++  %0 = "stablehlo.dot_general"(%arg0, %arg1) {
++    dot_dimension_numbers = #stablehlo.dot<
++      lhs_batching_dimensions = [0],
++      lhs_contracting_dimensions = [2],
++      rhs_batching_dimensions = [0],
++      rhs_contracting_dimensions = [1]
++    >,
++    precision_config = [#stablehlo<precision HIGHEST>, #stablehlo<precision HIGHEST>]
++  } : (tensor<8x8x16xf32>, tensor<8x16x8xf32>) -> tensor<8x8x8xf32>
++  func.return %0 : tensor<8x8x8xf32>
++}
++
++// CHECK-LABEL: "op_dot"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_dot(%arg0: tensor<8x16xf32>, %arg1: tensor<16x8xf32>) -> tensor<8x8xf32> {
++  //      CHECK: "vhlo.dot_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   precision_config = #vhlo.array_v1<[#vhlo<precision_v1 HIGHEST>, #vhlo<precision_v1 HIGHEST>]>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<8x16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<8x8x!vhlo.f32_v1>
++  %0 = "stablehlo.dot"(%arg0, %arg1) {
++    precision_config = [#stablehlo<precision HIGHEST>, #stablehlo<precision HIGHEST>]
++  } : (tensor<8x16xf32>, tensor<16x8xf32>) -> tensor<8x8xf32>
++  func.return %0 : tensor<8x8xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_broadcast_in_dim"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_dynamic_broadcast_in_dim(%arg0: tensor<?x?xf32>, %arg1: tensor<2xindex>) -> tensor<?x?xf32> {
++  //      CHECK: "vhlo.dynamic_broadcast_in_dim_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   broadcast_dimensions = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   known_expanding_dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   known_nonexpanding_dimensions = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<?x?x!vhlo.f32_v1>, !vhlo.tensor_v1<2x!vhlo.index_v1>) -> !vhlo.tensor_v1<?x?x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_broadcast_in_dim"(%arg0, %arg1) {
++    broadcast_dimensions = array<i64: 0, 1>,
++    known_expanding_dimensions = array<i64: 0>,
++    known_nonexpanding_dimensions = array<i64: 1>
++  } : (tensor<?x?xf32>, tensor<2xindex>) -> tensor<?x?xf32>
++  func.return %0 : tensor<?x?xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_conv"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_dynamic_conv(%arg0: tensor<1x8x8x207xf32>, %arg1: tensor<3x3x207x16xf32>, %arg2: tensor<2x2xi64>) -> tensor<1x?x?x16xf32> {
++  //      CHECK: "vhlo.dynamic_conv_v2"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   batch_group_count = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   feature_group_count = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   input_batch_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   input_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   input_spatial_dimensions = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   kernel_input_feature_dimension = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   kernel_output_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   kernel_spatial_dimensions = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   lhs_dilation = #vhlo.tensor_v1<dense<2> : tensor<2xi64>>,
++  // CHECK-SAME:   output_batch_dimension = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   output_feature_dimension = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   output_spatial_dimensions = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   precision_config = #vhlo.array_v1<[#vhlo<precision_v1 HIGHEST>, #vhlo<precision_v1 HIGHEST>]>,
++  // CHECK-SAME:   rhs_dilation = #vhlo.tensor_v1<dense<2> : tensor<2xi64>>,
++  // CHECK-SAME:   window_reversal = #vhlo.tensor_v1<dense<true> : tensor<2xi1>>,
++  // CHECK-SAME:   window_strides = #vhlo.tensor_v1<dense<2> : tensor<2xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<1x8x8x207x!vhlo.f32_v1>, !vhlo.tensor_v1<3x3x207x16x!vhlo.f32_v1>, !vhlo.tensor_v1<2x2x!vhlo.i64_v1>) -> !vhlo.tensor_v1<1x?x?x16x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_conv"(%arg0, %arg1, %arg2) {
++    window_strides = array<i64: 2, 2>,
++    lhs_dilation = array<i64: 2, 2>,
++    rhs_dilation = array<i64: 2, 2>,
++    window_reversal = array<i1: true, true>,
++    dimension_numbers = #stablehlo.conv<[b, 0, 1, f]x[0, 1, i, o]->[b, 0, 1, f]>,
++    feature_group_count = 1 : i64,
++    batch_group_count = 1 : i64,
++    precision_config = [#stablehlo<precision HIGHEST>, #stablehlo<precision HIGHEST>]
++  } : (tensor<1x8x8x207xf32>, tensor<3x3x207x16xf32>, tensor<2x2xi64>) -> tensor<1x?x?x16xf32>
++  func.return %0 : tensor<1x?x?x16xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_gather"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_dynamic_gather(%arg0 : tensor<2x4x9xf32>, %arg1 : tensor<1x5x2xi32>, %arg2 : tensor<3xi32>) -> tensor<1x5x8xf32> {
++  //      CHECK: "vhlo.dynamic_gather_v2"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   collapsed_slice_dims = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   offset_dims = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++  // CHECK-SAME:   operand_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   start_index_map = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   start_indices_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<2x4x9x!vhlo.f32_v1>, !vhlo.tensor_v1<1x5x2x!vhlo.i32_v1>, !vhlo.tensor_v1<3x!vhlo.i32_v1>) -> !vhlo.tensor_v1<1x5x8x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_gather"(%arg0, %arg1, %arg2) {
++    dimension_numbers = #stablehlo.gather<
++      offset_dims = [2],
++      collapsed_slice_dims = [0, 1],
++      start_index_map = [0, 1],
++      index_vector_dim = 2
++    >,
++    indices_are_sorted = true
++  } : (tensor<2x4x9xf32>, tensor<1x5x2xi32>, tensor<3xi32>) -> tensor<1x5x8xf32>
++  func.return %0 : tensor<1x5x8xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_gather_with_batching_dims"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_dynamic_gather_with_batching_dims(%arg0 : tensor<5x2x4x9xf32>, %arg1 : tensor<1x5x2xi32>, %arg2 : tensor<4xi32>) -> tensor<1x5x8xf32> {
++  //      CHECK: "vhlo.dynamic_gather_v2"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   collapsed_slice_dims = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   offset_dims = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++  // CHECK-SAME:   operand_batching_dims = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   start_index_map = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   start_indices_batching_dims = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<5x2x4x9x!vhlo.f32_v1>, !vhlo.tensor_v1<1x5x2x!vhlo.i32_v1>, !vhlo.tensor_v1<4x!vhlo.i32_v1>) -> !vhlo.tensor_v1<1x5x8x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_gather"(%arg0, %arg1, %arg2) {
++    dimension_numbers = #stablehlo.gather<
++      offset_dims = [2],
++      collapsed_slice_dims = [1, 2],
++      operand_batching_dims = [0],
++      start_indices_batching_dims = [1],
++      start_index_map = [1, 2],
++      index_vector_dim = 2
++    >,
++    indices_are_sorted = true
++  } : (tensor<5x2x4x9xf32>, tensor<1x5x2xi32>, tensor<4xi32>) -> tensor<1x5x8xf32>
++  func.return %0 : tensor<1x5x8xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_iota"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_dynamic_iota(%arg0: tensor<1xindex>) -> tensor<?xf32> {
++  //      CHECK: "vhlo.dynamic_iota_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   iota_dimension = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<1x!vhlo.index_v1>) -> !vhlo.tensor_v1<?x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_iota"(%arg0) {
++    iota_dimension = 0 : i64
++  } : (tensor<1xindex>) -> tensor<?xf32>
++  func.return %0 : tensor<?xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_pad"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}}, %[[ARG3:.*]]: {{.*}}, %[[ARG4:.*]]: {{.*}})
++func.func @op_dynamic_pad(%arg0: tensor<?xf32>, %arg1: tensor<f32>, %arg2: tensor<1xindex>, %arg3: tensor<1xindex>, %arg4: tensor<1xindex>) -> tensor<?xf32> {
++  // CHECK: "vhlo.dynamic_pad_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]], %[[ARG3]], %[[ARG4]]) : (!vhlo.tensor_v1<?x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<1x!vhlo.index_v1>, !vhlo.tensor_v1<1x!vhlo.index_v1>, !vhlo.tensor_v1<1x!vhlo.index_v1>) -> !vhlo.tensor_v1<?x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_pad"(%arg0, %arg1, %arg2, %arg3, %arg4) : (tensor<?xf32>, tensor<f32>, tensor<1xindex>, tensor<1xindex>, tensor<1xindex>) -> tensor<?xf32>
++  func.return %0 : tensor<?xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_reshape"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_dynamic_reshape(%arg0: tensor<16xf32>, %arg1: tensor<2xindex>) -> tensor<?x?xf32> {
++  // CHECK: "vhlo.dynamic_reshape_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<2x!vhlo.index_v1>) -> !vhlo.tensor_v1<?x?x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_reshape"(%arg0, %arg1) : (tensor<16xf32>, tensor<2xindex>) -> tensor<?x?xf32>
++  func.return %0 : tensor<?x?xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_slice"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_dynamic_slice(%arg0: tensor<16xf32>, %arg1: tensor<i64>) -> tensor<4xf32> {
++  //      CHECK: "vhlo.dynamic_slice_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   slice_sizes = #vhlo.tensor_v1<dense<4> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.i64_v1>) -> !vhlo.tensor_v1<4x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_slice"(%arg0, %arg1) {
++    slice_sizes = array<i64: 4>
++  } : (tensor<16xf32>, tensor<i64>) -> tensor<4xf32>
++  func.return %0 : tensor<4xf32>
++}
++
++// CHECK-LABEL: "op_dynamic_update_slice"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_dynamic_update_slice(%arg0: tensor<16xf32>, %arg1: tensor<4xf32>, %arg2: tensor<i64>) -> tensor<16xf32> {
++  // CHECK: "vhlo.dynamic_update_slice_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<4x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.i64_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.dynamic_update_slice"(%arg0, %arg1, %arg2) : (tensor<16xf32>, tensor<4xf32>, tensor<i64>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_einsum"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_einsum(%arg0: tensor<8x16xf32>, %arg1: tensor<16x8xf32>) -> tensor<8x8xf32> {
++  //      CHECK: "vhlo.einsum_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   einsum_config = #vhlo.string_v1<"ab,bc->ac">
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<8x16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<8x8x!vhlo.f32_v1>
++  %0 = "stablehlo.einsum"(%arg0, %arg1) {
++    einsum_config = "ab,bc->ac"
++  } : (tensor<8x16xf32>, tensor<16x8xf32>) -> tensor<8x8xf32>
++  func.return %0 : tensor<8x8xf32>
++}
++
++// CHECK-LABEL: "op_exponential_minus_one"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_exponential_minus_one(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.exponential_minus_one_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.exponential_minus_one"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_exponential"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_exponential(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.exponential_v2"(%[[ARG0]]) <{result_accuracy = #vhlo.result_accuracy_v1<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #vhlo<result_accuracy_mode_v1 DEFAULT>>}> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.exponential"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_fft"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_fft(%arg0: tensor<16xcomplex<f32>>) -> tensor<16xcomplex<f32>> {
++  //      CHECK: "vhlo.fft_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   fft_length = #vhlo.tensor_v1<dense<16> : tensor<1xi64>>,
++  // CHECK-SAME:   fft_type = #vhlo<fft_type_v1 FFT>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x!vhlo.complex_v1<!vhlo.f32_v1>>) -> !vhlo.tensor_v1<16x!vhlo.complex_v1<!vhlo.f32_v1>>
++  %0 = "stablehlo.fft"(%arg0) {
++    fft_type = #stablehlo<fft_type FFT>,
++    fft_length = array<i64: 16>
++  } : (tensor<16xcomplex<f32>>) -> tensor<16xcomplex<f32>>
++  func.return %0 : tensor<16xcomplex<f32>>
++}
++
++// CHECK-LABEL: "op_floor"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_floor(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.floor_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.floor"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++func.func private @op_func(%arg0: tensor<f32> {stablehlo.arg = "0"}) -> (tensor<f32> {stablehlo.result = "0"}) {
++  // CHECK:      "vhlo.func_v1"() <{
++  // CHECK-SAME:   arg_attrs = #vhlo.array_v1<[#vhlo.dict_v1<{#vhlo.string_v1<"stablehlo.arg"> = #vhlo.string_v1<"0">}>]>,
++  // CHECK-SAME:   function_type = #vhlo.type_v1<!vhlo.func_v1<(!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>>>,
++  // CHECK-SAME:   res_attrs = #vhlo.array_v1<[#vhlo.dict_v1<{#vhlo.string_v1<"stablehlo.result"> = #vhlo.string_v1<"0">}>]>,
++  // CHECK-SAME:   sym_name = #vhlo.string_v1<"op_func">,
++  // CHECK-SAME:   sym_visibility = #vhlo.string_v1<"private">
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG0:.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : () -> ()
++
++  func.return %arg0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_gather"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_gather(%arg0 : tensor<2x4x9xf32>, %arg1 : tensor<1x5x2xi32>) -> tensor<1x5x1xf32> {
++  //      CHECK: "vhlo.gather_v2"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   collapsed_slice_dims = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   offset_dims = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++  // CHECK-SAME:   operand_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   slice_sizes = #vhlo.tensor_v1<dense<1> : tensor<3xi64>>,
++  // CHECK-SAME:   start_index_map = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   start_indices_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<2x4x9x!vhlo.f32_v1>, !vhlo.tensor_v1<1x5x2x!vhlo.i32_v1>) -> !vhlo.tensor_v1<1x5x1x!vhlo.f32_v1>
++  %0 = "stablehlo.gather"(%arg0, %arg1) {
++    dimension_numbers = #stablehlo.gather<
++      offset_dims = [2],
++      collapsed_slice_dims = [0, 1],
++      start_index_map = [0, 1],
++      index_vector_dim = 2
++    >,
++    slice_sizes = array<i64: 1, 1, 1>,
++    indices_are_sorted = true
++  } : (tensor<2x4x9xf32>, tensor<1x5x2xi32>) -> tensor<1x5x1xf32>
++  func.return %0 : tensor<1x5x1xf32>
++}
++
++// CHECK-LABEL: "op_gather_with_batching_dims"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_gather_with_batching_dims(%arg0 : tensor<5x2x4x9xf32>, %arg1 : tensor<1x5x2xi32>) -> tensor<1x5x1xf32> {
++  //      CHECK: "vhlo.gather_v2"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   collapsed_slice_dims = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   offset_dims = #vhlo.tensor_v1<dense<2> : tensor<1xi64>>,
++  // CHECK-SAME:   operand_batching_dims = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   slice_sizes = #vhlo.tensor_v1<dense<1> : tensor<4xi64>>,
++  // CHECK-SAME:   start_index_map = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   start_indices_batching_dims = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<5x2x4x9x!vhlo.f32_v1>, !vhlo.tensor_v1<1x5x2x!vhlo.i32_v1>) -> !vhlo.tensor_v1<1x5x1x!vhlo.f32_v1>
++  %0 = "stablehlo.gather"(%arg0, %arg1) {
++    dimension_numbers = #stablehlo.gather<
++      offset_dims = [2],
++      collapsed_slice_dims = [1, 2],
++      operand_batching_dims = [0],
++      start_indices_batching_dims = [1],
++      start_index_map = [1, 2],
++      index_vector_dim = 2
++    >,
++    slice_sizes = array<i64: 1, 1, 1, 1>,
++    indices_are_sorted = true
++  } : (tensor<5x2x4x9xf32>, tensor<1x5x2xi32>) -> tensor<1x5x1xf32>
++  func.return %0 : tensor<1x5x1xf32>
++}
++
++// CHECK-LABEL: "op_get_dimension_size"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_get_dimension_size(%arg0: tensor<?xf32>) -> tensor<i32> {
++  //      CHECK: "vhlo.get_dimension_size_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   dimension = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<?x!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.i32_v1>
++  %0 = "stablehlo.get_dimension_size"(%arg0) {
++    dimension = 0 : i64
++  } : (tensor<?xf32>) -> tensor<i32>
++  func.return %0 : tensor<i32>
++}
++
++// CHECK-LABEL: "op_get_tuple_element"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_get_tuple_element(%arg0: tuple<tensor<f32>, tensor<i32>>) -> tensor<f32> {
++  //      CHECK: "vhlo.get_tuple_element_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   index = #vhlo.integer_v1<0 : i32>
++  // CHECK-SAME: }> : (!vhlo.tuple_v1<!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.i32_v1>>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.get_tuple_element"(%arg0) {
++    index = 0 : i32
++  } : (tuple<tensor<f32>, tensor<i32>>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_if"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_if(%arg0: tensor<i1>, %arg1: tensor<f32>, %arg2: tensor<f32>) -> tensor<f32> {
++  //      CHECK: "vhlo.if_v1"(%[[ARG0]]) ({
++  // CHECK-NEXT:   "vhlo.return_v1"(%[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }, {
++  // CHECK-NEXT:   "vhlo.return_v1"(%[[ARG2]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.if"(%arg0) ({
++    "stablehlo.return"(%arg1) : (tensor<f32>) -> ()
++  }, {
++    "stablehlo.return"(%arg2) : (tensor<f32>) -> ()
++  }) : (tensor<i1>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_imag"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_imag(%arg0: tensor<complex<f32>>) -> tensor<f32> {
++  // CHECK: "vhlo.imag_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f32_v1>>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.imag"(%arg0) : (tensor<complex<f32>>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_infeed"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_infeed(%arg0: !stablehlo.token) -> (tensor<f32>, !stablehlo.token) {
++  //               CHECK: "vhlo.infeed_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   infeed_config = #vhlo.string_v1<"foo">,
++  // CHECK-SAME{LITERAL}:   layout = #vhlo.array_v1<[#vhlo.array_v1<[]>]>
++  //          CHECK-SAME: }> : (!vhlo.token_v1) -> (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.token_v1)
++  %0:2 = "stablehlo.infeed"(%arg0) {
++    infeed_config = "foo",
++    layout = [[]]
++  } : (!stablehlo.token) -> (tensor<f32>, !stablehlo.token)
++  func.return %0#0, %0#1 : tensor<f32>, !stablehlo.token
++}
++
++// CHECK-LABEL: "op_iota"
++func.func @op_iota() -> tensor<16xf32> {
++  //      CHECK: "vhlo.iota_v1"() <{
++  // CHECK-SAME:   iota_dimension = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : () -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.iota"() {
++    iota_dimension = 0 : i64
++  } : () -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_is_finite"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_is_finite(%arg0: tensor<f32>) -> tensor<i1> {
++  // CHECK: "vhlo.is_finite_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.is_finite"(%arg0) : (tensor<f32>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "op_log"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_log(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.log_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.log"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_log_plus_one"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_log_plus_one(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.log_plus_one_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.log_plus_one"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_logistic"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_logistic(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.logistic_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.logistic"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_map"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_map(%arg0: tensor<16xf32>) -> tensor<16xf32> {
++  //      CHECK: "vhlo.map_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.abs_v1"(%[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.map"(%arg0) ({
++    ^bb0(%arg1: tensor<f32>):
++      %1 = "stablehlo.abs"(%arg1) : (tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    dimensions = array<i64: 0>
++  } : (tensor<16xf32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_maximum"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_maximum(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.maximum_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.maximum"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_minimum"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_minimum(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.minimum_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.minimum"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_multiply"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_multiply(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.multiply_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.multiply"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_negate"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_negate(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.negate_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.negate"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_not"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_not(%arg0: tensor<i1>) -> tensor<i1> {
++  // CHECK: "vhlo.not_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.not"(%arg0) : (tensor<i1>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "op_optimization_barrier"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_optimization_barrier(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.optimization_barrier_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.optimization_barrier"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_or"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_or(%arg0: tensor<i1>, %arg1: tensor<i1>) -> tensor<i1> {
++  // CHECK: "vhlo.or_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>, !vhlo.tensor_v1<!vhlo.bool_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.or"(%arg0, %arg1) : (tensor<i1>, tensor<i1>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "op_outfeed"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_outfeed(%arg0: tensor<f32>, %arg1: !stablehlo.token) -> !stablehlo.token {
++  //      CHECK: "vhlo.outfeed_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   outfeed_config = #vhlo.string_v1<"foo">
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.token_v1) -> !vhlo.token_v1
++  %0 = "stablehlo.outfeed"(%arg0, %arg1) {
++    outfeed_config = "foo"
++  } : (tensor<f32>, !stablehlo.token) -> !stablehlo.token
++  func.return %0 : !stablehlo.token
++}
++
++// CHECK-LABEL: "op_pad"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_pad(%arg0: tensor<8xf32>, %arg1: tensor<f32>) -> tensor<16xf32> {
++  //      CHECK: "vhlo.pad_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   edge_padding_high = #vhlo.tensor_v1<dense<4> : tensor<1xi64>>,
++  // CHECK-SAME:   edge_padding_low = #vhlo.tensor_v1<dense<4> : tensor<1xi64>>,
++  // CHECK-SAME:   interior_padding = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<8x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.pad"(%arg0, %arg1) {
++    edge_padding_high = array<i64: 4>,
++    edge_padding_low = array<i64: 4>,
++    interior_padding = array<i64: 0>
++  } : (tensor<8xf32>, tensor<f32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_popcnt"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_popcnt(%arg0: tensor<i32>) -> tensor<i32> {
++  // CHECK: "vhlo.popcnt_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.i32_v1>
++  %0 = "stablehlo.popcnt"(%arg0) : (tensor<i32>) -> tensor<i32>
++  func.return %0 : tensor<i32>
++}
++
++// CHECK-LABEL: "op_power"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_power(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.power_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.power"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_real_dynamic_slice"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}}, %[[ARG3:.*]]: {{.*}})
++func.func @op_real_dynamic_slice(%arg0: tensor<?xf32>, %arg1: tensor<1xindex>, %arg2: tensor<1xindex>, %arg3: tensor<1xindex>) -> tensor<?xf32> {
++  // CHECK: "vhlo.real_dynamic_slice_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]], %[[ARG3]]) : (!vhlo.tensor_v1<?x!vhlo.f32_v1>, !vhlo.tensor_v1<1x!vhlo.index_v1>, !vhlo.tensor_v1<1x!vhlo.index_v1>, !vhlo.tensor_v1<1x!vhlo.index_v1>) -> !vhlo.tensor_v1<?x!vhlo.f32_v1>
++  %0 = "stablehlo.real_dynamic_slice"(%arg0, %arg1, %arg2, %arg3) : (tensor<?xf32>, tensor<1xindex>, tensor<1xindex>, tensor<1xindex>) -> tensor<?xf32>
++  func.return %0 : tensor<?xf32>
++}
++
++// CHECK-LABEL: "op_real"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_real(%arg0: tensor<complex<f32>>) -> tensor<f32> {
++  // CHECK: "vhlo.real_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f32_v1>>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.real"(%arg0) : (tensor<complex<f32>>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_recv"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_recv(%arg0: !stablehlo.token) -> (tensor<f32>, !stablehlo.token) {
++  //      CHECK: "vhlo.recv_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   channel_type = #vhlo.integer_v1<3 : i64>,
++  // CHECK-SAME:   is_host_transfer = #vhlo.bool_v1<true>
++  // CHECK-SAME: }> : (!vhlo.token_v1) -> (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.token_v1)
++  %0:2 = "stablehlo.recv"(%arg0) {
++    channel_handle = #stablehlo.channel_handle<handle = 0, type = 3>,
++    is_host_transfer = true
++  } : (!stablehlo.token) -> (tensor<f32>, !stablehlo.token)
++  func.return %0#0, %0#1 : tensor<f32>, !stablehlo.token
++}
++
++// CHECK-LABEL: "op_reduce"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_reduce(%arg0: tensor<16xf32>, %arg1: tensor<f32>) -> tensor<f32> {
++  //  CHECK: "vhlo.reduce_v1"(%[[ARG0]], %[[ARG1]])
++  //  CHECK:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  //  CHECK:     "vhlo.return_v1"(%[[VAL1:.*]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  //  CHECK: }) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.reduce"(%arg0, %arg1) ({
++    ^bb0(%arg2: tensor<f32>, %arg3: tensor<f32>):
++      %1 = "stablehlo.add"(%arg2, %arg3) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    dimensions = array<i64: 0>
++  } : (tensor<16xf32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_reduce_precision"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_reduce_precision(%arg0: tensor<f32>) -> tensor<f32> {
++  //      CHECK: "vhlo.reduce_precision_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   exponent_bits = #vhlo.integer_v1<8 : i32>
++  // CHECK-SAME:   mantissa_bits = #vhlo.integer_v1<10 : i32>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.reduce_precision"(%arg0) {
++    exponent_bits = 8 : i32,
++    mantissa_bits = 10 : i32
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK_lABEL: "op_reduce_with_promotable_types"
++func.func @op_reduce_with_promotable_types(%arg0: tensor<4x4xf32>, %arg1 : tensor<f32>)
++    -> (tensor<4xf64>) {
++  //  CHECK: "vhlo.reduce_v1"(%[[ARG0:.*]], %[[ARG1:.*]])
++  //  CHECK:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>):
++  //  CHECK:     "vhlo.return_v1"(%[[VAL1:.*]]) : (!vhlo.tensor_v1<!vhlo.f64_v1>) -> ()
++  //  CHECK: }) : (!vhlo.tensor_v1<4x4x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<4x!vhlo.f64_v1>
++  %0 = "stablehlo.reduce"(%arg0, %arg1) ({
++  ^bb0(%arg2: tensor<f64>, %arg3: tensor<f64> ):
++    %1 = "stablehlo.add"(%arg2, %arg3) : (tensor<f64>, tensor<f64>) -> tensor<f64>
++    "stablehlo.return"(%1) : (tensor<f64>) -> ()
++
++  }) {dimensions = array<i64: 0>} : (tensor<4x4xf32>, tensor<f32>) -> tensor<4xf64>
++
++  func.return %0: tensor<4xf64>
++}
++
++// CHECK-LABEL: "op_reduce_scatter"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_reduce_scatter(%arg0: tensor<16xf32>) -> tensor<16xf32> {
++  //               CHECK: "vhlo.reduce_scatter_v1"(%[[ARG0]]) <{
++  //          CHECK-SAME:   channel_id = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME{LITERAL}:   replica_groups = #vhlo.tensor_v1<dense<[[0], [1]]> : tensor<2x1xi64>>,
++  //          CHECK-SAME:   scatter_dimension = #vhlo.integer_v1<0 : i64>
++  //          CHECK-SAME:   use_global_device_ids = #vhlo.bool_v1<true>
++  //          CHECK-SAME: }> ({
++  //          CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  //          CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.add_v1"(%[[ARG1]], %[[ARG2]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  //          CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  //          CHECK-NEXT: }) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.reduce_scatter"(%arg0) ({
++    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):
++      %1 = "stablehlo.add"(%arg1, %arg2) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    scatter_dimension = 0 : i64,
++    replica_groups = dense<[[0], [1]]> : tensor<2x1xi64>,
++    channel_handle = #stablehlo.channel_handle<handle = 1, type = 0>,
++    use_global_device_ids
++  } : (tensor<16xf32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK_lABEL: "op_reduce_scatter_with_promotable_types"
++func.func @op_reduce_scatter_with_promotable_types(%data: tensor<4x16xf32>) -> tensor<4x4xf64> {
++  //  CHECK: "vhlo.reduce_scatter_v1"(%[[ARG0:.*]])
++  //  CHECK:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>):
++  //  CHECK:     "vhlo.return_v1"(%[[VAL1:.*]]) : (!vhlo.tensor_v1<!vhlo.f64_v1>) -> ()
++  //  CHECK: }) : (!vhlo.tensor_v1<4x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<4x4x!vhlo.f64_v1>
++  %0 = "stablehlo.reduce_scatter"(%data) ({
++    ^bb0(%arg2: tensor<f64>, %arg3: tensor<f64>):
++    %1 = stablehlo.add %arg2, %arg3 : tensor<f64>
++    "stablehlo.return"(%1) : (tensor<f64>) -> ()
++  }) {replica_groups = dense<[[0, 1, 2, 3]]> : tensor<1x4xi64>,
++      scatter_dimension = 1 : i64,
++      channel_handle = #stablehlo.channel_handle<handle = 1, type = 0>,
++      use_global_device_ids} : (tensor<4x16xf32>) -> tensor<4x4xf64>
++  func.return %0 : tensor<4x4xf64>
++}
++
++
++// CHECK-LABEL: "op_reduce_window"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_reduce_window(%arg0: tensor<2x17x31x7xf32>, %arg1: tensor<f32>) -> tensor<2x9x16x7xf32> {
++  //               CHECK: "vhlo.reduce_window_v1"(%[[ARG0]], %[[ARG1]]) <{
++  //          CHECK-SAME:   base_dilations = #vhlo.tensor_v1<dense<[1, 2, 2, 1]> : tensor<4xi64>>,
++  // CHECK-SAME{LITERAL}:   padding = #vhlo.tensor_v1<dense<[[0, 0], [2, 0], [0, 2], [0, 0]]> : tensor<4x2xi64>>,
++  //          CHECK-SAME:   window_dilations = #vhlo.tensor_v1<dense<[1, 2, 2, 1]> : tensor<4xi64>>,
++  //          CHECK-SAME:   window_dimensions = #vhlo.tensor_v1<dense<[1, 2, 2, 1]> : tensor<4xi64>>,
++  //          CHECK-SAME:   window_strides = #vhlo.tensor_v1<dense<[1, 4, 4, 1]> : tensor<4xi64>>
++  //          CHECK-SAME: }> ({
++  //          CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG3:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  //          CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.maximum_v1"(%[[ARG2]], %[[ARG3]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  //          CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  //          CHECK-NEXT: }) : (!vhlo.tensor_v1<2x17x31x7x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<2x9x16x7x!vhlo.f32_v1>
++  %0 = "stablehlo.reduce_window"(%arg0, %arg1) ({
++    ^bb0(%arg2: tensor<f32>, %arg3: tensor<f32>):
++      %1 = "stablehlo.maximum"(%arg2, %arg3) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    window_dimensions = array<i64: 1, 2, 2, 1>,
++    window_strides = array<i64: 1, 4, 4, 1>,
++    base_dilations = array<i64: 1, 2, 2, 1>,
++    window_dilations = array<i64: 1, 2, 2, 1>,
++    padding = dense<[[0, 0], [2, 0], [0, 2], [0, 0]]> : tensor<4x2xi64>
++  } : (tensor<2x17x31x7xf32>, tensor<f32>) -> tensor<2x9x16x7xf32>
++  func.return %0 : tensor<2x9x16x7xf32>
++}
++
++// CHECK-LABEL: "op_reduce_window_with_promotable_types"
++func.func @op_reduce_window_with_promotable_types(%arg0: tensor<4x2xf32>,
++    %arg1: tensor<4x2xf32>, %init0: tensor<f32>, %init1: tensor<f32>) ->
++    (tensor<2x2xf64>, tensor<2x2xf32>) {
++  //  CHECK: "vhlo.reduce_window_v1"(%[[ARG0:.*]], %[[ARG1:.*]], %[[ARG2:.*]], %[[ARG3:.*]])
++  //  CHECK:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG3:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>, %[[ARG4:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  //  CHECK:     "vhlo.return_v1"(%[[VAL1:.*]], %[[VAL2:.*]]) : (!vhlo.tensor_v1<!vhlo.f64_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  //  CHECK: }) : (!vhlo.tensor_v1<4x2x!vhlo.f32_v1>, !vhlo.tensor_v1<4x2x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<2x2x!vhlo.f64_v1>, !vhlo.tensor_v1<2x2x!vhlo.f32_v1>)
++  %0:2 = "stablehlo.reduce_window"(%arg0, %arg1, %init0, %init1) ({
++         ^bb0(%a0: tensor<f64>, %a1: tensor<f32>, %b0: tensor<f64>,
++                %b1: tensor<f32>):
++              %2 = stablehlo.add %a0, %b0 : tensor<f64>
++              %3 = stablehlo.add %a1, %b1 : tensor<f32>
++              "stablehlo.return"(%2,%3) : (tensor<f64>, tensor<f32>) -> ()
++            })
++         { padding = dense<[[2, 2], [0, 0]]> : tensor<2x2xi64>,
++         window_dimensions = array<i64: 5, 1>,
++         window_strides = array<i64: 3, 1> }
++         : (tensor<4x2xf32>, tensor<4x2xf32>, tensor<f32>, tensor<f32>) ->
++              (tensor<2x2xf64>, tensor<2x2xf32>)
++  func.return %0#0, %0#1 : tensor<2x2xf64>, tensor<2x2xf32>
++}
++
++// CHECK-LABEL: "op_remainder"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_remainder(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.remainder_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.remainder"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_replica_id"
++func.func @op_replica_id() -> tensor<ui32> {
++  // CHECK: "vhlo.replica_id_v1"() : () -> !vhlo.tensor_v1<!vhlo.ui32_v1>
++  %0 = "stablehlo.replica_id"() : () -> tensor<ui32>
++  func.return %0 : tensor<ui32>
++}
++
++// CHECK-LABEL: "op_partition_id"
++func.func @op_partition_id() -> tensor<ui32> {
++  // CHECK: "vhlo.partition_id_v1"() : () -> !vhlo.tensor_v1<!vhlo.ui32_v1>
++  %0 = "stablehlo.partition_id"() : () -> tensor<ui32>
++  func.return %0 : tensor<ui32>
++}
++
++// CHECK-LABEL: "op_reshape"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_reshape(%arg0: tensor<16xf32>) -> tensor<4x4xf32> {
++  // CHECK: "vhlo.reshape_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<4x4x!vhlo.f32_v1>
++  %0 = "stablehlo.reshape"(%arg0) : (tensor<16xf32>) -> tensor<4x4xf32>
++  func.return %0 : tensor<4x4xf32>
++}
++
++// CHECK-LABEL: "op_return"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_return(%arg0: tensor<i32>, %arg1: tensor<f32>) -> tensor<f32> {
++  //      CHECK: "vhlo.case_v1"(%[[ARG0]]) ({
++  // CHECK-NEXT:   "vhlo.return_v1"(%[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.case"(%arg0) ({
++    "stablehlo.return"(%arg1) : (tensor<f32>) -> ()
++  }) : (tensor<i32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_reverse"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_reverse(%arg0: tensor<16xf32>) -> tensor<16xf32> {
++  //      CHECK: "vhlo.reverse_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   dimensions = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.reverse"(%arg0) {
++    dimensions = array<i64: 0>
++  } : (tensor<16xf32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_rng_bit_generator"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_rng_bit_generator(%arg0: tensor<f32>) -> (tensor<f32>, tensor<f32>) {
++  //      CHECK: "vhlo.rng_bit_generator_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   rng_algorithm = #vhlo<rng_algorithm_v1 PHILOX>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>)
++  %0:2 = "stablehlo.rng_bit_generator"(%arg0) {
++    rng_algorithm = #stablehlo<rng_algorithm PHILOX>
++  } : (tensor<f32>) -> (tensor<f32>, tensor<f32>)
++  func.return %0#0, %0#1 : tensor<f32>, tensor<f32>
++}
++
++// CHECK-LABEL: "op_rng"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_rng(%arg0: tensor<f32>, %arg1: tensor<f32>, %arg2: tensor<0xindex>) -> tensor<f32> {
++  //      CHECK: "vhlo.rng_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   rng_distribution = #vhlo<rng_distribution_v1 NORMAL>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<0x!vhlo.index_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.rng"(%arg0, %arg1, %arg2) {
++    rng_distribution = #stablehlo<rng_distribution NORMAL>
++  } : (tensor<f32>, tensor<f32>, tensor<0xindex>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_round_nearest_afz"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_round_nearest_afz(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.round_nearest_afz_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.round_nearest_afz"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_round_nearest_even"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_round_nearest_even(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.round_nearest_even_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.round_nearest_even"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_rsqrt"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_rsqrt(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.rsqrt_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.rsqrt"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_scatter"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_scatter(%arg0: tensor<200x100x300xf32>, %arg1: tensor<10x2xi32>, %arg2: tensor<10x300xf32>) -> tensor<200x100x300xf32> {
++  //      CHECK: "vhlo.scatter_v2"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   input_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   inserted_window_dims = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   scatter_dims_to_operand_dims = #vhlo.tensor_v1<dense<[0, 1]> : tensor<2xi64>>,
++  // CHECK-SAME:   scatter_indices_batching_dims = #vhlo.tensor_v1<dense<> : tensor<0xi64>>,
++  // CHECK-SAME:   unique_indices = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   update_window_dims = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG3:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG4:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.add_v1"(%[[ARG3]], %[[ARG4]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<200x100x300x!vhlo.f32_v1>, !vhlo.tensor_v1<10x2x!vhlo.i32_v1>, !vhlo.tensor_v1<10x300x!vhlo.f32_v1>) -> !vhlo.tensor_v1<200x100x300x!vhlo.f32_v1>
++  %0 = "stablehlo.scatter"(%arg0, %arg1, %arg2) ({
++    ^bb0(%arg3: tensor<f32>, %arg4: tensor<f32>):
++      %1 = "stablehlo.add"(%arg3, %arg4) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    scatter_dimension_numbers = #stablehlo.scatter<
++      update_window_dims = [1],
++      inserted_window_dims = [0, 1],
++      scatter_dims_to_operand_dims = [0, 1],
++      index_vector_dim = 1
++    >,
++    indices_are_sorted = true,
++    unique_indices = true
++  } : (tensor<200x100x300xf32>, tensor<10x2xi32>, tensor<10x300xf32>) -> tensor<200x100x300xf32>
++  func.return %0 : tensor<200x100x300xf32>
++}
++
++// CHECK-LABEL: "op_scatter_with_batching_dims"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_scatter_with_batching_dims(%arg0: tensor<10x200x100x300xf32>, %arg1: tensor<10x2xi32>, %arg2: tensor<10x300xf32>) -> tensor<10x200x100x300xf32> {
++  //      CHECK: "vhlo.scatter_v2"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   index_vector_dim = #vhlo.integer_v1<1 : i64>,
++  // CHECK-SAME:   indices_are_sorted = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   input_batching_dims = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   inserted_window_dims = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   scatter_dims_to_operand_dims = #vhlo.tensor_v1<dense<[1, 2]> : tensor<2xi64>>,
++  // CHECK-SAME:   scatter_indices_batching_dims = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   unique_indices = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   update_window_dims = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG3:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG4:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.add_v1"(%[[ARG3]], %[[ARG4]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<10x200x100x300x!vhlo.f32_v1>, !vhlo.tensor_v1<10x2x!vhlo.i32_v1>, !vhlo.tensor_v1<10x300x!vhlo.f32_v1>) -> !vhlo.tensor_v1<10x200x100x300x!vhlo.f32_v1>
++  %0 = "stablehlo.scatter"(%arg0, %arg1, %arg2) ({
++    ^bb0(%arg3: tensor<f32>, %arg4: tensor<f32>):
++      %1 = "stablehlo.add"(%arg3, %arg4) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    scatter_dimension_numbers = #stablehlo.scatter<
++      update_window_dims = [1],
++      inserted_window_dims = [1, 2],
++      input_batching_dims = [0],
++      scatter_dims_to_operand_dims = [1, 2],
++      scatter_indices_batching_dims = [0],
++      index_vector_dim = 1
++    >,
++    indices_are_sorted = true,
++    unique_indices = true
++  } : (tensor<10x200x100x300xf32>, tensor<10x2xi32>, tensor<10x300xf32>) -> tensor<10x200x100x300xf32>
++  func.return %0 : tensor<10x200x100x300xf32>
++}
++
++// CHECK_lABEL: "op_scatter_with_promotable_types"
++func.func @op_scatter_with_promotable_types(%input_tensor: tensor<200x100x300xf32>,
++    %scatter_indices: tensor<10x2xi32>, %updates: tensor<10x300xf32>) ->
++      tensor<200x100x300xf64> {
++  //  CHECK: "vhlo.scatter_v2"(%[[ARG0:.*]], %[[ARG1:.*]], %[[ARG2:.*]])
++  //  CHECK:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>):
++  //  CHECK:     "vhlo.return_v1"(%[[VAL1:.*]]) : (!vhlo.tensor_v1<!vhlo.f64_v1>) -> ()
++  //  CHECK: }) : (!vhlo.tensor_v1<200x100x300x!vhlo.f32_v1>, !vhlo.tensor_v1<10x2x!vhlo.i32_v1>, !vhlo.tensor_v1<10x300x!vhlo.f32_v1>) -> !vhlo.tensor_v1<200x100x300x!vhlo.f64_v1>
++  %0 = "stablehlo.scatter" (%input_tensor, %scatter_indices, %updates) ({
++  ^bb0(%lhs: tensor<f64>, %rhs: tensor<f64>):
++    %add = stablehlo.add %lhs, %rhs : tensor<f64>
++    "stablehlo.return"(%add) : (tensor<f64>) -> ()
++  }) {
++    scatter_dimension_numbers = #stablehlo.scatter<
++      update_window_dims = [1],
++      inserted_window_dims = [0, 1],
++      scatter_dims_to_operand_dims = [0, 1],
++      index_vector_dim = 1
++    >,
++    indices_are_sorted = true,
++    unique_indices = true
++  } : (tensor<200x100x300xf32>, tensor<10x2xi32>, tensor<10x300xf32>) ->
++      tensor<200x100x300xf64>
++  func.return %0 : tensor<200x100x300xf64>
++}
++
++// CHECK-LABEL: "op_select_and_scatter"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_select_and_scatter(%arg0: tensor<10x24x24x64xf32>, %arg1: tensor<12x13x13x66xf32>, %arg2: tensor<f32>) -> tensor<10x24x24x64xf32> {
++  //      CHECK: "vhlo.select_and_scatter_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) <{
++  // CHECK-SAME:   padding = #vhlo.tensor_v1<dense<1> : tensor<4x2xi64>>,
++  // CHECK-SAME:   window_dimensions = #vhlo.tensor_v1<dense<[1, 2, 2, 1]> : tensor<4xi64>>,
++  // CHECK-SAME:   window_strides = #vhlo.tensor_v1<dense<[1, 2, 2, 1]> : tensor<4xi64>>
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG31:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG41:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL11:.*]] = "vhlo.compare_v1"(%[[ARG31]], %[[ARG41]]) <{compare_type = #vhlo<comparison_type_v1 TOTALORDER>, comparison_direction = #vhlo<comparison_direction_v1 GE>}> : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL11]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> ()
++  // CHECK-NEXT: }, {
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG32:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG42:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL12:.*]] = "vhlo.add_v1"(%[[ARG32]], %[[ARG42]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL12]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<10x24x24x64x!vhlo.f32_v1>, !vhlo.tensor_v1<12x13x13x66x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<10x24x24x64x!vhlo.f32_v1>
++  %0 = "stablehlo.select_and_scatter"(%arg0, %arg1, %arg2) ({
++    ^bb0(%arg3: tensor<f32>, %arg4: tensor<f32>):
++      %1 = "stablehlo.compare"(%arg3, %arg4) {compare_type = #stablehlo<comparison_type TOTALORDER>, comparison_direction = #stablehlo<comparison_direction GE>} : (tensor<f32>, tensor<f32>) -> tensor<i1>
++      "stablehlo.return"(%1) : (tensor<i1>) -> ()
++  }, {
++    ^bb0(%arg3: tensor<f32>, %arg4: tensor<f32>):
++      %1 = "stablehlo.add"(%arg3, %arg4) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++      "stablehlo.return"(%1) : (tensor<f32>) -> ()
++  }) {
++    window_dimensions = array<i64: 1, 2, 2, 1>,
++    window_strides = array<i64: 1, 2, 2, 1>,
++    padding = dense<1> : tensor<4x2xi64>
++  } : (tensor<10x24x24x64xf32>, tensor<12x13x13x66xf32>, tensor<f32>) -> tensor<10x24x24x64xf32>
++  func.return %0 : tensor<10x24x24x64xf32>
++}
++
++// CHECK-LABEL: "op_select_and_scatter_with_promotable_types"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_select_and_scatter_with_promotable_types(%arg0: tensor<10x24x24x64xf32>, %arg1: tensor<12x13x13x66xf32>, %arg2: tensor<f32>) -> tensor<10x24x24x64xf64> {
++  // CHECK: "vhlo.select_and_scatter_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]])
++  // CHECK:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f64_v1>):
++  // CHECK:     %[[VAL:.*]] = "vhlo.add_v1"(%[[ARG1]], %[[ARG2]]) : (!vhlo.tensor_v1<!vhlo.f64_v1>, !vhlo.tensor_v1<!vhlo.f64_v1>) -> !vhlo.tensor_v1<!vhlo.f64_v1>
++  // CHECK:     "vhlo.return_v1"(%[[VAL]]) : (!vhlo.tensor_v1<!vhlo.f64_v1>) -> ()
++  // CHECK: }) : (!vhlo.tensor_v1<10x24x24x64x!vhlo.f32_v1>, !vhlo.tensor_v1<12x13x13x66x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<10x24x24x64x!vhlo.f64_v1>
++  %0 = "stablehlo.select_and_scatter"(%arg0, %arg1, %arg2) ({
++    ^bb0(%arg3: tensor<f32>, %arg4: tensor<f32>):
++      %1 = "stablehlo.compare"(%arg3, %arg4) {compare_type = #stablehlo<comparison_type TOTALORDER>, comparison_direction = #stablehlo<comparison_direction GE>} : (tensor<f32>, tensor<f32>) -> tensor<i1>
++      "stablehlo.return"(%1) : (tensor<i1>) -> ()
++  }, {
++    ^bb0(%arg3: tensor<f64>, %arg4: tensor<f64>):
++      %1 = "stablehlo.add"(%arg3, %arg4) : (tensor<f64>, tensor<f64>) -> tensor<f64>
++      "stablehlo.return"(%1) : (tensor<f64>) -> ()
++  }) {
++    window_dimensions = array<i64: 1, 2, 2, 1>,
++    window_strides = array<i64: 1, 2, 2, 1>,
++    padding = dense<1> : tensor<4x2xi64>
++  } : (tensor<10x24x24x64xf32>, tensor<12x13x13x66xf32>, tensor<f32>) -> tensor<10x24x24x64xf64>
++  func.return %0 : tensor<10x24x24x64xf64>
++}
++
++// CHECK-LABEL: "op_select"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}}, %[[ARG2:.*]]: {{.*}})
++func.func @op_select(%arg0: tensor<i1>, %arg1: tensor<f32>, %arg2: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.select_v1"(%[[ARG0]], %[[ARG1]], %[[ARG2]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.select"(%arg0, %arg1, %arg2) : (tensor<i1>, tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_send"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_send(%arg0: tensor<f32>, %arg1: !stablehlo.token) -> !stablehlo.token {
++  //      CHECK: "vhlo.send_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   channel_id = #vhlo.integer_v1<0 : i64>,
++  // CHECK-SAME:   channel_type = #vhlo.integer_v1<2 : i64>,
++  // CHECK-SAME:   is_host_transfer = #vhlo.bool_v1<true>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.token_v1) -> !vhlo.token_v1
++  %0 = "stablehlo.send"(%arg0, %arg1) {
++    channel_handle = #stablehlo.channel_handle<handle = 0, type = 2>,
++    is_host_transfer = true
++  } : (tensor<f32>, !stablehlo.token) -> !stablehlo.token
++  func.return %0 : !stablehlo.token
++}
++
++// CHECK-LABEL: "op_set_dimension_size"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_set_dimension_size(%arg0: tensor<?xf32>, %arg1: tensor<i32>) -> tensor<16xf32> {
++  //      CHECK: "vhlo.set_dimension_size_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   dimension = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<?x!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.set_dimension_size"(%arg0, %arg1) {
++    dimension = 0 : i64
++  } : (tensor<?xf32>, tensor<i32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_shift_left"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_shift_left(%arg0: tensor<i32>, %arg1: tensor<i32>) -> tensor<i32> {
++  // CHECK: "vhlo.shift_left_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i32_v1>, !vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.i32_v1>
++  %0 = "stablehlo.shift_left"(%arg0, %arg1) : (tensor<i32>, tensor<i32>) -> tensor<i32>
++  func.return %0 : tensor<i32>
++}
++
++// CHECK-LABEL: "op_shift_right_arithmetic"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_shift_right_arithmetic(%arg0: tensor<i32>, %arg1: tensor<i32>) -> tensor<i32> {
++  // CHECK: "vhlo.shift_right_arithmetic_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i32_v1>, !vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.i32_v1>
++  %0 = "stablehlo.shift_right_arithmetic"(%arg0, %arg1) : (tensor<i32>, tensor<i32>) -> tensor<i32>
++  func.return %0 : tensor<i32>
++}
++
++// CHECK-LABEL: "op_shift_right_logical"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_shift_right_logical(%arg0: tensor<i32>, %arg1: tensor<i32>) -> tensor<i32> {
++  // CHECK: "vhlo.shift_right_logical_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i32_v1>, !vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.i32_v1>
++  %0 = "stablehlo.shift_right_logical"(%arg0, %arg1) : (tensor<i32>, tensor<i32>) -> tensor<i32>
++  func.return %0 : tensor<i32>
++}
++
++// CHECK-LABEL: "op_sign"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_sign(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.sign_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.sign"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_sine"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_sine(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.sine_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.sine"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_slice"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_slice(%arg0: tensor<16xf32>) -> tensor<4xf32> {
++  //      CHECK: "vhlo.slice_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   limit_indices = #vhlo.tensor_v1<dense<4> : tensor<1xi64>>,
++  // CHECK-SAME:   start_indices = #vhlo.tensor_v1<dense<0> : tensor<1xi64>>,
++  // CHECK-SAME:   strides = #vhlo.tensor_v1<dense<1> : tensor<1xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<4x!vhlo.f32_v1>
++  %0 = "stablehlo.slice"(%arg0) {
++    start_indices = array<i64: 0>,
++    limit_indices = array<i64: 4>,
++    strides = array<i64: 1>
++  } : (tensor<16xf32>) -> tensor<4xf32>
++  func.return %0 : tensor<4xf32>
++}
++
++// CHECK-LABEL: "op_sort"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_sort(%arg0: tensor<16xf32>) -> tensor<16xf32> {
++  //      CHECK: "vhlo.sort_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   dimension = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME:   is_stable = #vhlo.bool_v1<true>
++  // CHECK-SAME: }> ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>, %[[ARG2:arg.*]]: !vhlo.tensor_v1<!vhlo.f32_v1>):
++  // CHECK-NEXT:     %[[VAL1:.*]] = "vhlo.compare_v1"(%[[ARG1]], %[[ARG2]]) <{compare_type = #vhlo<comparison_type_v1 FLOAT>, comparison_direction = #vhlo<comparison_direction_v1 GT>}>
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[VAL1]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x!vhlo.f32_v1>
++  %0 = "stablehlo.sort"(%arg0) ({
++    ^bb0(%arg1: tensor<f32>, %arg2: tensor<f32>):
++      %1 = "stablehlo.compare"(%arg1, %arg2) {compare_type = #stablehlo<comparison_type FLOAT>, comparison_direction = #stablehlo<comparison_direction GT>} : (tensor<f32>, tensor<f32>) -> tensor<i1>
++      "stablehlo.return"(%1) : (tensor<i1>) -> ()
++  }) {
++    dimension = 0 : i64,
++    is_stable = true
++  } : (tensor<16xf32>) -> tensor<16xf32>
++  func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "op_sqrt"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_sqrt(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.sqrt_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.sqrt"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_subtract"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_subtract(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.subtract_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.subtract"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_tan"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_tan(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.tan_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.tan"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_tanh"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_tanh(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.tanh_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.tanh"(%arg0) : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_torch_index_select"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_torch_index_select(%arg0: tensor<5x1x5xf32>, %arg1: tensor<2xi32>) ->  tensor<2x1x5xf32> {
++  //      CHECK: "vhlo.torch_index_select_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   batch_dims = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME:   dim = #vhlo.integer_v1<0 : i64>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<5x1x5x!vhlo.f32_v1>, !vhlo.tensor_v1<2x!vhlo.i32_v1>) -> !vhlo.tensor_v1<2x1x5x!vhlo.f32_v1>
++  %0 = "stablehlo.torch_index_select"(%arg0, %arg1) {
++    dim = 0 : i64,
++    batch_dims = 0 : i64
++  } : (tensor<5x1x5xf32>, tensor<2xi32>) -> tensor<2x1x5xf32>
++  func.return %0 : tensor<2x1x5xf32>
++}
++
++// CHECK-LABEL: "op_transpose"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_transpose(%arg0: tensor<16x8xf32>) ->  tensor<8x16xf32> {
++  //      CHECK: "vhlo.transpose_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   permutation = #vhlo.tensor_v1<dense<[1, 0]> : tensor<2xi64>>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x8x!vhlo.f32_v1>) -> !vhlo.tensor_v1<8x16x!vhlo.f32_v1>
++  %0 = "stablehlo.transpose"(%arg0) {
++    permutation = array<i64: 1, 0>
++  } : (tensor<16x8xf32>) -> tensor<8x16xf32>
++  func.return %0 : tensor<8x16xf32>
++}
++
++// CHECK-LABEL: "op_triangular_solve"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_triangular_solve(%arg0: tensor<16x16xf32>, %arg1: tensor<16x16xf32>) ->  tensor<16x16xf32> {
++  //      CHECK: "vhlo.triangular_solve_v1"(%[[ARG0]], %[[ARG1]]) <{
++  // CHECK-SAME:   left_side = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   lower = #vhlo.bool_v1<true>,
++  // CHECK-SAME:   transpose_a = #vhlo<transpose_v1 NO_TRANSPOSE>,
++  // CHECK-SAME:   unit_diagonal = #vhlo.bool_v1<true>
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<16x16x!vhlo.f32_v1>, !vhlo.tensor_v1<16x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<16x16x!vhlo.f32_v1>
++  %0 = "stablehlo.triangular_solve"(%arg0, %arg1) {
++    left_side = true,
++    lower = true,
++    unit_diagonal = true,
++    transpose_a = #stablehlo<transpose NO_TRANSPOSE>
++  } : (tensor<16x16xf32>, tensor<16x16xf32>) -> tensor<16x16xf32>
++  func.return %0 : tensor<16x16xf32>
++}
++
++// CHECK-LABEL: "op_tuple"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_tuple(%arg0: tensor<f32>) -> tuple<tensor<f32>> {
++  // CHECK: "vhlo.tuple_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tuple_v1<!vhlo.tensor_v1<!vhlo.f32_v1>>
++  %0 = "stablehlo.tuple"(%arg0) : (tensor<f32>) -> tuple<tensor<f32>>
++  func.return %0 : tuple<tensor<f32>>
++}
++
++// CHECK-LABEL: "op_unary_einsum"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_unary_einsum(%arg0: tensor<8x16xf32>) -> tensor<8xf32> {
++  //      CHECK: "vhlo.unary_einsum_v1"(%[[ARG0]]) <{
++  // CHECK-SAME:   einsum_config = #vhlo.string_v1<"ab->a">
++  // CHECK-SAME: }> : (!vhlo.tensor_v1<8x16x!vhlo.f32_v1>) -> !vhlo.tensor_v1<8x!vhlo.f32_v1>
++  %0 = "stablehlo.unary_einsum"(%arg0) {
++    einsum_config = "ab->a"
++  } : (tensor<8x16xf32>) -> tensor<8xf32>
++  func.return %0 : tensor<8xf32>
++}
++
++// CHECK-LABEL: "op_uniform_dequantize"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_uniform_dequantize(%arg0: tensor<!quant.uniform<i8:f32, 34.0:16>>) -> tensor<f32> {
++  // CHECK: "vhlo.uniform_dequantize_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.quant_v1<!vhlo.i8_v1:!vhlo.f32_v1, 3.400000e+01:16, -128:127, 1>>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.uniform_dequantize"(%arg0) : (tensor<!quant.uniform<i8:f32, 34.0:16>>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "op_uniform_quantize"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_uniform_quantize(%arg0: tensor<f32>) -> tensor<!quant.uniform<i8:f32, 34.0:16>> {
++  // CHECK: "vhlo.uniform_quantize_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.quant_v1<!vhlo.i8_v1:!vhlo.f32_v1, 3.400000e+01:16, -128:127, 1>>
++  %0 = "stablehlo.uniform_quantize"(%arg0) : (tensor<f32>) -> tensor<!quant.uniform<i8:f32, 34.0:16>>
++  func.return %0 : tensor<!quant.uniform<i8:f32, 34.0:16>>
++}
++
++// CHECK-LABEL: "op_while"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @op_while(%arg0: tensor<i1>) -> tensor<i1> {
++  //      CHECK: "vhlo.while_v1"(%[[ARG0]]) ({
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.bool_v1>):
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> ()
++  // CHECK-NEXT:   }, {
++  // CHECK-NEXT:   ^[[BB:bb.*]](%[[ARG1:arg.*]]: !vhlo.tensor_v1<!vhlo.bool_v1>)
++  // CHECK-NEXT:     "vhlo.return_v1"(%[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> ()
++  // CHECK-NEXT: }) : (!vhlo.tensor_v1<!vhlo.bool_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.while"(%arg0) ({
++    ^bb0(%arg1: tensor<i1>):
++      "stablehlo.return"(%arg1) : (tensor<i1>) -> ()
++    }, {
++    ^bb0(%arg1: tensor<i1>):
++      "stablehlo.return"(%arg1) : (tensor<i1>) -> ()
++  }) : (tensor<i1>) -> tensor<i1>
++  func.return %0: tensor<i1>
++}
++
++// CHECK-LABEL: "op_xor"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @op_xor(%arg0: tensor<i1>, %arg1: tensor<i1>) -> tensor<i1> {
++  // CHECK: "vhlo.xor_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>, !vhlo.tensor_v1<!vhlo.bool_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.xor"(%arg0, %arg1) : (tensor<i1>, tensor<i1>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// ============ TYPES ============
++
++// CHECK-LABEL: "type_i1"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_i1(%arg0: tensor<i1>, %arg1: tensor<i1>) -> tensor<i1> {
++  // CHECK: "vhlo.and_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.bool_v1>, !vhlo.tensor_v1<!vhlo.bool_v1>) -> !vhlo.tensor_v1<!vhlo.bool_v1>
++  %0 = "stablehlo.and"(%arg0, %arg1) : (tensor<i1>, tensor<i1>) -> tensor<i1>
++  func.return %0 : tensor<i1>
++}
++
++// CHECK-LABEL: "type_i2"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_i2(%arg0: tensor<i2>, %arg1: tensor<i2>) -> tensor<i2> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i2_v1>, !vhlo.tensor_v1<!vhlo.i2_v1>) -> !vhlo.tensor_v1<!vhlo.i2_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<i2>, tensor<i2>) -> tensor<i2>
++  func.return %0 : tensor<i2>
++}
++
++// CHECK-LABEL: "type_i4"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_i4(%arg0: tensor<i4>, %arg1: tensor<i4>) -> tensor<i4> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i4_v1>, !vhlo.tensor_v1<!vhlo.i4_v1>) -> !vhlo.tensor_v1<!vhlo.i4_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<i4>, tensor<i4>) -> tensor<i4>
++  func.return %0 : tensor<i4>
++}
++
++// CHECK-LABEL: "type_i8"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_i8(%arg0: tensor<i8>, %arg1: tensor<i8>) -> tensor<i8> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i8_v1>, !vhlo.tensor_v1<!vhlo.i8_v1>) -> !vhlo.tensor_v1<!vhlo.i8_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<i8>, tensor<i8>) -> tensor<i8>
++  func.return %0 : tensor<i8>
++}
++
++// CHECK-LABEL: "type_i16"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_i16(%arg0: tensor<i16>, %arg1: tensor<i16>) -> tensor<i16> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i16_v1>, !vhlo.tensor_v1<!vhlo.i16_v1>) -> !vhlo.tensor_v1<!vhlo.i16_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<i16>, tensor<i16>) -> tensor<i16>
++  func.return %0 : tensor<i16>
++}
++
++// CHECK-LABEL: "type_i32"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_i32(%arg0: tensor<i32>, %arg1: tensor<i32>) -> tensor<i32> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i32_v1>, !vhlo.tensor_v1<!vhlo.i32_v1>) -> !vhlo.tensor_v1<!vhlo.i32_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<i32>, tensor<i32>) -> tensor<i32>
++  func.return %0 : tensor<i32>
++}
++
++// CHECK-LABEL: "type_i64"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_i64(%arg0: tensor<i64>, %arg1: tensor<i64>) -> tensor<i64> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.i64_v1>, !vhlo.tensor_v1<!vhlo.i64_v1>) -> !vhlo.tensor_v1<!vhlo.i64_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<i64>, tensor<i64>) -> tensor<i64>
++  func.return %0 : tensor<i64>
++}
++
++// CHECK-LABEL: "type_ui2"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_ui2(%arg0: tensor<ui2>, %arg1: tensor<ui2>) -> tensor<ui2> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.ui2_v1>, !vhlo.tensor_v1<!vhlo.ui2_v1>) -> !vhlo.tensor_v1<!vhlo.ui2_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<ui2>, tensor<ui2>) -> tensor<ui2>
++  func.return %0 : tensor<ui2>
++}
++
++// CHECK-LABEL: "type_ui4"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_ui4(%arg0: tensor<ui4>, %arg1: tensor<ui4>) -> tensor<ui4> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.ui4_v1>, !vhlo.tensor_v1<!vhlo.ui4_v1>) -> !vhlo.tensor_v1<!vhlo.ui4_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<ui4>, tensor<ui4>) -> tensor<ui4>
++  func.return %0 : tensor<ui4>
++}
++
++// CHECK-LABEL: "type_ui8"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_ui8(%arg0: tensor<ui8>, %arg1: tensor<ui8>) -> tensor<ui8> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.ui8_v1>, !vhlo.tensor_v1<!vhlo.ui8_v1>) -> !vhlo.tensor_v1<!vhlo.ui8_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<ui8>, tensor<ui8>) -> tensor<ui8>
++  func.return %0 : tensor<ui8>
++}
++
++// CHECK-LABEL: "type_ui16"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_ui16(%arg0: tensor<ui16>, %arg1: tensor<ui16>) -> tensor<ui16> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.ui16_v1>, !vhlo.tensor_v1<!vhlo.ui16_v1>) -> !vhlo.tensor_v1<!vhlo.ui16_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<ui16>, tensor<ui16>) -> tensor<ui16>
++  func.return %0 : tensor<ui16>
++}
++
++// CHECK-LABEL: "type_ui32"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_ui32(%arg0: tensor<ui32>, %arg1: tensor<ui32>) -> tensor<ui32> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.ui32_v1>, !vhlo.tensor_v1<!vhlo.ui32_v1>) -> !vhlo.tensor_v1<!vhlo.ui32_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<ui32>, tensor<ui32>) -> tensor<ui32>
++  func.return %0 : tensor<ui32>
++}
++
++// CHECK-LABEL: "type_ui64"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_ui64(%arg0: tensor<ui64>, %arg1: tensor<ui64>) -> tensor<ui64> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.ui64_v1>, !vhlo.tensor_v1<!vhlo.ui64_v1>) -> !vhlo.tensor_v1<!vhlo.ui64_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<ui64>, tensor<ui64>) -> tensor<ui64>
++  func.return %0 : tensor<ui64>
++}
++
++// CHECK-LABEL: "type_f4E2M1FN"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f4E2M1FN(%arg0: tensor<f4E2M1FN>, %arg1: tensor<f4E2M1FN>) -> tensor<f4E2M1FN> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f4E2M1FN_v1>, !vhlo.tensor_v1<!vhlo.f4E2M1FN_v1>) -> !vhlo.tensor_v1<!vhlo.f4E2M1FN_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f4E2M1FN>, tensor<f4E2M1FN>) -> tensor<f4E2M1FN>
++  func.return %0 : tensor<f4E2M1FN>
++}
++
++// CHECK-LABEL: "type_f6E2M3FN"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f6E2M3FN(%arg0: tensor<f6E2M3FN>, %arg1: tensor<f6E2M3FN>) -> tensor<f6E2M3FN> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f6E2M3FN_v1>, !vhlo.tensor_v1<!vhlo.f6E2M3FN_v1>) -> !vhlo.tensor_v1<!vhlo.f6E2M3FN_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f6E2M3FN>, tensor<f6E2M3FN>) -> tensor<f6E2M3FN>
++  func.return %0 : tensor<f6E2M3FN>
++}
++
++// CHECK-LABEL: "type_f6E3M2FN"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f6E3M2FN(%arg0: tensor<f6E3M2FN>, %arg1: tensor<f6E3M2FN>) -> tensor<f6E3M2FN> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f6E3M2FN_v1>, !vhlo.tensor_v1<!vhlo.f6E3M2FN_v1>) -> !vhlo.tensor_v1<!vhlo.f6E3M2FN_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f6E3M2FN>, tensor<f6E3M2FN>) -> tensor<f6E3M2FN>
++  func.return %0 : tensor<f6E3M2FN>
++}
++
++// CHECK-LABEL: "type_f8E3M4"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f8E3M4(%arg0: tensor<f8E3M4>, %arg1: tensor<f8E3M4>) -> tensor<f8E3M4> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f8E3M4_v1>, !vhlo.tensor_v1<!vhlo.f8E3M4_v1>) -> !vhlo.tensor_v1<!vhlo.f8E3M4_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f8E3M4>, tensor<f8E3M4>) -> tensor<f8E3M4>
++  func.return %0 : tensor<f8E3M4>
++}
++
++// CHECK-LABEL: "type_f8E4M3"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f8E4M3(%arg0: tensor<f8E4M3>, %arg1: tensor<f8E4M3>) -> tensor<f8E4M3> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f8E4M3_v1>, !vhlo.tensor_v1<!vhlo.f8E4M3_v1>) -> !vhlo.tensor_v1<!vhlo.f8E4M3_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f8E4M3>, tensor<f8E4M3>) -> tensor<f8E4M3>
++  func.return %0 : tensor<f8E4M3>
++}
++
++// CHECK-LABEL: "type_f8E4M3FN"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f8E4M3FN(%arg0: tensor<f8E4M3FN>, %arg1: tensor<f8E4M3FN>) -> tensor<f8E4M3FN> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f8E4M3FN_v1>, !vhlo.tensor_v1<!vhlo.f8E4M3FN_v1>) -> !vhlo.tensor_v1<!vhlo.f8E4M3FN_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f8E4M3FN>, tensor<f8E4M3FN>) -> tensor<f8E4M3FN>
++  func.return %0 : tensor<f8E4M3FN>
++}
++
++// CHECK-LABEL: "type_f8E5M2"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f8E5M2(%arg0: tensor<f8E5M2>, %arg1: tensor<f8E5M2>) -> tensor<f8E5M2> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f8E5M2_v1>, !vhlo.tensor_v1<!vhlo.f8E5M2_v1>) -> !vhlo.tensor_v1<!vhlo.f8E5M2_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f8E5M2>, tensor<f8E5M2>) -> tensor<f8E5M2>
++  func.return %0 : tensor<f8E5M2>
++}
++
++// CHECK-LABEL: "type_f8E4M3FNUZ"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f8E4M3FNUZ(%arg0: tensor<f8E4M3FNUZ>, %arg1: tensor<f8E4M3FNUZ>) -> tensor<f8E4M3FNUZ> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f8E4M3FNUZ_v1>, !vhlo.tensor_v1<!vhlo.f8E4M3FNUZ_v1>) -> !vhlo.tensor_v1<!vhlo.f8E4M3FNUZ_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f8E4M3FNUZ>, tensor<f8E4M3FNUZ>) -> tensor<f8E4M3FNUZ>
++  func.return %0 : tensor<f8E4M3FNUZ>
++}
++
++// CHECK-LABEL: "type_f8E4M3B11FNUZ"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f8E4M3B11FNUZ(%arg0: tensor<f8E4M3B11FNUZ>, %arg1: tensor<f8E4M3B11FNUZ>) -> tensor<f8E4M3B11FNUZ> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f8E4M3B11FNUZ_v1>, !vhlo.tensor_v1<!vhlo.f8E4M3B11FNUZ_v1>) -> !vhlo.tensor_v1<!vhlo.f8E4M3B11FNUZ_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f8E4M3B11FNUZ>, tensor<f8E4M3B11FNUZ>) -> tensor<f8E4M3B11FNUZ>
++  func.return %0 : tensor<f8E4M3B11FNUZ>
++}
++
++// CHECK-LABEL: "type_f8E5M2FNUZ"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f8E5M2FNUZ(%arg0: tensor<f8E5M2FNUZ>, %arg1: tensor<f8E5M2FNUZ>) -> tensor<f8E5M2FNUZ> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f8E5M2FNUZ_v1>, !vhlo.tensor_v1<!vhlo.f8E5M2FNUZ_v1>) -> !vhlo.tensor_v1<!vhlo.f8E5M2FNUZ_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f8E5M2FNUZ>, tensor<f8E5M2FNUZ>) -> tensor<f8E5M2FNUZ>
++  func.return %0 : tensor<f8E5M2FNUZ>
++}
++
++// CHECK-LABEL: "type_f8E8M0FNU"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f8E8M0FNU(%arg0: tensor<f8E8M0FNU>, %arg1: tensor<f8E8M0FNU>) -> tensor<f8E8M0FNU> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f8E8M0FNU_v1>, !vhlo.tensor_v1<!vhlo.f8E8M0FNU_v1>) -> !vhlo.tensor_v1<!vhlo.f8E8M0FNU_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f8E8M0FNU>, tensor<f8E8M0FNU>) -> tensor<f8E8M0FNU>
++  func.return %0 : tensor<f8E8M0FNU>
++}
++
++// CHECK-LABEL: "type_bf16"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_bf16(%arg0: tensor<bf16>, %arg1: tensor<bf16>) -> tensor<bf16> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.bf16_v1>, !vhlo.tensor_v1<!vhlo.bf16_v1>) -> !vhlo.tensor_v1<!vhlo.bf16_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<bf16>, tensor<bf16>) -> tensor<bf16>
++  func.return %0 : tensor<bf16>
++}
++
++// CHECK-LABEL: "type_f16"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f16(%arg0: tensor<f16>, %arg1: tensor<f16>) -> tensor<f16> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f16_v1>, !vhlo.tensor_v1<!vhlo.f16_v1>) -> !vhlo.tensor_v1<!vhlo.f16_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f16>, tensor<f16>) -> tensor<f16>
++  func.return %0 : tensor<f16>
++}
++
++// CHECK-LABEL: "type_f32"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f32(%arg0: tensor<f32>, %arg1: tensor<f32>) -> tensor<f32> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>, !vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f32>, tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: "type_f64"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_f64(%arg0: tensor<f64>, %arg1: tensor<f64>) -> tensor<f64> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.f64_v1>, !vhlo.tensor_v1<!vhlo.f64_v1>) -> !vhlo.tensor_v1<!vhlo.f64_v1>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<f64>, tensor<f64>) -> tensor<f64>
++  func.return %0 : tensor<f64>
++}
++
++// CHECK-LABEL: "type_complex_f32"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_complex_f32(%arg0: tensor<complex<f32>>, %arg1: tensor<complex<f32>>) -> tensor<complex<f32>> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f32_v1>>, !vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f32_v1>>) -> !vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f32_v1>>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<complex<f32>>, tensor<complex<f32>>) -> tensor<complex<f32>>
++  func.return %0 : tensor<complex<f32>>
++}
++
++// CHECK-LABEL: "type_complex_f64"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_complex_f64(%arg0: tensor<complex<f64>>, %arg1: tensor<complex<f64>>) -> tensor<complex<f64>> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f64_v1>>, !vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f64_v1>>) -> !vhlo.tensor_v1<!vhlo.complex_v1<!vhlo.f64_v1>>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<complex<f64>>, tensor<complex<f64>>) -> tensor<complex<f64>>
++  func.return %0 : tensor<complex<f64>>
++}
++
++// CHECK-LABEL: "type_tf32"
++// CHECK: #vhlo.type_v1<!vhlo.tf31_v1>
++func.func @type_tf32() attributes {stablehlo.attr = tf32 } {
++  return
++}
++
++// CHECK-LABEL: "type_none"
++// CHECK: #vhlo.type_v1<!vhlo.none_v1>
++func.func @type_none() attributes {stablehlo.attr = none } {
++  return
++}
++
++// CHECK-LABEL: "type_dynamism_ranked"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @type_dynamism_ranked(%arg0: tensor<?xf32>) -> tensor<?xf32> {
++  // CHECK: "vhlo.abs_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<?x!vhlo.f32_v1>) -> !vhlo.tensor_v1<?x!vhlo.f32_v1>
++  %0 = "stablehlo.abs"(%arg0) : (tensor<?xf32>) -> tensor<?xf32>
++  func.return %0 : tensor<?xf32>
++}
++
++// CHECK-LABEL: "type_per_tensor_quantization"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}, %[[ARG1:.*]]: {{.*}})
++func.func @type_per_tensor_quantization(%arg0: tensor<!quant.uniform<i8:f32, 34.0:16>>, %arg1: tensor<!quant.uniform<i8:f32, 34.0:16>>) -> tensor<!quant.uniform<i8:f32, 34.0:16>> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG1]]) : (!vhlo.tensor_v1<!vhlo.quant_v1<!vhlo.i8_v1:!vhlo.f32_v1, 3.400000e+01:16, -128:127, 1>>, !vhlo.tensor_v1<!vhlo.quant_v1<!vhlo.i8_v1:!vhlo.f32_v1, 3.400000e+01:16, -128:127, 1>>) -> !vhlo.tensor_v1<!vhlo.quant_v1<!vhlo.i8_v1:!vhlo.f32_v1, 3.400000e+01:16, -128:127, 1>>
++  %0 = "stablehlo.add"(%arg0, %arg1) : (tensor<!quant.uniform<i8:f32, 34.0:16>>, tensor<!quant.uniform<i8:f32, 34.0:16>>) -> tensor<!quant.uniform<i8:f32, 34.0:16>>
++  func.return %0 : tensor<!quant.uniform<i8:f32, 34.0:16>>
++}
++
++// CHECK-LABEL: "type_per_axis_quantization"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @type_per_axis_quantization(%arg0: tensor<2x!quant.uniform<i8:f32:0, {34.0:16, 34.0:16}>>) -> tensor<2x!quant.uniform<i8:f32:0, {34.0:16, 34.0:16}>> {
++  // CHECK: "vhlo.add_v1"(%[[ARG0]], %[[ARG0]]) : (!vhlo.tensor_v1<2x!vhlo.quant_per_axis_v1<!vhlo.i8_v1:!vhlo.f32_v1, 0, [3.400000e+01, 3.400000e+01], [16, 16], -128:127, 1>>, !vhlo.tensor_v1<2x!vhlo.quant_per_axis_v1<!vhlo.i8_v1:!vhlo.f32_v1, 0, [3.400000e+01, 3.400000e+01], [16, 16], -128:127, 1>>) -> !vhlo.tensor_v1<2x!vhlo.quant_per_axis_v1<!vhlo.i8_v1:!vhlo.f32_v1, 0, [3.400000e+01, 3.400000e+01], [16, 16], -128:127, 1>>
++  %0 = stablehlo.add %arg0, %arg0 : tensor<2x!quant.uniform<i8:f32:0, {34.0:16, 34.0:16}>>
++  func.return %0 : tensor<2x!quant.uniform<i8:f32:0, {34.0:16, 34.0:16}>>
++}
++
++//       CHECK: function_type = #vhlo.type_v1<!vhlo.func_v1<(!vhlo.token_v1) -> !vhlo.token_v1>>
++// CHECK-LABEL: "type_token_callee"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @type_token_callee(%arg0: !stablehlo.token) -> !stablehlo.token {
++  // CHECK: "vhlo.return_v1"(%[[ARG0]]) : (!vhlo.token_v1) -> ()
++  return %arg0 : !stablehlo.token
++}
++
++//       CHECK: function_type = #vhlo.type_v1<!vhlo.func_v1<(!vhlo.token_v1) -> !vhlo.token_v1>>
++// CHECK-LABEL: "type_token_caller"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @type_token_caller(%arg0: !stablehlo.token) -> !stablehlo.token {
++  // CHECK:      "vhlo.call_v1"(%[[ARG0]]) <{callee = #vhlo.string_v1<"type_token_callee">}
++  // CHECK-SAME: (!vhlo.token_v1) -> !vhlo.token_v1
++  %0 = func.call @type_token_callee(%arg0) : (!stablehlo.token) -> !stablehlo.token
++  return %0 : !stablehlo.token
++}
++
++// CHECK-LABEL: "type_tuple"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
++func.func @type_tuple(%arg0: tuple<tensor<f32>>) -> tuple<!stablehlo.token> {
++  %0 = "stablehlo.custom_call"(%arg0) {
++    call_target_name = "foo"
++  // CHECK: (!vhlo.tuple_v1<!vhlo.tensor_v1<!vhlo.f32_v1>>) -> !vhlo.tuple_v1<!vhlo.token_v1>
++  } : (tuple<tensor<f32>>) -> tuple<!stablehlo.token>
++  return %0 : tuple<!stablehlo.token>
++}
++
++// ============ DEPENDENCIES  ============
++
++func.func @composite_target(%arg0: tensor<f32>) -> tensor<f32> {
++  return %arg0: tensor<f32>
++}
+diff --ruN a/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo.mlir b/stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo.mlir
+--- stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo.mlir
++++ stablehlo/stablehlo/tests/vhlo/stablehlo_legalize_to_vhlo.mlir
+@@ -248,6 +248,36 @@
+     fft_length = array<i64: 16>
+   } : (tensor<9xcomplex<f32>>) -> tensor<16xf32>
+   func.return %0 : tensor<16xf32>
++}
++
++// CHECK-LABEL: "attr_result_accuracy_HIGHEST"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}
++func.func @attr_result_accuracy_HIGHEST(%arg0: tensor<8x16xf32>) -> tensor<8x16xf32> {
++  %0 = "stablehlo.exponential"(%arg0) {
++    // CHECK: result_accuracy = #vhlo.result_accuracy_v1<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #vhlo<result_accuracy_mode_v1 HIGHEST>>
++    result_accuracy = #stablehlo.result_accuracy<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #stablehlo.result_accuracy_mode<HIGHEST>>
++  } : (tensor<8x16xf32>) -> tensor<8x16xf32>
++  func.return %0 : tensor<8x16xf32>
++}
++
++// CHECK-LABEL: "attr_result_accuracy_TOLERANCE"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}
++func.func @attr_result_accuracy_TOLERANCE(%arg0: tensor<8x16xf32>) -> tensor<8x16xf32> {
++  %0 = "stablehlo.exponential"(%arg0) {
++    // CHECK: result_accuracy = #vhlo.result_accuracy_v1<atol = 1.000000e-05, rtol = 0.000000e+00, ulps = 1, mode = #vhlo<result_accuracy_mode_v1 TOLERANCE>>
++    result_accuracy = #stablehlo.result_accuracy<atol = 1.000000e-5, rtol = 0.000000e+00, ulps = 1, mode = #stablehlo.result_accuracy_mode<TOLERANCE>>
++  } : (tensor<8x16xf32>) -> tensor<8x16xf32>
++  func.return %0 : tensor<8x16xf32>
++}
++
++// CHECK-LABEL: "attr_result_accuracy_DEFAULT"
++// CHECK-NEXT: (%[[ARG0:.*]]: {{.*}}
++func.func @attr_result_accuracy_DEFAULT(%arg0: tensor<8x16xf32>) -> tensor<8x16xf32> {
++  %0 = "stablehlo.exponential"(%arg0) {
++    // CHECK: result_accuracy = #vhlo.result_accuracy_v1<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #vhlo<result_accuracy_mode_v1 DEFAULT>>
++    result_accuracy = #stablehlo.result_accuracy<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #stablehlo.result_accuracy_mode<DEFAULT>>
++  } : (tensor<8x16xf32>) -> tensor<8x16xf32>
++  func.return %0 : tensor<8x16xf32>
+ }
+ 
+ // GatherDimensionNumbers aka #stablehlo.gather is covered below.
+@@ -1621,7 +1651,7 @@
+ // CHECK-LABEL: "op_exponential"
+ // CHECK-NEXT: (%[[ARG0:.*]]: {{.*}})
+ func.func @op_exponential(%arg0: tensor<f32>) -> tensor<f32> {
+-  // CHECK: "vhlo.exponential_v1"(%[[ARG0]]) : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
++  // CHECK: "vhlo.exponential_v2"(%[[ARG0]]) <{result_accuracy = #vhlo.result_accuracy_v1<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #vhlo<result_accuracy_mode_v1 DEFAULT>>}> : (!vhlo.tensor_v1<!vhlo.f32_v1>) -> !vhlo.tensor_v1<!vhlo.f32_v1>
+   %0 = "stablehlo.exponential"(%arg0) : (tensor<f32>) -> tensor<f32>
+   func.return %0 : tensor<f32>
+ }
+diff --ruN a/stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir b/stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
+--- stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
++++ stablehlo/stablehlo/tests/vhlo/vhlo_attributes_invalid.mlir
+@@ -0,0 +1,26 @@
++// RUN: stablehlo-opt --vhlo-to-version=target=1.9.0 -verify-diagnostics --split-input-file %s
++
++func.func @invalid_array_element() -> () attributes {
++  // expected-error @+1 {{expected array of VHLO attriutes}}
++  vhlo.attr = #vhlo.array_v1<[#stablehlo<precision DEFAULT>]>
++} {
++  return
++}
++
++// -----
++
++func.func @invalid_dict_element_value() -> () attributes {
++  // expected-error @+1 {{expected VHLO attribute}}
++  vhlo.attr = #vhlo.dict_v1<{#vhlo.string_v1<"attr1"> = 3 : i32}>
++} {
++  return
++}
++
++// -----
++
++func.func @invalid_result_accuracy() -> () attributes {
++  // expected-error @+1 {{expected VHLO result accuracy mode}}
++  vhlo.attr = #vhlo.result_accuracy_v1<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #stablehlo.result_accuracy_mode<DEFAULT>>
++} {
++  return
++}
+diff --ruN a/stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade.1_8_0.mlir b/stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade.1_8_0.mlir
+--- stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade.1_8_0.mlir
++++ stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade.1_8_0.mlir
+@@ -0,0 +1,24 @@
++// RUN: stablehlo-opt --stablehlo-legalize-to-vhlo --vhlo-to-version='target=1.8.0' %s | FileCheck %s
++
++// ExpOp was changed in  v1.9.0 to have
++// result_accuracy attribute. Ensure that serializing for 1.8.0 is valid and targets the
++// v1.8.0 opset.
++//
++// This will catch issues in op `isLegal` checks:
++//   op.minVersion() <= target <= op.maxVersion()
++
++// CHECK-LABEL: vhlo.func_v1 @exp_op
++func.func public @exp_op(%arg0: tensor<f32>) -> tensor<f32> {
++  // CHECK: vhlo.exponential_v1
++  %0 = "stablehlo.exponential"(%arg0) : (tensor<f32>) -> tensor<f32>
++  return %0 : tensor<f32>
++}
++
++// CHECK-LABEL: vhlo.func_v1 @exp_op_default
++func.func @exp_op_default(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.exponential"(%arg0) {
++    // CHECK: vhlo.exponential_v1
++    result_accuracy = #stablehlo.result_accuracy<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #stablehlo.result_accuracy_mode<DEFAULT>>
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
+diff --ruN a/stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_invalid.1_8_0.mlir b/stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_invalid.1_8_0.mlir
+--- stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_invalid.1_8_0.mlir
++++ stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_invalid.1_8_0.mlir
+@@ -0,0 +1,22 @@
++// RUN: stablehlo-opt --stablehlo-legalize-to-vhlo --vhlo-to-version='target=1.8.0' --verify-diagnostics --split-input-file %s
++
++
++func.func @attr_result_accuracy_default(%arg0: tensor<f32>) -> tensor<f32> {
++  %0 = "stablehlo.exponential"(%arg0) {
++    // CHECK: vhlo.exponential_v1
++    result_accuracy = #stablehlo.result_accuracy<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #stablehlo.result_accuracy_mode<DEFAULT>>
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
++// -----
++
++// expected-error @-3 {{failed to convert VHLO to v1.8.0}}
++func.func @attr_result_accuracy_highest(%arg0: tensor<f32>) -> tensor<f32> {
++  // expected-error @+1 {{failed to legalize operation 'vhlo.exponential_v2' that was explicitly marked illegal}}
++  %0 = "stablehlo.exponential"(%arg0) {
++    result_accuracy = #stablehlo.result_accuracy<atol = 0.000000e+00, rtol = 0.000000e+00, ulps = 0, mode = #stablehlo.result_accuracy_mode<HIGHEST>>
++  } : (tensor<f32>) -> tensor<f32>
++  func.return %0 : tensor<f32>
++}
++
+diff --ruN a/stablehlo/stablehlo/transforms/MapStablehloToVhlo.h b/stablehlo/stablehlo/transforms/MapStablehloToVhlo.h
+--- stablehlo/stablehlo/transforms/MapStablehloToVhlo.h
++++ stablehlo/stablehlo/transforms/MapStablehloToVhlo.h
+@@ -94,7 +94,7 @@
+ MAP_STABLEHLO_TO_VHLO(DynamicUpdateSliceOp, V1)
+ MAP_STABLEHLO_TO_VHLO(EinsumOp, V1)
+ MAP_STABLEHLO_TO_VHLO(Expm1Op, V1)
+-MAP_STABLEHLO_TO_VHLO(ExpOp, V1)
++MAP_STABLEHLO_TO_VHLO(ExpOp, V2)
+ MAP_STABLEHLO_TO_VHLO(FftOp, V1)
+ MAP_STABLEHLO_TO_VHLO(FloorOp, V1)
+ MAP_STABLEHLO_TO_VHLO(GatherOp, V2)
+diff --ruN a/stablehlo/stablehlo/transforms/Passes.h b/stablehlo/stablehlo/transforms/Passes.h
+--- stablehlo/stablehlo/transforms/Passes.h
++++ stablehlo/stablehlo/transforms/Passes.h
+@@ -25,12 +25,17 @@
+ #include "mlir/Pass/Pass.h"
+ #include "mlir/Support/LogicalResult.h"
+ #include "mlir/Transforms/DialectConversion.h"
++#include "mlir/Transforms/GreedyPatternRewriteDriver.h"
+ #include "stablehlo/dialect/Version.h"
+ 
+ namespace mlir {
+ namespace stablehlo {
+ 
+ #define GEN_PASS_DECL
++
++std::unique_ptr<::mlir::Pass> createStablehloAggressiveSimplificationPass(
++    GreedyRewriteConfig config);
++
+ #define GEN_PASS_REGISTRATION
+ #include "stablehlo/transforms/Passes.h.inc"
+ 
+diff --ruN a/stablehlo/stablehlo/transforms/StablehloAggressiveSimplification.cpp b/stablehlo/stablehlo/transforms/StablehloAggressiveSimplification.cpp
+--- stablehlo/stablehlo/transforms/StablehloAggressiveSimplification.cpp
++++ stablehlo/stablehlo/transforms/StablehloAggressiveSimplification.cpp
+@@ -11,6 +11,7 @@
+ #include <cstddef>
+ #include <cstdint>
+ #include <iterator>
++#include <memory>
+ #include <optional>
+ #include <utility>
+ 
+@@ -21,6 +22,7 @@
+ #include "llvm/ADT/SmallVector.h"
+ #include "llvm/ADT/SmallVectorExtras.h"
+ #include "llvm/Support/ErrorHandling.h"
++#include "mlir/Dialect/Arith/IR/Arith.h"
+ #include "mlir/IR/Attributes.h"
+ #include "mlir/IR/Block.h"
+ #include "mlir/IR/Builders.h"
+@@ -38,6 +40,7 @@
+ #include "mlir/IR/TypeUtilities.h"
+ #include "mlir/IR/Value.h"
+ #include "mlir/IR/ValueRange.h"
++#include "mlir/Pass/Pass.h"
+ #include "mlir/Rewrite/FrozenRewritePatternSet.h"
+ #include "mlir/Support/LLVM.h"
+ #include "mlir/Support/LogicalResult.h"
+@@ -1447,12 +1450,18 @@
+       return rewriter.notifyMatchFailure(
+           op, "defining operation of unexpected type");
+ 
++    // Reshape and broadcast are not allowed to have dynamic shape.
++    Value result = op->getResult(0);
++    if (isa<ReshapeOp, BroadcastOp>(definingOp) &&
++        !cast<ShapedType>(result.getType()).hasStaticShape())
++      return rewriter.notifyMatchFailure(
++          op, "cannot reorder around reshape/broadcast with dynamic shape");
++
+     // Only reorder if the defining op has no other uses.
+     if (!llvm::hasSingleElement(definingOp->getResult(0).getUses()))
+       return rewriter.notifyMatchFailure(op, "operation has more than one use");
+ 
+     Value input = definingOp->getOperand(0);
+-    Value result = op->getResult(0);
+     auto intermediateType = cast<ShapedType>(input.getType())
+                                 .clone(getElementTypeOrSelf(result.getType()));
+ 
+@@ -1470,6 +1479,9 @@
+ struct StablehloAggressiveSimplificationPass final
+     : impl::StablehloAggressiveSimplificationPassBase<
+           StablehloAggressiveSimplificationPass> {
++  StablehloAggressiveSimplificationPass() = default;
++  StablehloAggressiveSimplificationPass(GreedyRewriteConfig config)
++      : config(config) {}
+   LogicalResult initialize(MLIRContext *context) override {
+     RewritePatternSet patterns_(context);
+     populateStablehloCanonicalizationPatterns(context, &patterns_);
+@@ -1478,11 +1490,12 @@
+   }
+ 
+   void runOnOperation() override {
+-    if (failed(applyPatternsGreedily(getOperation(), patterns)))
++    if (failed(applyPatternsGreedily(getOperation(), patterns, config)))
+       signalPassFailure();
+   }
+ 
+  private:
++  GreedyRewriteConfig config;
+   FrozenRewritePatternSet patterns;
+ };
+ 
+@@ -1515,5 +1528,10 @@
+             DynamicReshapeOpIsStatic, DynamicIotaIsStatic>(context);
+ }
+ 
++std::unique_ptr<Pass> createStablehloAggressiveSimplificationPass(
++    GreedyRewriteConfig config) {
++  return std::make_unique<StablehloAggressiveSimplificationPass>(config);
++}
++
+ }  // namespace stablehlo
+ }  // namespace mlir
+diff --ruN a/stablehlo/stablehlo/transforms/StablehloComplexMathExpanderPatterns.td b/stablehlo/stablehlo/transforms/StablehloComplexMathExpanderPatterns.td
+--- stablehlo/stablehlo/transforms/StablehloComplexMathExpanderPatterns.td
++++ stablehlo/stablehlo/transforms/StablehloComplexMathExpanderPatterns.td
+@@ -683,12 +683,15 @@
+ //     Notice that for `y != 0`, neither `cos(y)` nor `sin(y)` is never
+ //     zero on the set of floating point numbers.
+ //
+-def ExpOp_ComplexElementType_ComplexMathExpander: Pat<(StableHLO_ExpOp ComplexElementType:$z),
++def ConstDefaultResultAccuracyAttr :
++  ConstantAttr<StableHLO_ResultAccuracyAttr, "::mlir::stablehlo::ResultAccuracyMode::DEFAULT">;
++
++def ExpOp_ComplexElementType_ComplexMathExpander: Pat<(StableHLO_ExpOp ComplexElementType:$z, ConstDefaultResultAccuracyAttr),
+   (StableHLO_ComplexOp
+     (StableHLO_SelectOp
+       (StableHLO_CompareOp:$eq_e_constant_posinf
+        (StableHLO_ExpOp:$e
+-         (StableHLO_RealOp:$x $z)),
++         (StableHLO_RealOp:$x $z), ConstDefaultResultAccuracyAttr),
+        (StableHLO_ConstantLikePosInfValue $x),
+         StableHLO_ComparisonDirectionValue<"EQ">,
+         (STABLEHLO_DEFAULT_COMPARISON_TYPE)),
+@@ -697,7 +700,7 @@
+           (StableHLO_ExpOp:$e2
+             (StableHLO_MulOp
+               $x,
+-              (StableHLO_ConstantLike<"0.5"> $x))),
++              (StableHLO_ConstantLike<"0.5"> $x)), ConstDefaultResultAccuracyAttr),
+           (StableHLO_CosineOp:$cs
+             (StableHLO_ImagOp:$y $z))),
+         $e2),
+diff --ruN a/stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp b/stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
+--- stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
++++ stablehlo/stablehlo/transforms/StablehloLegalizeToVhlo.cpp
+@@ -19,6 +19,7 @@
+ 
+ #include "llvm/Support/Casting.h"
+ #include "llvm/Support/Debug.h"
++#include "llvm/Support/ErrorHandling.h"
+ #include "mlir/Dialect/Func/IR/FuncOps.h"
+ #include "mlir/IR/Attributes.h"
+ #include "mlir/IR/Builders.h"
+@@ -129,6 +130,16 @@
+   }
+   if (auto attr = dyn_cast<stablehlo::TransposeAttr>(stablehloAttr)) {
+     RETURN_CONVERTED_ENUM_ATTR(Transpose, V1);
++  }
++  if (auto attr = dyn_cast<stablehlo::ResultAccuracyModeAttr>(stablehloAttr)) {
++    RETURN_CONVERTED_ENUM_ATTR(ResultAccuracyMode, V1);
++  }
++  if (auto attr = dyn_cast<stablehlo::ResultAccuracyAttr>(stablehloAttr)) {
++    auto modeAttr = convertGeneric(attr.getMode(), typeConverter);
++    if (!modeAttr) return {};
++    return vhlo::ResultAccuracyV1Attr::get(attr.getContext(), attr.getAtol(),
++                                           attr.getRtol(), attr.getUlps(),
++                                           modeAttr);
+   }
+   if (stablehloAttr.getDialect().getNamespace() ==
+       stablehlo::StablehloDialect::getDialectNamespace()) {
+@@ -815,6 +826,19 @@
+       }
+     }
+   }
++  if constexpr (std::is_same<StablehloOpTy, stablehlo::ExpOp>::value) {
++    if (!stablehloOp.getResultAccuracyAttr())
++      addDefaultAttr("result_accuracy",
++                     stablehlo::ResultAccuracyAttr::get(
++                         pattern.getContext(),
++                         /*atol=*/APFloat(0.0),
++                         /*rtol=*/APFloat(0.0),
++                         /*ulps=*/0,
++                         /*mode=*/
++                         stablehlo::ResultAccuracyModeAttr::get(
++                             pattern.getContext(),
++                             stablehlo::ResultAccuracyMode::DEFAULT)));
++  }
+   if constexpr (std::is_same<StablehloOpTy,
+                              stablehlo::DynamicBroadcastInDimOp>::value) {
+     if (!stablehloOp.getKnownExpandingDimensionsAttr())
+diff --ruN a/stablehlo/stablehlo/transforms/StablehloRefineShapes.cpp b/stablehlo/stablehlo/transforms/StablehloRefineShapes.cpp
+--- stablehlo/stablehlo/transforms/StablehloRefineShapes.cpp
++++ stablehlo/stablehlo/transforms/StablehloRefineShapes.cpp
+@@ -109,12 +109,14 @@
+       // their operands and results. Any operand type in these ops can change
+       // within what's supported by `inferMostSpecificType` without breaking
+       // verification of the op.
+-      if (isa<chlo::ChloDialect, StablehloDialect>(user->getDialect()))
++      if (isa<chlo::ChloDialect, StablehloDialect>(
++              user->getDialect()))
+         continue;
+       // TODO(bartchr): Consider if the dialect allow-listing approach is too
+       // strict. In the meantime, allow some shape interop with the shardy
+       // dialect.
+-      if (user->getDialect()->getNamespace() == "sdy") continue;
++      if (user->getDialect()->getNamespace() == "sdy")
++        continue;
+ 
+       // Simply changing operand type of `func.return` won't work because
+       // that won't update the FunctionType of the enclosing `func.func`.
+diff --ruN a/stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp b/stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
+--- stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
++++ stablehlo/stablehlo/transforms/VhloLegalizeToStablehlo.cpp
+@@ -23,6 +23,7 @@
+ #include "llvm/Support/AllocatorBase.h"
+ #include "llvm/Support/Casting.h"
+ #include "llvm/Support/Debug.h"
++#include "llvm/Support/ErrorHandling.h"
+ #include "mlir/Dialect/Func/IR/FuncOps.h"
+ #include "mlir/IR/Attributes.h"
+ #include "mlir/IR/BuiltinAttributes.h"
+@@ -168,6 +169,17 @@
+     auto builtinType = typeConverter->convertType(attr.getValue());
+     if (!builtinType) return {};
+     return TypeAttr::get(builtinType);
++  }
++  if (auto attr = dyn_cast<vhlo::ResultAccuracyModeV1Attr>(vhloAttr)) {
++    RETURN_CONVERTED_ENUM_ATTR(ResultAccuracyMode, V1);
++  }
++  if (auto attr = dyn_cast<vhlo::ResultAccuracyV1Attr>(vhloAttr)) {
++    auto modeAttr = dyn_cast_or_null<stablehlo::ResultAccuracyModeAttr>(
++        convertGeneric(attr.getMode(), typeConverter));
++    if (!modeAttr) return {};
++    return stablehlo::ResultAccuracyAttr::get(attr.getContext(), attr.getAtol(),
++                                              attr.getRtol(), attr.getUlps(),
++                                              modeAttr);
+   }
+ 
+   // All VHLO Attributes must be converted by now.
+@@ -737,6 +749,13 @@
+          });
+ }
+ 
++bool isDefaultResultAccuracyAttribute(Attribute vhloAttr) {
++  auto attr = dyn_cast_or_null<vhlo::ResultAccuracyV1Attr>(vhloAttr);
++  return attr.getAtol().isZero() && attr.getRtol().isZero() &&
++         attr.getUlps() == 0 &&
++         dyn_cast<vhlo::ResultAccuracyModeV1Attr>(attr.getMode()).getValue() ==
++             vhlo::ResultAccuracyModeV1::DEFAULT;
++}
+ template <typename T>
+ bool isSplatTensor(const ConversionPattern& pattern, Attribute vhloAttr,
+                    T splatValue) {
+@@ -897,6 +916,11 @@
+       eraseAttrs(vhloAttrs, "dimension");
+     if (isBoolean(vhloOp.getIsStableAttr(), false))
+       eraseAttrs(vhloAttrs, "is_stable");
++  }
++  if constexpr (std::is_same<VhloOpTy, vhlo::ExpOpV2>::value) {
++    if (isDefaultResultAccuracyAttribute(vhloOp.getResultAccuracyAttr())) {
++      eraseAttrs(vhloAttrs, "result_accuracy");
++    }
+   }
+   return success();
+ }
+diff --ruN a/stablehlo/stablehlo/transforms/VhloToVersion.cpp b/stablehlo/stablehlo/transforms/VhloToVersion.cpp
+--- stablehlo/stablehlo/transforms/VhloToVersion.cpp
++++ stablehlo/stablehlo/transforms/VhloToVersion.cpp
+@@ -139,6 +139,8 @@
+     return isLegalType(tensorAttr.getType(), targetVersion);
+   if (auto typeAttr = dyn_cast<TypeV1Attr>(attr))
+     return isLegalType(typeAttr.getValue(), targetVersion);
++  if (auto resultAccuracyAttr = dyn_cast<ResultAccuracyV1Attr>(attr))
++    return isLegalAttribute(resultAccuracyAttr.getMode(), targetVersion);
+ 
+   // Is VHLO and valid version, success.
+   return success();
+@@ -324,6 +326,22 @@
+       denseElements.getRawData());
+ }
+ 
++bool isDefaultResultAccuracy(Attribute attr) {
++  auto resultAccuracy = dyn_cast<ResultAccuracyV1Attr>(attr);
++  auto default_mode = ResultAccuracyModeV1Attr::get(
++      attr.getContext(), ResultAccuracyModeV1::DEFAULT);
++  return resultAccuracy.getAtol().isZero() &&
++         resultAccuracy.getRtol().isZero() && resultAccuracy.getUlps() == 0 &&
++         resultAccuracy.getMode() == default_mode;
++}
++
++ResultAccuracyV1Attr getDefaultResultAccuracy(OpBuilder& builder) {
++  return ResultAccuracyV1Attr::get(
++      builder.getContext(), APFloat(0.0), APFloat(0.0), 0,
++      ResultAccuracyModeV1Attr::get(builder.getContext(),
++                                    ResultAccuracyModeV1::DEFAULT));
++}
++
+ // DRR has limited support for ops with regions
+ struct ScatterOpV2ToV1 : public OpRewritePattern<ScatterOpV2> {
+   using OpRewritePattern<ScatterOpV2>::OpRewritePattern;
+@@ -393,6 +411,40 @@
+   }
+ };
+ 
++struct ExpOpV1ToV2 : public OpRewritePattern<ExpOpV1> {
++  using OpRewritePattern<ExpOpV1>::OpRewritePattern;
++
++  LogicalResult matchAndRewrite(ExpOpV1 op,
++                                PatternRewriter& rewriter) const override {
++    ResultAccuracyV1Attr defaultResultAccuracy = ResultAccuracyV1Attr::get(
++        rewriter.getContext(), APFloat(0.0), APFloat(0.0), 0,
++        ResultAccuracyModeV1Attr::get(rewriter.getContext(),
++                                      ResultAccuracyModeV1::DEFAULT));
++    rewriter.replaceOpWithNewOp<ExpOpV2>(
++        op, op->getResultTypes(), op.getOperand(), defaultResultAccuracy);
++    return success();
++  }
++};
++
++struct ExpOpV2ToV1 : public OpRewritePattern<ExpOpV2> {
++  using OpRewritePattern<ExpOpV2>::OpRewritePattern;
++
++  LogicalResult matchAndRewrite(ExpOpV2 op,
++                                PatternRewriter& rewriter) const override {
++    auto defaultResultAccuracy = ResultAccuracyV1Attr::get(
++        rewriter.getContext(), APFloat(0.0), APFloat(0.0), 0,
++        ResultAccuracyModeV1Attr::get(rewriter.getContext(),
++                                      ResultAccuracyModeV1::DEFAULT));
++    if (op.getResultAccuracy() != defaultResultAccuracy) {
++      return rewriter.notifyMatchFailure(op,
++                                         "non-default result accuracy attr");
++    }
++    rewriter.replaceOpWithNewOp<ExpOpV1>(op, op->getResultTypes(),
++                                         op.getOperand());
++    return success();
++  }
++};
++
+ #include "stablehlo/transforms/VhloToVersionPatterns.h.inc"
+ 
+ }  // namespace
+@@ -405,6 +457,7 @@
+   vhlo::populateWithGenerated(*patterns);
+   patterns->add<vhlo::ScatterOpV1ToV2, vhlo::ScatterOpV2ToV1>(context);
+   patterns->add<vhlo::AllReduceOpV1ToV2, vhlo::AllReduceOpV2ToV1>(context);
++  patterns->add<vhlo::ExpOpV1ToV2, vhlo::ExpOpV2ToV1>(context);
+ }
+ 
+ }  // namespace stablehlo
+diff --ruN a/stablehlo/stablehlo/transforms/VhloToVersionPatterns.td b/stablehlo/stablehlo/transforms/VhloToVersionPatterns.td
+--- stablehlo/stablehlo/transforms/VhloToVersionPatterns.td
++++ stablehlo/stablehlo/transforms/VhloToVersionPatterns.td
+@@ -15,6 +15,9 @@
+ 
+ include "mlir/IR/OpBase.td"
+ include "stablehlo/dialect/VhloOps.td"
++include "mlir/IR/CommonAttrConstraints.td"
++include "stablehlo/dialect/VhloEnums.td"
++include "stablehlo/dialect/VhloAttrs.td"
+ 
+ def VHLO_GetEmptyDims : NativeCodeCall<"getEmptyI64Tensor($_builder)">;
+ 
+@@ -31,6 +34,11 @@
+ def VHLO_GetFirstOperand : NativeCodeCall<"$0.front()">;
+ 
+ def VHLO_WrapInVector : NativeCodeCall<"{$0}">;
++
++def VHLO_GetDefaultResultAccuracyAttr : NativeCodeCall<"getDefaultResultAccuracy($_builder)">;
++
++
++def VHLO_DefaultResultAccuracy : AttrConstraint<CPred<"isDefaultResultAccuracy($_self)">, "Default result accuracy">;
+ 
+ def DynamicConvUpgradeV1ToV2:
+   Pat<(VHLO_DynamicConvOpV1 $lhs, $rhs, $d_padding, $window_strides, $padding, $lhs_dilation, $rhs_dilation, $window_reversal, $input_batch_dimension, $input_feature_dimension, $input_spatial_dimensions, $kernel_input_feature_dimension, $kernel_output_feature_dimension, $kernel_spatial_dimensions, $output_batch_dimension, $output_feature_dimension, $output_spatial_dimensions, $feature_group_count, $batch_group_count, $precision_config),
+@@ -83,3 +91,11 @@
+   Pat<(VHLO_DotGeneralOpV1 $lhs, $rhs, $lhs_batching_dimensions, $rhs_batching_dimensions, $lhs_contracting_dimensions, $rhs_contracting_dimensions, $precision_config),
+       (VHLO_DotGeneralOpV2 $lhs, $rhs, $lhs_batching_dimensions, $rhs_batching_dimensions, $lhs_contracting_dimensions, $rhs_contracting_dimensions, $precision_config,
+          (VHLO_GetNoneType), (VHLO_GetNoneType), (VHLO_GetNoneType), (VHLO_GetNoneType), (VHLO_GetNoneType), (VHLO_GetNoneType), (VHLO_GetNoneType))>;
++
++def ExpOpDowngradeV2ToV1 :
++  Pat<(VHLO_ExpOpV2 $operand, VHLO_DefaultResultAccuracy:$result_accuracy),
++      (VHLO_ExpOpV1 $operand)>;
++
++def ExpOpUpgradeV1ToV2 :
++  Pat<(VHLO_ExpOpV1 $operand),
++      (VHLO_ExpOpV2 $operand, (VHLO_GetDefaultResultAccuracyAttr))>;
 
diff --git a/third_party/stablehlo/workspace.bzl b/third_party/stablehlo/workspace.bzl
index 205c21b..bd083a8 100644
--- a/third_party/stablehlo/workspace.bzl
+++ b/third_party/stablehlo/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive", "tf_mirror_urls")
 
 def repo():
     #
-    STABLEHLO_COMMIT = "48a1e14edc8219577fcad53de1924876f855f431"
-    STABLEHLO_SHA256 = "b35e16723afe3ea142c4fe6a44e56885985b28e1b036945f4c2d230e1a8907cb"
+    STABLEHLO_COMMIT = "c27ba678a712a401e4a6db75ec0ef9e1ce9e1777"
+    STABLEHLO_SHA256 = "af3ade86200a10ef75d816147db1b5151aa2788da99289ef133e49453aee3f14"
     #
 
     tf_http_archive(
